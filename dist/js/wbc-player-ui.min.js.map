{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/ts/arrayutils.ts","src/ts/browserutils.ts","src/ts/components/adclickoverlay.ts","src/ts/components/admessagelabel.ts","src/ts/components/adskipbutton.ts","src/ts/components/airplaytogglebutton.ts","src/ts/components/audioonlyoverlay.ts","src/ts/components/audioqualityselectbox.ts","src/ts/components/audiotrackselectbox.ts","src/ts/components/bufferingoverlay.ts","src/ts/components/button.ts","src/ts/components/caststatusoverlay.ts","src/ts/components/casttogglebutton.ts","src/ts/components/castuicontainer.ts","src/ts/components/clickoverlay.ts","src/ts/components/closebutton.ts","src/ts/components/component.ts","src/ts/components/container.ts","src/ts/components/controlbar.ts","src/ts/components/errormessageoverlay.ts","src/ts/components/fullscreentogglebutton.ts","src/ts/components/hugeplaybacktogglebutton.ts","src/ts/components/hugereplaybutton.ts","src/ts/components/itemselectionlist.ts","src/ts/components/label.ts","src/ts/components/listselector.ts","src/ts/components/metadatalabel.ts","src/ts/components/pictureinpicturetogglebutton.ts","src/ts/components/playbackspeedselectbox.ts","src/ts/components/playbacktimelabel.ts","src/ts/components/playbacktogglebutton.ts","src/ts/components/playbacktoggleoverlay.ts","src/ts/components/recommendationoverlay.ts","src/ts/components/seekbar.ts","src/ts/components/seekbarlabel.ts","src/ts/components/selectbox.ts","src/ts/components/settingspanel.ts","src/ts/components/settingstogglebutton.ts","src/ts/components/spacer.ts","src/ts/components/subtitleoverlay.ts","src/ts/components/subtitleselectbox.ts","src/ts/components/subtitlesettings/backgroundcolorselectbox.ts","src/ts/components/subtitlesettings/backgroundopacityselectbox.ts","src/ts/components/subtitlesettings/characteredgeselectbox.ts","src/ts/components/subtitlesettings/fontcolorselectbox.ts","src/ts/components/subtitlesettings/fontfamilyselectbox.ts","src/ts/components/subtitlesettings/fontopacityselectbox.ts","src/ts/components/subtitlesettings/fontsizeselectbox.ts","src/ts/components/subtitlesettings/subtitlesettingsbutton.ts","src/ts/components/subtitlesettings/subtitlesettingsclosebutton.ts","src/ts/components/subtitlesettings/subtitlesettingselectbox.ts","src/ts/components/subtitlesettings/subtitlesettingslabel.ts","src/ts/components/subtitlesettings/subtitlesettingsmanager.ts","src/ts/components/subtitlesettings/subtitlesettingsopenbutton.ts","src/ts/components/subtitlesettings/subtitlesettingspanel.ts","src/ts/components/subtitlesettings/subtitlesettingsresetbutton.ts","src/ts/components/subtitlesettings/windowcolorselectbox.ts","src/ts/components/subtitlesettings/windowopacityselectbox.ts","src/ts/components/titlebar.ts","src/ts/components/togglebutton.ts","src/ts/components/tvnoisecanvas.ts","src/ts/components/uicontainer.ts","src/ts/components/videoqualityselectbox.ts","src/ts/components/volumecontrolbutton.ts","src/ts/components/volumeslider.ts","src/ts/components/volumetogglebutton.ts","src/ts/components/vrtogglebutton.ts","src/ts/components/watermark.ts","src/ts/dom.ts","src/ts/eventdispatcher.ts","src/ts/guid.ts","src/ts/imageloader.ts","src/ts/main.ts","src/ts/playerutils.ts","src/ts/storageutils.ts","src/ts/stringutils.ts","src/ts/timeout.ts","src/ts/uimanager.ts","src/ts/uiutils.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","bitmovin","playerui","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","ArrayUtils","remove","array","item","index","indexOf","splice","BrowserUtils","isMobile","navigator","userAgent","test","isChrome","isAndroid","clickoverlay_1","AdClickOverlay","_super","__extends","prototype","configure","player","uimanager","_this","clickThroughUrl","clickThroughEnabled","getConfig","advertising","hasOwnProperty","addEventHandler","EVENT","ON_AD_STARTED","event","setUrl","adFinishedHandler","ON_AD_FINISHED","ON_AD_SKIPPED","ON_AD_ERROR","onClick","subscribe","pause","fireEvent","ON_AD_CLICKED","ClickOverlay","label_1","stringutils_1","AdMessageLabel","config","mergeConfig","cssClass","text","updateMessageHandler","setText","StringUtils","replaceAdMessagePlaceholders","adStartHandler","adMessage","ON_TIME_CHANGED","ON_CAST_TIME_UPDATED","adEndHandler","removeEventHandler","Label","button_1","AdSkipButton","skipMessage","countdown","skip","adEvent","updateSkipMessageHandler","skipOffset","show","hide","getCurrentTime","skipAd","Button","togglebutton_1","AirPlayToggleButton","isAirplayAvailable","showAirplayTargetPicker","console","log","airPlayAvailableHandler","ON_AIRPLAY_AVAILABLE","ToggleButton","container_1","component_1","timeout_1","AudioOnlyOverlay","indicator","Component","tag","hidden","components","overlayShowTimeout","Timeout","showOverlay","start","hideOverlay","clear","ON_PLAY","ON_PAUSED","Container","selectbox_1","AudioQualitySelectBox","selectCurrentAudioQuality","getAudioQuality","selectItem","id","data","getDownloadedAudioData","isAuto","updateAudioQualities","audioQualities","getAvailableAudioQualities","clearItems","addItem","_i","audioQualities_1","audioQuality","label","onItemSelected","sender","value","setAudioQuality","ON_AUDIO_CHANGED","ON_SOURCE_UNLOADED","ON_READY","ON_PERIOD_SWITCHED","ON_AUDIO_QUALITY_CHANGED","ON_AUDIO_DOWNLOAD_QUALITY_CHANGE","SelectBox","AudioTrackSelectBox","selectCurrentAudioTrack","currentAudioTrack","getAudio","updateAudioTracks","audioTracks","getAvailableAudio","audioTracks_1","audioTrack","setAudio","ON_AUDIO_ADDED","ON_AUDIO_REMOVED","BufferingOverlay","indicators","showDelayMs","ON_STALL_STARTED","ON_STALL_ENDED","isStalled","dom_1","eventdispatcher_1","buttonEvents","EventDispatcher","toDomElement","buttonElement","DOM","type","class","getCssClasses","append","prefixCss","html","on","onClickEvent","getDomElement","find","dispatch","Object","defineProperty","getEvent","CastStatusOverlay","statusLabel","ON_CAST_WAITING_FOR_DEVICE","castDeviceName","castPayload","deviceName","ON_CAST_STARTED","ON_CAST_STOPPED","CastToggleButton","isCastAvailable","isCasting","castStop","castVideo","castAvailableHander","ON_CAST_AVAILABLE","off","uicontainer_1","CastUIContainer","isUiShown","hideUi","onControlsHide","castUiHideTimeout","hideDelay","showUi","onControlsShow","showUiPermanently","showUiWithTimeout","showUiAfterSeek","isPlaying","ON_SOURCE_LOADED","ON_SEEK","ON_SEEKED","release","UIContainer","initialize","url","element","open","getUrl","undefined","CloseButton","target","guid_1","componentEvents","onShow","onHide","onHoverChanged","Guid","next","cssPrefix","cssClasses","isHidden","onComponentShow","onComponentHide","onHoverChangedEvent","defaults","base","assign","flattenedArray","concat","map","css","join","trim","cssClassOrId","addClass","CLASS_HIDDEN","onHideEvent","removeClass","onShowEvent","isShown","toggleHidden","isHovered","hovered","arrayutils_1","componentsToAdd","componentsToRemove","addComponent","component","push","removeComponent","getComponents","removeComponents","_a","slice","updateComponents","shift","innerContainerElement","containerElement","innerContainer","initialComponent","uiutils_1","spacer_1","ControlBar","hoverStackCount","UIUtils","traverseTree","Spacer","args","onPreviewControlsHide","cancel","tvnoisecanvas_1","ErrorMessageOverlay","errorLabel","tvNoiseBackground","TvNoiseCanvas","ON_ERROR","message","messages","customMessage","stop","FullscreenToggleButton","fullscreenStateHandler","isFullscreen","ON_FULLSCREEN_ENTER","ON_FULLSCREEN_EXIT","exitFullscreen","enterFullscreen","playbacktogglebutton_1","HugePlaybackToggleButton","togglePlayback","play","toggleFullscreen","firstPlay","clickTime","doubleClickTime","now","Date","setTimeout","ON_WARNING","castInitializationHandler","ON_CAST_START","suppressPlayButtonTransitionAnimation","setTransitionAnimationsEnabled","onToggle","subscribeOnce","isAutoplayEnabled","playback","Boolean","autoplay","isAutoplayUpcoming","isReady","enabled","noTransitionAnimationsClass","hasClass","PlaybackToggleButton","HugeReplayButton","listselector_1","ItemSelectionList","isActive","items","listElement","updateDomItems","selectedValue","empty","selectedListItem","listItem","CLASS_SELECTED","deselectItem","this_1","String","key","onItemSelectedEvent","onItemAddedEvent","selectedItem","onItemRemovedEvent","ListSelector","labelEvents","onTextChanged","labelElement","onTextChangedEvent","getText","clearText","isEmpty","listSelectorEvents","onItemAdded","onItemRemoved","getItemIndex","parseInt","hasItem","filter","translator","removeItem","getSelectedItem","items_1","itemCount","keys","MetadataLabelContent","MetadataLabel","content","toLowerCase","uiconfig","init","Title","metadata","title","Description","description","unload","PictureInPictureToggleButton","isPictureInPictureAvailable","isPictureInPicture","exitPictureInPicture","enterPictureInPicture","pipAvailableHander","ON_PICTURE_IN_PICTURE_ENTER","ON_PICTURE_IN_PICTURE_EXIT","PlaybackSpeedSelectBox","defaultPlaybackSpeeds","addDefaultItems","setPlaybackSpeed","parseFloat","setDefaultValue","playbackSpeed","getPlaybackSpeed","setSpeed","ON_PLAYBACK_SPEED_CHANGED","speed","customItems","sort","forEach","PlaybackTimeLabelMode","playerutils_1","PlaybackTimeLabel","timeLabelMode","CurrentAndTotalTime","hideInLivePlayback","live","liveCssClass","liveEdgeCssClass","minWidth","liveClickHandler","timeShift","updateLiveState","isLive","updateLiveTimeshiftState","unsubscribe","isTimeshifted","getTimeShift","isTimeshiftAvailable","getMaxTimeShift","isPaused","liveStreamDetector","PlayerUtils","LiveStreamDetector","onLiveChanged","detect","playbackTimeHandler","getDuration","Infinity","setTime","width","min-width","ON_TIME_SHIFT","ON_TIME_SHIFTED","timeFormat","Math","abs","FORMAT_HHMMSS","FORMAT_MMSS","playbackSeconds","durationSeconds","currentTime","secondsToTime","totalTime","CurrentTime","TotalTime","setTimeFormat","handleClickEvent","isSeeking","playbackStateHandler","ON_PLAYING","ON_PLAYBACK_FINISHED","ON_CAST_PLAYING","ON_CAST_PAUSED","ON_CAST_PLAYBACK_FINISHED","timeShiftDetector","TimeShiftAvailabilityDetector","onTimeShiftAvailabilityChanged","timeShiftAvailable","CLASS_STOPTOGGLE","onSeek","onSeeked","hugeplaybacktogglebutton_1","PlaybackToggleOverlay","playbackToggleButton","hugereplaybutton_1","RecommendationOverlay","replayButton","clearRecommendations","RecommendationItem","setupRecommendations","recommendations","recommendations_1","itemConfig","isAd","itemElement","href","background-image","thumbnail","bgElement","titleElement","timeElement","duration","SeekBar","playbackPositionPercentage","touchSupported","seekBarEvents","onSeekPreview","vertical","smoothPlaybackPositionUpdateIntervalMs","timelineMarkers","hasLabel","getLabel","configureSeek","setPosition","seekBarBackdrop","playbackPositionHandler","forceUpdate","setPlaybackPosition","setBufferPosition","videoBufferLength","getVideoBufferLength","audioBufferLength","getAudioBufferLength","bufferLength","min","Number","MAX_VALUE","bufferPercentage","SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED","ON_SEGMENT_REQUEST_FINISHED","configureLivePausedTimeshiftUpdater","setSeeking","seek","percentage","subscribeRateLimited","scrubbing","position","hasTimeShift","switchVisibility","refreshPlaybackPosition","ON_PLAYER_RESIZE","onConfigured","setSeekPosition","configureSmoothPlaybackPositionUpdater","configureMarkers","pausedTimeshiftUpdater","currentTimeSeekBar","currentTimePlayer","smoothPlaybackPositionUpdater","updateIntervalMs","currentTimeDelta","startSmoothPlaybackPositionUpdater","stopSmoothPlaybackPositionUpdater","clearMarkers","updateMarkers","setupMarkers","markers","marker","markerPosition","time","markerDuration","events","onUpdated","onRelease","seekBarContainer","seekBar","seekBarBufferLevel","seekBarBufferPosition","seekBarPlaybackPosition","seekBarPlaybackPositionMarker","seekBarSeekPosition","seekBarChapterMarkersContainer","seekBarMarkersContainer","seeking","mouseTouchMoveHandler","preventDefault","stopPropagation","targetPercentage","getOffset","onSeekPreviewEvent","mouseTouchUpHandler","document","snappedChapter","getMarkerAtPosition","onSeekedEvent","isTouchEvent","TouchEvent","onSeekEvent","seekBarWidthPx","markerClasses","cssProperties","markerWidthPx","round","data-marker-time","data-marker-title","getHorizontalOffset","eventPageX","elementOffsetPx","offset","left","widthPx","offsetPx","sanitizeOffset","getVerticalOffset","eventPageY","top","height","changedTouches","pageY","touches","pageX","MouseEvent","warn","percent","totalSize","px","style","transform","-ms-transform","-webkit-transform","scale","CLASS_SEEKING","snappedMarker","seekPositionPercentage","imageloader_1","SeekBarLabel","timeLabel","titleLabel","thumbnailImageLoader","ImageLoader","appliedMarkerCssClasses","maxTimeShift","setTitleText","setThumbnail","getThumb","seconds","thumbnailElement","display","load","thumbnailCountX","w","thumbnailCountY","h","thumbnailIndexX","x","thumbnailIndexY","y","sizeX","sizeY","offsetX","offsetY","aspectRatio","padding-bottom","background-size","background-position","selectElement","val","optionElement","attr","videoqualityselectbox_1","audioqualityselectbox_1","SettingsPanel","settingsPanelEvents","onSettingsStateChanged","hideTimeout","hideHoveredSelectBoxes","reset","settingsStateChangedHandler","onSettingsStateChangedEvent","lastShownItem","getItems","CLASS_LAST","onActiveChanged","setting","selectBox_1","oldDisplay_1","requestAnimationFrame","hasActiveSettings","SettingsPanelItem","settingsPanelItemEvents","handleConfigItemChanged","minItemsToDisplay","VideoQualitySelectBox","hasAutoItem","onActiveChangedEvent","SettingsToggleButton","settingsPanel","autoHideWhenNoActiveSettings","settingsPanelItemsChangedHandler","controlbar_1","SubtitleOverlay","preprocessLabelEventCallback","previewSubtitleActive","previewSubtitle","SubtitleLabel","subtitleManager","ActiveSubtitleManager","ON_CUE_ENTER","row","column","labelToAdd","cueEnter","ON_CUE_EXIT","labelToRemove","cueExit","hasCues","subtitleClearHandler","ON_SUBTITLE_CHANGED","CLASS_CONTROLBAR_VISIBLE","configureCea608Captions","fontSize","fontLetterSpacing","fontSizeCalculationRequired","updateCEA608FontSize","dummyLabel","font-size","line-height","visibility","dummyLabelCharWidth","dummyLabelCharHeight","fontSizeRatio","subtitleOverlayWidth","subtitleOverlayHeight","CEA608_NUM_COLUMNS","CEA608_NUM_ROWS","gridSlotWidth","letter-spacing","CLASS_CEA_608","CEA608_COLUMN_OFFSET","CEA608_ROW_OFFSET","enablePreviewSubtitleLabel","removePreviewSubtitleLabel","activeSubtitleCueMap","activeSubtitleCueCount","calculateId","getCues","activeSubtitleCues","cue","activeSubtitleCue","cueCount","SubtitleSelectBox","selectCurrentSubtitle","currentSubtitle","getSubtitle","updateSubtitles","getAvailableSubtitles","subtitle","setSubtitle","ON_SUBTITLE_ADDED","ON_SUBTITLE_REMOVED","subtitlesettingselectbox_1","BackgroundColorSelectBox","setColorAndOpacity","settingsManager","backgroundColor","isSet","backgroundOpacity","toggleOverlayClass","onChanged","property","SubtitleSettingSelectBox","BackgroundOpacitySelectBox","CharacterEdgeSelectBox","characterEdge","FontColorSelectBox","fontColor","fontOpacity","FontFamilySelectBox","fontFamily","FontOpacitySelectBox","FontSizeSelectBox","SubtitleSettingsButton","subtitleSettingsPanel","subtitlesettingsbutton_1","SubtitleSettingsCloseButton","overlay","currentCssClass","SubtitleSettingsLabel","opener","storageutils_1","SubtitleSettingsManager","_properties","SubtitleSettingsProperty","windowColor","windowOpacity","userSettings","localStorageKey","DummyComponent","instance","propertyName","save","StorageUtils","setObject","getObject","_instance","manager","_manager","_onChanged","_value","onChangedEvent","SubtitleSettingsOpenButton","settingspanel_1","fontcolorselectbox_1","fontopacityselectbox_1","fontfamilyselectbox_1","fontsizeselectbox_1","backgroundcolorselectbox_1","backgroundopacityselectbox_1","windowcolorselectbox_1","windowopacityselectbox_1","characteredgeselectbox_1","subtitlesettingsmanager_1","subtitlesettingsclosebutton_1","subtitlesettingsresetbutton_1","SubtitleSettingsPanel","WindowColorSelectBox","WindowOpacitySelectBox","SubtitleSettingsResetButton","metadatalabel_1","TitleBar","keepHiddenWithoutMetadata","shouldBeShown","hasMetadataText","checkMetadataTextAndUpdateVisibility","toggleButtonEvents","onToggleOn","onToggleOff","defaultConfig","onClass","offClass","isOff","onState","onToggleEvent","onToggleOnEvent","isOn","onToggleOffEvent","toggle","canvasWidth","canvasHeight","interferenceHeight","lastFrameUpdate","frameInterval","useAnimationFrame","canvas","canvasElement","get","canvasContext","getContext","noiseAnimationWindowPos","renderFrame","cancelAnimationFrame","frameUpdateHandlerId","clearTimeout","getTime","scheduleNextRender","currentPixelOffset","noiseImage","createImageData","random","putImageData","bind","configureUIShowHide","configurePlayerStates","container","isFirstTouch","uiHideTimeout","previewHideEventArgs","stateClassNames","state","PlayerState","isNaN","enumName","STATE_PREFIX","removeStates","IDLE","PREPARED","PLAYING","PAUSED","FINISHED","getState","FULLSCREEN","BUFFERING","REMOTE_CONTROL","CONTROLS_HIDDEN","CONTROLS_SHOWN","updateLayoutSizeClasses","substring","getFigure","createElement","flex","selectCurrentVideoQuality","getVideoQuality","getDownloadedVideoData","updateVideoQualities","videoQualities","getAvailableVideoQualities","hasAuto","getStreamType","videoQualities_1","videoQuality","setVideoQuality","ON_VIDEO_QUALITY_CHANGED","ON_VIDEO_DOWNLOAD_QUALITY_CHANGE","volumeslider_1","volumetogglebutton_1","VolumeControlButton","volumeToggleButton","VolumeToggleButton","volumeSlider","VolumeSlider","getVolumeToggleButton","getVolumeSlider","volumeSliderHideTimeout","volumeSliderHovered","seekbar_1","hideIfVolumeControlProhibited","detectVolumeControlAvailability","volumeChangeHandler","isMuted","getVolume","ON_VOLUME_CHANGED","ON_MUTED","ON_UNMUTED","setVolume","issuerName","dummyVideoElement","volume","muteStateHandler","volumeLevelHandler","volumeLevelTens","ceil","unmute","mute","VRToggleButton","isVRConfigured","source","vr","contentType","isVRStereoAvailable","getVRStatus","vrStateHandler","isStereo","vrButtonVisibilityHandler","ON_VR_MODE_CHANGED","ON_VR_STEREO_CHANGED","ON_VR_ERROR","setVRStereo","Watermark","something","attributes","Array","HTMLElement","elements","Document","tagName","attributeName","attributeValue","setAttribute","selector","findChildElements","getElements","handler","findChildElementsOfElement","childElements","querySelectorAll","allChildElements","arguments","setHtml","getHtml","innerHTML","HTMLSelectElement","HTMLInputElement","attribute","setAttr","getAttr","getAttribute","dataAttribute","setData","getData","childElement","_","appendChild","parent","parentNode","removeChild","elementRect","getBoundingClientRect","htmlRect","body","parentElement","offsetWidth","offsetHeight","eventName","eventHandler","split","addEventListener","removeEventListener","className","classList","classNames","add","apply","replace","RegExp","contains","propertyNameOrCollection","setCss","getCss","propertyValueCollection","setCssCollection","getComputedStyle","ruleValueCollection","listeners","listener","EventListenerWrapper","rateMs","RateLimitedEventListenerWrapper","subscribedListener","unsubscribeAll","listenersToRemove","listeners_1","fire","isOnce","listenersToRemove_1","listenerToRemove","once","eventListener","lastFireTime","rateLimitingEventListener","fireSuper","guid","loadedCallback","loaded","callLoadedCallback","state_1","image","uimanager_1","fullscreentogglebutton_1","playbacktimelabel_1","itemselectionlist_1","settingstogglebutton_1","vrtogglebutton_1","watermark_1","audiotrackselectbox_1","caststatusoverlay_1","casttogglebutton_1","errormessageoverlay_1","recommendationoverlay_1","seekbarlabel_1","subtitleoverlay_1","subtitleselectbox_1","titlebar_1","volumecontrolbutton_1","adskipbutton_1","admessagelabel_1","adclickoverlay_1","playbackspeedselectbox_1","bufferingoverlay_1","castuicontainer_1","playbacktoggleoverlay_1","closebutton_1","airplaytogglebutton_1","pictureinpicturetogglebutton_1","subtitlesettingslabel_1","subtitlesettingsopenbutton_1","subtitlesettingspanel_1","browserutils_1","TypeError","version","UIManager","UIInstanceManager","subtitlesettings","isTimeShiftAvailable","hasEnded","timeShiftAvailabilityChangedEvent","timeShiftAvailableNow","liveChangedEvent","liveDetector","liveNow","hasLocalStorage","hasLocalStorageCache","storage","setItem","DOMException","name","localStorage","getItem","JSON","stringify","json","parse","totalSeconds","format","isNegative","hours","floor","minutes","leftPadWithZeros","num","substr","adMessagePlaceholderRegex","formatString","formatNumber","formatStringValidationRegex","leadingZeroesRegex","decimalPlacesRegex","leadingZeroes","leadingZeroesMatches","match","numDecimalPlaces","decimalPlacesMatches","timeString","toFixed","delay","callback","repeat","timeoutHandle","clearInternal","lastScheduleTime","delayAdjust","internalCallback","delta","audioonlyoverlay_1","playerUiOrUiVariants","onUiVariantResolve","playerUi","uiVariants","ui","__assign","managerPlayerWrapper","PlayerWrapper","updateConfig","playerSourceConfig","uiConfig","playerSourceUiConfig","getPlayer","uiContainerElement","uiInstanceManagers","uiVariantsWithoutCondition","uiVariant","condition","InternalUIInstanceManager","autoUiVariantResolve","adStartedEvent","resolveUiVariant","ad","adWithUI","clientType","isAdWithUI","adClientType","context","currentUi","getWrappedPlayer","fireEventInUI","getUiVariants","switchToUiVariant","uiVariantIndex","nextUi","uiVariantChanged","getUI","isConfigured","addUi","defaultContext","documentWidth","clientWidth","switchingContext","nextUiVariant","dom","configureControls","releaseUi","releaseControls","clearEventHandlers","uiInstanceManager","getTimelineMarkers","addTimelineMarker","timelineMarker","removeTimelineMarker","Factory","buildAudioVideoUI","modernSmallScreenUI","modernUI","buildAudioOnlyUI","modernAudioOnlySmallScreenUI","modernAudioOnlyUI","subtitleOverlay","subtitleSettingsOpenButton","controlBar","playerWrapper","event_1","configureControlsTree","configured","configuredComponents","configuredComponents_1","error","constructor","releaseControlsTree","released","isReleased","childComponent","eventHandlers","members","member","methods","properties","members_1","wrapper","methods_1","method","_b","properties_1","propertyDescriptor","getOwnPropertyDescriptor","getPrototypeOf","set","eventType","playerEventData","timestamp","uiSourced","visit","recursiveTreeWalker"],"mappings":"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","file":"wbc-player-ui.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","export namespace ArrayUtils {\n  /**\n   * Removes an item from an array.\n   * @param array the array that may contain the item to remove\n   * @param item the item to remove from the array\n   * @returns {any} the removed item or null if it wasn't part of the array\n   */\n  export function remove<T>(array: T[], item: T): T | null {\n    let index = array.indexOf(item);\n\n    if (index > -1) {\n      return array.splice(index, 1)[0];\n    } else {\n      return null;\n    }\n  }\n}\n","export namespace BrowserUtils {\n\n  // isMobile only needs to be evaluated once (it cannot change during a browser session)\n  // Mobile detection according to Mozilla recommendation: \"In summary, we recommend looking for the string Mobi\n  // anywhere in the User Agent to detect a mobile device.\"\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n  export const isMobile = navigator && navigator.userAgent && /Mobi/.test(navigator.userAgent);\n\n  export const isChrome = navigator && navigator.userAgent && /Chrome/.test(navigator.userAgent);\n\n  export const isAndroid = navigator && navigator.userAgent && /Android/.test(navigator.userAgent);\n}\n","import {ClickOverlay} from './clickoverlay';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A simple click capture overlay for clickThroughUrls of ads.\n */\nexport class AdClickOverlay extends ClickOverlay {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clickThroughUrl = <string>null;\n    let clickThroughEnabled = !player.getConfig().advertising\n      || !player.getConfig().advertising.hasOwnProperty('clickThroughEnabled')\n      || player.getConfig().advertising.clickThroughEnabled;\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, (event: bitmovin.PlayerAPI.AdStartedEvent) => {\n      clickThroughUrl = event.clickThroughUrl;\n\n      if (clickThroughEnabled) {\n        this.setUrl(clickThroughUrl);\n      } else {\n        // If click-through is disabled, we set the url to null to avoid it open\n        this.setUrl(null);\n      }\n    });\n\n    // Clear click-through URL when ad has finished\n    let adFinishedHandler = () => {\n      this.setUrl(null);\n    };\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adFinishedHandler);\n\n    this.onClick.subscribe(() => {\n      // Pause the ad when overlay is clicked\n      player.pause('ui-content-click');\n\n      // Notify the player of the clicked ad\n      player.fireEvent(player.EVENT.ON_AD_CLICKED, {\n        clickThroughUrl: clickThroughUrl,\n      });\n    });\n  }\n}","import {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils} from '../stringutils';\n\n/**\n * A label that displays a message about a running ad, optionally with a countdown.\n */\nexport class AdMessageLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label-ad-message',\n      text: 'This ad will end in {remainingTime} seconds.',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let text = this.getConfig().text;\n\n    let updateMessageHandler = () => {\n      this.setText(StringUtils.replaceAdMessagePlaceholders(text, null, player));\n    };\n\n    let adStartHandler = (event: bitmovin.PlayerAPI.AdStartedEvent) => {\n      text = event.adMessage || text;\n      updateMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport SkipMessage = bitmovin.PlayerAPI.SkipMessage;\nimport {StringUtils} from '../stringutils';\n\n/**\n * Configuration interface for the {@link AdSkipButton}.\n */\nexport interface AdSkipButtonConfig extends ButtonConfig {\n  skipMessage?: SkipMessage;\n}\n\n/**\n * A button that is displayed during ads and can be used to skip the ad.\n */\nexport class AdSkipButton extends Button<AdSkipButtonConfig> {\n\n  constructor(config: AdSkipButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <AdSkipButtonConfig>{\n      cssClass: 'ui-button-ad-skip',\n      skipMessage: {\n        countdown: 'Skip ad in {remainingTime}',\n        skip: 'Skip ad',\n      },\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <AdSkipButtonConfig>this.getConfig(); // TODO get rid of generic cast\n    let skipMessage = config.skipMessage;\n    let adEvent = <bitmovin.PlayerAPI.AdStartedEvent>null;\n\n    let updateSkipMessageHandler = () => {\n      // Display this button only if ad is skippable\n      if (adEvent.skipOffset) {\n        this.show();\n      } else {\n        this.hide();\n      }\n\n      // Update the skip message on the button\n      if (player.getCurrentTime() < adEvent.skipOffset) {\n        this.setText(\n          StringUtils.replaceAdMessagePlaceholders(config.skipMessage.countdown, adEvent.skipOffset, player));\n      } else {\n        this.setText(config.skipMessage.skip);\n      }\n    };\n\n    let adStartHandler = (event: bitmovin.PlayerAPI.AdStartedEvent) => {\n      adEvent = event;\n      skipMessage = adEvent.skipMessage || skipMessage;\n      updateSkipMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n\n    this.onClick.subscribe(() => {\n      // Try to skip the ad (this only works if it is skippable so we don't need to take extra care of that here)\n      player.skipAd();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple AirPlay.\n */\nexport class AirPlayToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-airplaytogglebutton',\n      text: 'Apple AirPlay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    if (!player.isAirplayAvailable) {\n      // If the player does not support Airplay (player 7.0), we just hide this component and skip configuration\n      this.hide();\n      return;\n    }\n\n    this.onClick.subscribe(() => {\n      if (player.isAirplayAvailable()) {\n        player.showAirplayTargetPicker();\n      } else {\n        if (console) {\n          console.log('AirPlay unavailable');\n        }\n      }\n    });\n\n    let airPlayAvailableHandler = () => {\n      if (player.isAirplayAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_AIRPLAY_AVAILABLE, airPlayAvailableHandler);\n\n    // Startup init\n    airPlayAvailableHandler(); // Hide button if AirPlay is not available\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for the {@link AudioOnlyOverlay} component.\n */\nexport interface AudioOnlyOverlayConfig extends ContainerConfig {\n}\n\n/**\n * Overlays the player and displays an audio-only indicator.\n */\nexport class AudioOnlyOverlay extends Container<AudioOnlyOverlayConfig> {\n\n  private indicator: Component<ComponentConfig>[];\n\n  constructor(config: AudioOnlyOverlayConfig = {}) {\n    super(config);\n\n    this.indicator = [\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-audioonly-overlay-indicator', hidden: true }),\n    ];\n\n    this.config = this.mergeConfig(config, <AudioOnlyOverlayConfig>{\n      cssClass: 'ui-audioonly-overlay',\n      hidden: false,\n      components: this.indicator,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <AudioOnlyOverlayConfig>this.getConfig();\n\n    let overlayShowTimeout = new Timeout(400, () => {\n      config.components[0].show();\n    });\n\n    let showOverlay = () => {\n      overlayShowTimeout.start();\n    };\n\n    let hideOverlay = () => {\n      overlayShowTimeout.clear();\n      config.components[0].hide();\n    };\n\n    player.addEventHandler(player.EVENT.ON_PLAY, showOverlay);\n    player.addEventHandler(player.EVENT.ON_PAUSED, hideOverlay);\n  }\n}\n","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available audio qualities.\n */\nexport class AudioQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let selectCurrentAudioQuality = () => {\n      if (player.getAudioQuality) {\n        // Since player 7.3.1\n        this.selectItem(player.getAudioQuality().id);\n      } else {\n        // Backwards compatibility for players <= 7.3.0\n        // TODO remove in next major release\n        let data = player.getDownloadedAudioData();\n        this.selectItem(data.isAuto ? 'auto' : data.id);\n      }\n    };\n\n    let updateAudioQualities = () => {\n      let audioQualities = player.getAvailableAudioQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('auto', 'auto');\n\n      // Add audio qualities\n      for (let audioQuality of audioQualities) {\n        this.addItem(audioQuality.id, audioQuality.label);\n      }\n\n      // Select initial quality\n      selectCurrentAudioQuality();\n    };\n\n    this.onItemSelected.subscribe((sender: AudioQualitySelectBox, value: string) => {\n      player.setAudioQuality(value);\n    });\n\n    // Update qualities when audio track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, updateAudioQualities);\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioQualities);\n    // Update qualities when the period within a source changes\n    player.addEventHandler(player.EVENT.ON_PERIOD_SWITCHED, updateAudioQualities);\n    // Update quality selection when quality is changed (from outside)\n    if (player.EVENT.ON_AUDIO_QUALITY_CHANGED) {\n      // Since player 7.3.1\n      player.addEventHandler(player.EVENT.ON_AUDIO_QUALITY_CHANGED, selectCurrentAudioQuality);\n    } else {\n      // Backwards compatibility for players <= 7.3.0\n      // TODO remove in next major release\n      player.addEventHandler(player.EVENT.ON_AUDIO_DOWNLOAD_QUALITY_CHANGE, selectCurrentAudioQuality);\n    }\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between available audio tracks (e.g. different languages).\n */\nexport class AudioTrackSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let selectCurrentAudioTrack = () => {\n      let currentAudioTrack = player.getAudio();\n\n      // HLS streams don't always provide this, so we have to check\n      if (currentAudioTrack) {\n        this.selectItem(currentAudioTrack.id);\n      }\n    };\n\n    let updateAudioTracks = () => {\n      let audioTracks = player.getAvailableAudio();\n\n      this.clearItems();\n\n      // Add audio tracks\n      for (let audioTrack of audioTracks) {\n        this.addItem(audioTrack.id, audioTrack.label);\n      }\n\n      // Select the correct audio track after the tracks have been added\n      // This is also important in case we missed the `ON_AUDIO_CHANGED` event, e.g. when `playback.audioLanguage`\n      // is configured but the event is fired before the UI is created.\n      selectCurrentAudioTrack();\n    };\n\n    this.onItemSelected.subscribe((sender: AudioTrackSelectBox, value: string) => {\n      player.setAudio(value);\n    });\n\n    // Update selection when selected track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, selectCurrentAudioTrack);\n    // Update tracks when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioTracks);\n    // Update tracks when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioTracks);\n    // Update tracks when the period within a source changes\n    player.addEventHandler(player.EVENT.ON_PERIOD_SWITCHED, updateAudioTracks);\n    // Update tracks when a track is added or removed (since player 7.1.4)\n    if (player.EVENT.ON_AUDIO_ADDED && player.EVENT.ON_AUDIO_REMOVED) {\n      player.addEventHandler(player.EVENT.ON_AUDIO_ADDED, updateAudioTracks);\n      player.addEventHandler(player.EVENT.ON_AUDIO_REMOVED, updateAudioTracks);\n    }\n\n    // Populate tracks at startup\n    updateAudioTracks();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for the {@link BufferingOverlay} component.\n */\nexport interface BufferingOverlayConfig extends ContainerConfig {\n  /**\n   * Delay in milliseconds after which the buffering overlay will be displayed. Useful to bypass short stalls without\n   * displaying the overlay. Set to 0 to display the overlay instantly.\n   * Default: 1000ms (1 second)\n   */\n  showDelayMs?: number;\n}\n\n/**\n * Overlays the player and displays a buffering indicator.\n */\nexport class BufferingOverlay extends Container<BufferingOverlayConfig> {\n\n  private indicators: Component<ComponentConfig>[];\n\n  constructor(config: BufferingOverlayConfig = {}) {\n    super(config);\n\n    this.indicators = [\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n    ];\n\n    this.config = this.mergeConfig(config, <BufferingOverlayConfig>{\n      cssClass: 'ui-buffering-overlay',\n      hidden: true,\n      components: this.indicators,\n      showDelayMs: 1000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <BufferingOverlayConfig>this.getConfig();\n\n    let overlayShowTimeout = new Timeout(config.showDelayMs, () => {\n      this.show();\n    });\n\n    let showOverlay = () => {\n      overlayShowTimeout.start();\n    };\n\n    let hideOverlay = () => {\n      overlayShowTimeout.clear();\n      this.hide();\n    };\n\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, showOverlay);\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, hideOverlay);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, hideOverlay);\n\n    // Show overlay if player is already stalled at init\n    if (player.isStalled()) {\n      this.show();\n    }\n  }\n}\n","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Button} component.\n */\nexport interface ButtonConfig extends ComponentConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A simple clickable button.\n */\nexport class Button<Config extends ButtonConfig> extends Component<ButtonConfig> {\n\n  private buttonEvents = {\n    onClick: new EventDispatcher<Button<Config>, NoArgs>(),\n  };\n\n  constructor(config: ButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-button',\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    // Create the button element with the text label\n    let buttonElement = new DOM('button', {\n      'type': 'button',\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    }).append(new DOM('span', {\n      'class': this.prefixCss('label'),\n    }).html(this.config.text));\n\n    // Listen for the click event on the button element and trigger the corresponding event on the button component\n    buttonElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return buttonElement;\n  }\n\n  /**\n   * Sets text on the label of the button.\n   * @param text the text to put into the label of the button\n   */\n  setText(text: string): void {\n    this.getDomElement().find('.' + this.prefixCss('label')).html(text);\n  }\n\n  protected onClickEvent() {\n    this.buttonEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is clicked.\n   * @returns {Event<Button<Config>, NoArgs>}\n   */\n  get onClick(): Event<Button<Config>, NoArgs> {\n    return this.buttonEvents.onClick.getEvent();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport CastWaitingForDeviceEvent = bitmovin.PlayerAPI.CastWaitingForDeviceEvent;\nimport CastStartedEvent = bitmovin.PlayerAPI.CastStartedEvent;\n\n/**\n * Overlays the player and displays the status of a Cast session.\n */\nexport class CastStatusOverlay extends Container<ContainerConfig> {\n\n  private statusLabel: Label<LabelConfig>;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.statusLabel = new Label<LabelConfig>({ cssClass: 'ui-cast-status-label' });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-cast-status-overlay',\n      components: [this.statusLabel],\n      hidden: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE,\n      (event: CastWaitingForDeviceEvent) => {\n        this.show();\n        // Get device name and update status text while connecting\n        let castDeviceName = event.castPayload.deviceName;\n        this.statusLabel.setText(`Connecting to <strong>${castDeviceName}</strong>...`);\n      });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, (event: CastStartedEvent) => {\n      // Session is started or resumed\n      // For cases when a session is resumed, we do not receive the previous events and therefore show the status panel\n      // here too\n      this.show();\n      let castDeviceName = event.deviceName;\n      this.statusLabel.setText(`Playing on <strong>${castDeviceName}</strong>`);\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, (event) => {\n      // Cast session gone, hide the status panel\n      this.hide();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles casting to a Cast receiver.\n */\nexport class CastToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-casttogglebutton',\n      text: 'Google Cast',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isCastAvailable()) {\n        if (player.isCasting()) {\n          player.castStop();\n        } else {\n          player.castVideo();\n        }\n      } else {\n        if (console) {\n          console.log('Cast unavailable');\n        }\n      }\n    });\n\n    let castAvailableHander = () => {\n      if (player.isCastAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_CAST_AVAILABLE, castAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      // When a session is resumed, there is no ON_CAST_START event, so we also need to toggle here for such cases\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      this.off();\n    });\n\n    // Startup init\n    castAvailableHander(); // Hide button if Cast not available\n    if (player.isCasting()) {\n      this.on();\n    }\n  }\n}","import {UIContainer, UIContainerConfig} from './uicontainer';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * The base container for Cast receivers that contains all of the UI and takes care that the UI is shown on\n * certain playback events.\n */\nexport class CastUIContainer extends UIContainer {\n\n  private castUiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <UIContainerConfig>this.getConfig();\n\n    /*\n     * Show UI on Cast devices at certain playback events\n     *\n     * Since a Cast receiver does not have a direct HCI, we show the UI on certain playback events to give the user\n     * a chance to see on the screen what's going on, e.g. on play/pause or a seek the UI is shown and the user can\n     * see the current time and position on the seek bar.\n     * The UI is shown permanently while playback is paused, otherwise hides automatically after the configured\n     * hide delay time.\n     */\n\n    let isUiShown = false;\n\n    let hideUi = () => {\n      uimanager.onControlsHide.dispatch(this);\n      isUiShown = false;\n    };\n\n    this.castUiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    let showUi = () => {\n      if (!isUiShown) {\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n    };\n\n    let showUiPermanently = () => {\n      showUi();\n      this.castUiHideTimeout.clear();\n    };\n\n    let showUiWithTimeout = () => {\n      showUi();\n      this.castUiHideTimeout.start();\n    };\n\n    let showUiAfterSeek = () => {\n      if (player.isPlaying()) {\n        showUiWithTimeout();\n      } else {\n        showUiPermanently();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PLAY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PAUSED, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEK, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEKED, showUiAfterSeek);\n  }\n\n  release(): void {\n    super.release();\n    this.castUiHideTimeout.clear();\n  }\n}","import {Button, ButtonConfig} from './button';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface ClickOverlayConfig extends ButtonConfig {\n  /**\n   * The url to open when the overlay is clicked. Set to null to disable the click handler.\n   */\n  url?: string;\n}\n\n/**\n * A click overlay that opens an url in a new tab if clicked.\n */\nexport class ClickOverlay extends Button<ClickOverlayConfig> {\n\n  constructor(config: ClickOverlayConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-clickoverlay',\n    }, <ClickOverlayConfig>this.config);\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    this.setUrl((<ClickOverlayConfig>this.config).url);\n    let element = this.getDomElement();\n    element.on('click', () => {\n      if (element.data('url')) {\n        window.open(element.data('url'), '_blank');\n      }\n    });\n  }\n\n  /**\n   * Gets the URL that should be followed when the watermark is clicked.\n   * @returns {string} the watermark URL\n   */\n  getUrl(): string {\n    return this.getDomElement().data('url');\n  }\n\n  setUrl(url: string): void {\n    if (url === undefined || url == null) {\n      url = '';\n    }\n    this.getDomElement().data('url', url);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\n\n/**\n * Configuration interface for the {@link CloseButton}.\n */\nexport interface CloseButtonConfig extends ButtonConfig {\n  /**\n   * The component that should be closed when the button is clicked.\n   */\n  target: Component<ComponentConfig>;\n}\n\n/**\n * A button that closes (hides) a configured component.\n */\nexport class CloseButton extends Button<CloseButtonConfig> {\n\n  constructor(config: CloseButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-closebutton',\n      text: 'Close',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <CloseButtonConfig>this.getConfig();\n\n    this.onClick.subscribe(() => {\n      config.target.hide();\n    });\n  }\n}","import {Guid} from '../guid';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Base configuration interface for a component.\n * Should be extended by components that want to add additional configuration options.\n */\nexport interface ComponentConfig {\n  /**\n   * The HTML tag name of the component.\n   * Default: 'div'\n   */\n  tag?: string;\n  /**\n   * The HTML ID of the component.\n   * Default: automatically generated with pattern 'ui-id-{guid}'.\n   */\n  id?: string;\n\n  /**\n   * A prefix to prepend all CSS classes with.\n   */\n  cssPrefix?: string;\n\n  /**\n   * The CSS classes of the component. This is usually the class from where the component takes its styling.\n   */\n  cssClass?: string; // 'class' is a reserved keyword, so we need to make the name more complicated\n\n  /**\n   * Additional CSS classes of the component.\n   */\n  cssClasses?: string[];\n\n  /**\n   * Specifies if the component should be hidden at startup.\n   * Default: false\n   */\n  hidden?: boolean;\n}\n\nexport interface ComponentHoverChangedEventArgs extends NoArgs {\n  /**\n   * True is the component is hovered, else false.\n   */\n  hovered: boolean;\n}\n\n/**\n * The base class of the UI framework.\n * Each component must extend this class and optionally the config interface.\n */\nexport class Component<Config extends ComponentConfig> {\n\n  /**\n   * The classname that is attached to the element when it is in the hidden state.\n   * @type {string}\n   */\n  private static readonly CLASS_HIDDEN = 'hidden';\n\n  /**\n   * Configuration object of this component.\n   */\n  protected config: Config;\n\n  /**\n   * The component's DOM element.\n   */\n  private element: DOM;\n\n  /**\n   * Flag that keeps track of the hidden state.\n   */\n  private hidden: boolean;\n\n  /**\n   * Flag that keeps track of the hover state.\n   */\n  private hovered: boolean;\n\n  /**\n   * The list of events that this component offers. These events should always be private and only directly\n   * accessed from within the implementing component.\n   *\n   * Because TypeScript does not support private properties with the same name on different class hierarchy levels\n   * (i.e. superclass and subclass cannot contain a private property with the same name), the default naming\n   * convention for the event list of a component that should be followed by subclasses is the concatenation of the\n   * camel-cased class name + 'Events' (e.g. SubClass extends Component => subClassEvents).\n   * See {@link #componentEvents} for an example.\n   *\n   * Event properties should be named in camel case with an 'on' prefix and in the present tense. Async events may\n   * have a start event (when the operation starts) in the present tense, and must have an end event (when the\n   * operation ends) in the past tense (or present tense in special cases (e.g. onStart/onStarted or onPlay/onPlaying).\n   * See {@link #componentEvents#onShow} for an example.\n   *\n   * Each event should be accompanied with a protected method named by the convention eventName + 'Event'\n   * (e.g. onStartEvent), that actually triggers the event by calling {@link EventDispatcher#dispatch dispatch} and\n   * passing a reference to the component as first parameter. Components should always trigger their events with these\n   * methods. Implementing this pattern gives subclasses means to directly listen to the events by overriding the\n   * method (and saving the overhead of passing a handler to the event dispatcher) and more importantly to trigger\n   * these events without having access to the private event list.\n   * See {@link #onShow} for an example.\n   *\n   * To provide external code the possibility to listen to this component's events (subscribe, unsubscribe, etc.),\n   * each event should also be accompanied by a public getter function with the same name as the event's property,\n   * that returns the {@link Event} obtained from the event dispatcher by calling {@link EventDispatcher#getEvent}.\n   * See {@link #onShow} for an example.\n   *\n   * Full example for an event representing an example action in a example component:\n   *\n   * <code>\n   * // Define an example component class with an example event\n   * class ExampleComponent extends Component<ComponentConfig> {\n     *\n     *     private exampleComponentEvents = {\n     *         onExampleAction: new EventDispatcher<ExampleComponent, NoArgs>()\n     *     }\n     *\n     *     // constructor and other stuff...\n     *\n     *     protected onExampleActionEvent() {\n     *        this.exampleComponentEvents.onExampleAction.dispatch(this);\n     *    }\n     *\n     *    get onExampleAction(): Event<ExampleComponent, NoArgs> {\n     *        return this.exampleComponentEvents.onExampleAction.getEvent();\n     *    }\n     * }\n   *\n   * // Create an instance of the component somewhere\n   * var exampleComponentInstance = new ExampleComponent();\n   *\n   * // Subscribe to the example event on the component\n   * exampleComponentInstance.onExampleAction.subscribe(function (sender: ExampleComponent) {\n     *     console.log('onExampleAction of ' + sender + ' has fired!');\n     * });\n   * </code>\n   */\n  private componentEvents = {\n    onShow: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHide: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHoverChanged: new EventDispatcher<Component<Config>, ComponentHoverChangedEventArgs>(),\n  };\n\n  /**\n   * Constructs a component with an optionally supplied config. All subclasses must call the constructor of their\n   * superclass and then merge their configuration into the component's configuration.\n   * @param config the configuration for the component\n   */\n  constructor(config: ComponentConfig = {}) {\n    // Create the configuration for this component\n    this.config = <Config>this.mergeConfig(config, {\n      tag: 'div',\n      id: 'mi-wbc-id-' + Guid.next(),\n      cssPrefix: 'mi-wbc',\n      cssClass: 'ui-component',\n      cssClasses: [],\n      hidden: false,\n    }, {});\n  }\n\n  /**\n   * Initializes the component, e.g. by applying config settings.\n   * This method must not be called from outside the UI framework.\n   *\n   * This method is automatically called by the {@link UIInstanceManager}. If the component is an inner component of\n   * some component, and thus encapsulated abd managed internally and never directly exposed to the UIManager,\n   * this method must be called from the managing component's {@link #initialize} method.\n   */\n  initialize(): void {\n    this.hidden = this.config.hidden;\n\n    // Hide the component at initialization if it is configured to be hidden\n    if (this.isHidden()) {\n      this.hidden = false; // Set flag to false for the following hide() call to work (hide() checks the flag)\n      this.hide();\n    }\n  }\n\n  /**\n   * Configures the component for the supplied Player and UIInstanceManager. This is the place where all the magic\n   * happens, where components typically subscribe and react to events (on their DOM element, the Player, or the\n   * UIInstanceManager), and basically everything that makes them interactive.\n   * This method is called only once, when the UIManager initializes the UI.\n   *\n   * Subclasses usually overwrite this method to add their own functionality.\n   *\n   * @param player the player which this component controls\n   * @param uimanager the UIInstanceManager that manages this component\n   */\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    this.onShow.subscribe(() => {\n      uimanager.onComponentShow.dispatch(this);\n    });\n    this.onHide.subscribe(() => {\n      uimanager.onComponentHide.dispatch(this);\n    });\n\n    // Track the hovered state of the element\n    this.getDomElement().on('mouseenter', () => {\n      this.onHoverChangedEvent(true);\n    });\n    this.getDomElement().on('mouseleave', () => {\n      this.onHoverChangedEvent(false);\n    });\n  }\n\n  /**\n   * Releases all resources and dependencies that the component holds. Player, DOM, and UIManager events are\n   * automatically removed during release and do not explicitly need to be removed here.\n   * This method is called by the UIManager when it releases the UI.\n   *\n   * Subclasses that need to release resources should override this method and call super.release().\n   */\n  release(): void {\n    // Nothing to do here, override where necessary\n  }\n\n  /**\n   * Generate the DOM element for this component.\n   *\n   * Subclasses usually overwrite this method to extend or replace the DOM element with their own design.\n   */\n  protected toDomElement(): DOM {\n    let element = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    });\n\n    return element;\n  }\n\n  /**\n   * Returns the DOM element of this component. Creates the DOM element if it does not yet exist.\n   *\n   * Should not be overwritten by subclasses.\n   *\n   * @returns {DOM}\n   */\n  getDomElement(): DOM {\n    if (!this.element) {\n      this.element = this.toDomElement();\n    }\n\n    return this.element;\n  }\n\n  /**\n   * Merges a configuration with a default configuration and a base configuration from the superclass.\n   *\n   * @param config the configuration settings for the components, as usually passed to the constructor\n   * @param defaults a default configuration for settings that are not passed with the configuration\n   * @param base configuration inherited from a superclass\n   * @returns {Config}\n   */\n  protected mergeConfig<Config>(config: Config, defaults: Config, base: Config): Config {\n    // Extend default config with supplied config\n    let merged = Object.assign({}, base, defaults, config);\n\n    // Return the extended config\n    return merged;\n  }\n\n  /**\n   * Helper method that returns a string of all CSS classes of the component.\n   *\n   * @returns {string}\n   */\n  protected getCssClasses(): string {\n    // Merge all CSS classes into single array\n    let flattenedArray = [this.config.cssClass].concat(this.config.cssClasses);\n    // Prefix classes\n    flattenedArray = flattenedArray.map((css) => {\n      return this.prefixCss(css);\n    });\n    // Join array values into a string\n    let flattenedString = flattenedArray.join(' ');\n    // Return trimmed string to prevent whitespace at the end from the join operation\n    return flattenedString.trim();\n  }\n\n  protected prefixCss(cssClassOrId: string): string {\n    return this.config.cssPrefix + '-' + cssClassOrId;\n  }\n\n  /**\n   * Returns the configuration object of the component.\n   * @returns {Config}\n   */\n  public getConfig(): Config {\n    return this.config;\n  }\n\n  /**\n   * Hides the component if shown.\n   * This method basically transfers the component into the hidden state. Actual hiding is done via CSS.\n   */\n  hide() {\n    if (!this.hidden) {\n      this.hidden = true;\n      this.getDomElement().addClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.onHideEvent();\n    }\n  }\n\n  /**\n   * Shows the component if hidden.\n   */\n  show() {\n    if (this.hidden) {\n      this.getDomElement().removeClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.hidden = false;\n      this.onShowEvent();\n    }\n  }\n\n  /**\n   * Determines if the component is hidden.\n   * @returns {boolean} true if the component is hidden, else false\n   */\n  isHidden(): boolean {\n    return this.hidden;\n  }\n\n  /**\n   * Determines if the component is shown.\n   * @returns {boolean} true if the component is visible, else false\n   */\n  isShown(): boolean {\n    return !this.isHidden();\n  }\n\n  /**\n   * Toggles the hidden state by hiding the component if it is shown, or showing it if hidden.\n   */\n  toggleHidden() {\n    if (this.isHidden()) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  }\n\n  /**\n   * Determines if the component is currently hovered.\n   * @returns {boolean} true if the component is hovered, else false\n   */\n  isHovered(): boolean {\n    return this.hovered;\n  }\n\n  /**\n   * Fires the onShow event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onShowEvent(): void {\n    this.componentEvents.onShow.dispatch(this);\n  }\n\n  /**\n   * Fires the onHide event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHideEvent(): void {\n    this.componentEvents.onHide.dispatch(this);\n  }\n\n  /**\n   * Fires the onHoverChanged event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHoverChangedEvent(hovered: boolean): void {\n    this.hovered = hovered;\n    this.componentEvents.onHoverChanged.dispatch(this, { hovered: hovered });\n  }\n\n  /**\n   * Gets the event that is fired when the component is showing.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onShow(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onShow.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component is hiding.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onHide(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onHide.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component's hover-state is changing.\n   * @returns {Event<Component<Config>, ComponentHoverChangedEventArgs>}\n   */\n  get onHoverChanged(): Event<Component<Config>, ComponentHoverChangedEventArgs> {\n    return this.componentEvents.onHoverChanged.getEvent();\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {ArrayUtils} from '../arrayutils';\n\n/**\n * Configuration interface for a {@link Container}.\n */\nexport interface ContainerConfig extends ComponentConfig {\n  /**\n   * Child components of the container.\n   */\n  components?: Component<ComponentConfig>[];\n}\n\n/**\n * A container component that can contain a collection of child components.\n * Components can be added at construction time through the {@link ContainerConfig#components} setting, or later\n * through the {@link Container#addComponent} method. The UIManager automatically takes care of all components, i.e. it\n * initializes and configures them automatically.\n *\n * In the DOM, the container consists of an outer <div> (that can be configured by the config) and an inner wrapper\n * <div> that contains the components. This double-<div>-structure is often required to achieve many advanced effects\n * in CSS and/or JS, e.g. animations and certain formatting with absolute positioning.\n *\n * DOM example:\n * <code>\n *     <div class='ui-container'>\n *         <div class='container-wrapper'>\n *             ... child components ...\n *         </div>\n *     </div>\n * </code>\n */\nexport class Container<Config extends ContainerConfig> extends Component<ContainerConfig> {\n\n  /**\n   * A reference to the inner element that contains the components of the container.\n   */\n  private innerContainerElement: DOM;\n  private componentsToAdd: Component<ComponentConfig>[];\n  private componentsToRemove: Component<ComponentConfig>[];\n\n  constructor(config: Config) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-container',\n      components: [],\n    }, this.config);\n\n    this.componentsToAdd = [];\n    this.componentsToRemove = [];\n  }\n\n  /**\n   * Adds a child component to the container.\n   * @param component the component to add\n   */\n  addComponent(component: Component<ComponentConfig>) {\n    this.config.components.push(component);\n    this.componentsToAdd.push(component);\n  }\n\n  /**\n   * Removes a child component from the container.\n   * @param component the component to remove\n   * @returns {boolean} true if the component has been removed, false if it is not contained in this container\n   */\n  removeComponent(component: Component<ComponentConfig>): boolean {\n    if (ArrayUtils.remove(this.config.components, component) != null) {\n      this.componentsToRemove.push(component);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Gets an array of all child components in this container.\n   * @returns {Component<ComponentConfig>[]}\n   */\n  getComponents(): Component<ComponentConfig>[] {\n    return this.config.components;\n  }\n\n  /**\n   * Removes all child components from the container.\n   */\n  removeComponents(): void {\n    for (let component of this.getComponents().slice()) {\n      this.removeComponent(component);\n    }\n  }\n\n  /**\n   * Updates the DOM of the container with the current components.\n   */\n  protected updateComponents(): void {\n    /* We cannot just clear the container to remove all elements and then re-add those that should stay, because\n     * IE looses the innerHTML of unattached elements, leading to empty elements within the container (e.g. missing\n     * subtitle text in SubtitleLabel).\n     * Instead, we keep a list of elements to add and remove, leaving remaining elements alone. By keeping them in\n     * the DOM, their content gets preserved in all browsers.\n     */\n    let component;\n\n    while (component = this.componentsToRemove.shift()) {\n      component.getDomElement().remove();\n    }\n\n    while (component = this.componentsToAdd.shift()) {\n      this.innerContainerElement.append(component.getDomElement());\n    }\n  }\n\n  protected toDomElement(): DOM {\n    // Create the container element (the outer <div>)\n    let containerElement = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    });\n\n    // Create the inner container element (the inner <div>) that will contain the components\n    let innerContainer = new DOM(this.config.tag, {\n      'class': this.prefixCss('container-wrapper'),\n    });\n    this.innerContainerElement = innerContainer;\n\n    for (let initialComponent of this.config.components) {\n      this.componentsToAdd.push(initialComponent);\n    }\n    this.updateComponents();\n\n    containerElement.append(innerContainer);\n\n    return containerElement;\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {UIUtils} from '../uiutils';\nimport {Spacer} from './spacer';\n\n/**\n * Configuration interface for the {@link ControlBar}.\n */\nexport interface ControlBarConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A container for main player control components, e.g. play toggle button, seek bar, volume control, fullscreen toggle\n * button.\n */\nexport class ControlBar extends Container<ControlBarConfig> {\n\n  constructor(config: ControlBarConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-controlbar',\n      hidden: true,\n    }, <ControlBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // Counts how many components are hovered and block hiding of the control bar\n    let hoverStackCount = 0;\n\n    // Track hover status of child components\n    UIUtils.traverseTree(this, (component) => {\n      // Do not track hover status of child containers or spacers, only of 'real' controls\n      if (component instanceof Container || component instanceof Spacer) {\n        return;\n      }\n\n      // Subscribe hover event and keep a count of the number of hovered children\n      component.onHoverChanged.subscribe((sender, args) => {\n        if (args.hovered) {\n          hoverStackCount++;\n        } else {\n          hoverStackCount--;\n        }\n      });\n    });\n\n    uimanager.onControlsShow.subscribe(() => {\n      this.show();\n    });\n    uimanager.onPreviewControlsHide.subscribe((sender, args) => {\n      // Cancel the hide event if hovered child components block hiding\n      args.cancel = (hoverStackCount > 0);\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      this.hide();\n    });\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport ErrorEvent = bitmovin.PlayerAPI.ErrorEvent;\nimport {TvNoiseCanvas} from './tvnoisecanvas';\nimport PlayerEvent = bitmovin.PlayerAPI.PlayerEvent;\n\nexport interface ErrorMessageTranslator {\n  (error: ErrorEvent): string;\n}\n\nexport interface ErrorMessageMap {\n  [code: number]: string | ErrorMessageTranslator;\n}\n\n/**\n * Configuration interface for the {@link ErrorMessageOverlay}.\n */\nexport interface ErrorMessageOverlayConfig extends ContainerConfig {\n  /**\n   * Allows overwriting of the error messages displayed in the overlay for customization and localization.\n   * This is either a function that receives any {@link ErrorEvent} as parameter and translates error messages,\n   * or a map of error codes that overwrites specific error messages with a plain string or a function that\n   * receives the {@link ErrorEvent} as parameter and returns a customized string.\n   * The translation functions can be used to extract data (e.g. parameters) from the original error message.\n   *\n   * Example 1 (catch-all translation function):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: function(error) {\n   *     switch (error.code) {\n   *       // Overwrite error 3000 'Unknown error'\n   *       case 3000:\n   *         return 'Houston, we have a problem'\n   *\n   *       // Transform error 3001 'Unsupported manifest format' to uppercase\n   *       case 3001:\n   *         return error.message.toUpperCase();\n   *\n   *       // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *       case 3006:\n   *         var statusCode = error.message.substring(46);\n   *         return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *     // Return unmodified error message for all other errors\n   *     return error.message;\n   *   }\n   * };\n   * </code>\n   *\n   * Example 2 (translating specific errors):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: {\n   *     // Overwrite error 3000 'Unknown error'\n   *     3000: 'Houston, we have a problem',\n   *\n   *     // Transform error 3001 'Unsupported manifest format' to uppercase\n   *     3001: function(error) {\n   *       return error.message.toUpperCase();\n   *     },\n   *\n   *     // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *     3006: function(error) {\n   *       var statusCode = error.message.substring(46);\n   *       return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *   }\n   * };\n   * </code>\n   */\n  messages?: ErrorMessageMap | ErrorMessageTranslator;\n}\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class ErrorMessageOverlay extends Container<ErrorMessageOverlayConfig> {\n\n  private errorLabel: Label<LabelConfig>;\n  private tvNoiseBackground: TvNoiseCanvas;\n\n  constructor(config: ErrorMessageOverlayConfig = {}) {\n    super(config);\n\n    this.errorLabel = new Label<LabelConfig>({ cssClass: 'ui-errormessage-label' });\n    this.tvNoiseBackground = new TvNoiseCanvas();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-errormessage-overlay',\n      components: [this.tvNoiseBackground, this.errorLabel],\n      hidden: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <ErrorMessageOverlayConfig>this.getConfig();\n\n    player.addEventHandler(player.EVENT.ON_ERROR, (event: ErrorEvent) => {\n      let message = event.message;\n\n      // Process message translations\n      if (config.messages) {\n        if (typeof config.messages === 'function') {\n          // Translation function for all errors\n          message = config.messages(event);\n        } else if (config.messages[event.code]) {\n          // It's not a translation function, so it must be a map of strings or translation functions\n          let customMessage = config.messages[event.code];\n\n          if (typeof customMessage === 'string') {\n            message = customMessage;\n          } else {\n            // The message is a translation function, so we call it\n            message = customMessage(event);\n          }\n        }\n      }\n\n      this.errorLabel.setText(message);\n      this.tvNoiseBackground.start();\n      this.show();\n    });\n\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, (event: PlayerEvent) => {\n      if (this.isShown()) {\n        this.tvNoiseBackground.stop();\n        this.hide();\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n\n    // Canvas rendering must be explicitly stopped, else it just continues forever and hogs resources\n    this.tvNoiseBackground.stop();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the player between windowed and fullscreen view.\n */\nexport class FullscreenToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-fullscreentogglebutton',\n      text: 'Fullscreen',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let fullscreenStateHandler = () => {\n      if (player.isFullscreen()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, fullscreenStateHandler);\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, fullscreenStateHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    });\n\n    // Startup init\n    fullscreenStateHandler();\n  }\n}","import {ToggleButtonConfig} from './togglebutton';\nimport {PlaybackToggleButton} from './playbacktogglebutton';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.PlayerAPI.PlayerEvent;\nimport WarningEvent = bitmovin.PlayerAPI.WarningEvent;\n\n/**\n * A button that overlays the video and toggles between playback and pause.\n */\nexport class HugePlaybackToggleButton extends PlaybackToggleButton {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugeplaybacktogglebutton',\n      text: 'Play/Pause',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    // Update button state through API events\n    super.configure(player, uimanager, false);\n\n    let togglePlayback = () => {\n      if (player.isPlaying()) {\n        player.pause('ui');\n      } else {\n        player.play('ui');\n      }\n    };\n\n    let toggleFullscreen = () => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    };\n\n    let firstPlay = true;\n    let clickTime = 0;\n    let doubleClickTime = 0;\n\n    /*\n     * YouTube-style toggle button handling\n     *\n     * The goal is to prevent a short pause or playback interval between a click, that toggles playback, and a\n     * double click, that toggles fullscreen. In this naive approach, the first click would e.g. start playback,\n     * the second click would be detected as double click and toggle to fullscreen, and as second normal click stop\n     * playback, which results is a short playback interval with max length of the double click detection\n     * period (usually 500ms).\n     *\n     * To solve this issue, we defer handling of the first click for 200ms, which is almost unnoticeable to the user,\n     * and just toggle playback if no second click (double click) has been registered during this period. If a double\n     * click is registered, we just toggle the fullscreen. In the first 200ms, undesired playback changes thus cannot\n     * happen. If a double click is registered within 500ms, we undo the playback change and switch fullscreen mode.\n     * In the end, this method basically introduces a 200ms observing interval in which playback changes are prevented\n     * if a double click happens.\n     */\n    this.onClick.subscribe(() => {\n      // Directly start playback on first click of the button.\n      // This is a required workaround for mobile browsers where video playback needs to be triggered directly\n      // by the user. A deferred playback start through the timeout below is not considered as user action and\n      // therefore ignored by mobile browsers.\n      if (firstPlay) {\n        // Try to start playback. Then we wait for ON_PLAY and only when it arrives, we disable the firstPlay flag.\n        // If we disable the flag here, onClick was triggered programmatically instead of by a user interaction, and\n        // playback is blocked (e.g. on mobile devices due to the programmatic play() call), we loose the chance to\n        // ever start playback through a user interaction again with this button.\n        togglePlayback();\n        return;\n      }\n\n      let now = Date.now();\n\n      if (now - clickTime < 200) {\n        // We have a double click inside the 200ms interval, just toggle fullscreen mode\n        toggleFullscreen();\n        doubleClickTime = now;\n        return;\n      } else if (now - clickTime < 500) {\n        // We have a double click inside the 500ms interval, undo playback toggle and toggle fullscreen mode\n        toggleFullscreen();\n        togglePlayback();\n        doubleClickTime = now;\n        return;\n      }\n\n      clickTime = now;\n\n      setTimeout(() => {\n        if (Date.now() - doubleClickTime > 200) {\n          // No double click detected, so we toggle playback and wait what happens next\n          togglePlayback();\n        }\n      }, 200);\n    });\n\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      // Playback has really started, we can disable the flag to switch to normal toggle button handling\n      firstPlay = false;\n    });\n\n    player.addEventHandler(player.EVENT.ON_WARNING, (event: WarningEvent) => {\n      // 5008 == Playback could not be started\n      if (event.code === 5008) {\n        // if playback could not be started, reset the first play flag as we need the user interaction to start\n        firstPlay = true;\n      }\n    });\n\n    // Hide button while initializing a Cast session\n    let castInitializationHandler = (event: PlayerEvent) => {\n      if (event.type === player.EVENT.ON_CAST_START) {\n        // Hide button when session is being initialized\n        this.hide();\n      } else {\n        // Show button when session is established or initialization was aborted\n        this.show();\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_CAST_START, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, castInitializationHandler);\n\n    const suppressPlayButtonTransitionAnimation = () => {\n      // Disable the current animation\n      this.setTransitionAnimationsEnabled(false);\n\n      // Enable the transition animations for the next state change\n      this.onToggle.subscribeOnce(() => {\n        this.setTransitionAnimationsEnabled(true);\n      });\n    };\n\n    // Hide the play button animation when the UI is loaded (it should only be animated on state changes)\n    suppressPlayButtonTransitionAnimation();\n\n    const isAutoplayEnabled = player.getConfig().playback && Boolean(player.getConfig().playback.autoplay);\n    // We only know if an autoplay attempt is upcoming if the player is not yet ready. It the player is already ready,\n    // the attempt might be upcoming or might have already happened, but we don't have to handle that because we can\n    // simply rely on isPlaying and the play state events.\n    const isAutoplayUpcoming = !player.isReady() && isAutoplayEnabled;\n\n    // Hide the play button when the player is already playing or autoplay is upcoming\n    if (player.isPlaying() || isAutoplayUpcoming) {\n      // Hide the play button (switch to playing state)\n      this.on();\n      // Disable the animation of the playing state switch\n      suppressPlayButtonTransitionAnimation();\n\n      // Show the play button without an animation if a play attempt is blocked\n      player.addEventHandler(player.EVENT.ON_WARNING, (event: WarningEvent) => {\n        if (event.code === 5008) {\n          suppressPlayButtonTransitionAnimation();\n        }\n      });\n    }\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image'),\n    }));\n\n    return buttonElement;\n  }\n\n  /**\n   * Enables or disables the play state transition animations of the play button image. Can be used to suppress\n   * animations.\n   * @param {boolean} enabled true to enable the animations (default), false to disable them\n   */\n  protected setTransitionAnimationsEnabled(enabled: boolean): void {\n    const noTransitionAnimationsClass = this.prefixCss('no-transition-animations');\n\n    if (enabled) {\n      this.getDomElement().removeClass(noTransitionAnimationsClass);\n    } else if (!this.getDomElement().hasClass(noTransitionAnimationsClass)) {\n      this.getDomElement().addClass(noTransitionAnimationsClass);\n    }\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button to play/replay a video.\n */\nexport class HugeReplayButton extends Button<ButtonConfig> {\n\n  constructor(config: ButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugereplaybutton',\n      text: 'Replay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      player.play('ui');\n    });\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image'),\n    }));\n\n    return buttonElement;\n  }\n}","import {ListSelector, ListSelectorConfig} from './listselector';\nimport {DOM} from '../dom';\n\nexport class ItemSelectionList extends ListSelector<ListSelectorConfig> {\n\n  private static readonly CLASS_SELECTED = 'selected';\n\n  private listElement: DOM;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      tag: 'ul',\n      cssClass: 'ui-itemselectionlist',\n    }, this.config);\n  }\n\n  protected isActive(): boolean {\n    return this.items.length > 1;\n  }\n\n  protected toDomElement(): DOM {\n    let listElement = new DOM('ul', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    });\n\n    this.listElement = listElement;\n    this.updateDomItems();\n\n    return listElement;\n  }\n\n  protected updateDomItems(selectedValue: string = null) {\n    // Delete all children\n    this.listElement.empty();\n\n    let selectedListItem: DOM = null;\n\n    const selectItem = (listItem: DOM) => {\n      listItem.addClass(this.prefixCss(ItemSelectionList.CLASS_SELECTED));\n    };\n\n    const deselectItem = (listItem: DOM) => {\n      listItem.removeClass(this.prefixCss(ItemSelectionList.CLASS_SELECTED));\n    };\n\n    for (let item of this.items) {\n      let listItem = new DOM('li', {\n        'type': 'li',\n        'class': this.prefixCss('ui-selectionlistitem'),\n      }).append(new DOM('a', {\n      }).html(item.label));\n\n      if (!selectedListItem) {\n        if (selectedValue == null) { // If there is no pre-selected value, select the first one\n          selectedListItem = listItem;\n        } else if (String(selectedValue) === item.key) { // convert selectedValue to string to catch 'null'/null case\n          selectedListItem = listItem;\n        }\n      }\n\n      // Handle list item selections\n      listItem.on('click', () => {\n        // Deselect the previous item (if there was a selected item)\n        if (selectedListItem) {\n          deselectItem(selectedListItem);\n        }\n\n        // Select the clicked item\n        selectedListItem = listItem;\n        selectItem(listItem);\n\n        // Fire the event\n        this.onItemSelectedEvent(item.key, false);\n      });\n\n      // Select default item\n      if (selectedListItem) {\n        selectItem(selectedListItem);\n      }\n\n      this.listElement.append(listItem);\n    }\n  }\n\n  protected onItemAddedEvent(value: string) {\n    super.onItemAddedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemRemovedEvent(value: string) {\n    super.onItemRemovedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemSelectedEvent(value: string, updateDomItems: boolean = true) {\n    super.onItemSelectedEvent(value);\n    if (updateDomItems) {\n      this.updateDomItems(value);\n    }\n  }\n}\n","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, Event, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Label} component.\n */\nexport interface LabelConfig extends ComponentConfig {\n  /**\n   * The text on the label.\n   */\n  text?: string;\n}\n\n/**\n * A simple text label.\n *\n * DOM example:\n * <code>\n *     <span class='ui-label'>...some text...</span>\n * </code>\n */\nexport class Label<Config extends LabelConfig> extends Component<LabelConfig> {\n\n  private text: string;\n\n  private labelEvents = {\n    onClick: new EventDispatcher<Label<Config>, NoArgs>(),\n    onTextChanged: new EventDispatcher<Label<Config>, string>(),\n  };\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label',\n    }, this.config);\n\n    this.text = this.config.text;\n  }\n\n  protected toDomElement(): DOM {\n    let labelElement = new DOM('span', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    }).html(this.text);\n\n    labelElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return labelElement;\n  }\n\n  /**\n   * Set the text on this label.\n   * @param text\n   */\n  setText(text: string) {\n    this.text = text;\n    this.getDomElement().html(text);\n    this.onTextChangedEvent(text);\n  }\n\n  /**\n   * Gets the text on this label.\n   * @return {string} The text on the label\n   */\n  getText(): string {\n    return this.text;\n  }\n\n  /**\n   * Clears the text on this label.\n   */\n  clearText() {\n    this.getDomElement().html('');\n    this.onTextChangedEvent(null);\n  }\n\n  /**\n   * Tests if the label is empty and does not contain any text.\n   * @return {boolean} True if the label is empty, else false\n   */\n  isEmpty(): boolean {\n    return !this.text;\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onClickEvent() {\n    this.labelEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onTextChangedEvent(text: string) {\n    this.labelEvents.onTextChanged.dispatch(this, text);\n  }\n\n  /**\n   * Gets the event that is fired when the label is clicked.\n   * @returns {Event<Label<LabelConfig>, NoArgs>}\n   */\n  get onClick(): Event<Label<LabelConfig>, NoArgs> {\n    return this.labelEvents.onClick.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the text on the label is changed.\n   * @returns {Event<Label<LabelConfig>, string>}\n   */\n  get onTextChanged(): Event<Label<LabelConfig>, string> {\n    return this.labelEvents.onTextChanged.getEvent();\n  }\n}\n","import {Component, ComponentConfig} from './component';\nimport {EventDispatcher, Event} from '../eventdispatcher';\nimport {ArrayUtils} from '../arrayutils';\n\n/**\n * A map of items (key/value -> label} for a {@link ListSelector} in a {@link ListSelectorConfig}.\n */\nexport interface ListItem {\n  key: string;\n  label: string;\n}\n\n/**\n * Filter function that can be used to filter out list items added through {@link ListSelector.addItem}.\n *\n * This is intended to be used in conjunction with subclasses that populate themselves automatically\n * via the player API, e.g. {@link SubtitleSelectBox}.\n */\nexport interface ListItemFilter {\n  /**\n   * Takes a list item and decides whether it should pass or be discarded.\n   * @param {ListItem} listItem the item to apply the filter to\n   * @returns {boolean} true to let the item pass through the filter, false to discard the item\n   */\n  (listItem: ListItem): boolean;\n}\n\n/**\n * Translator function to translate labels of list items added through {@link ListSelector.addItem}.\n *\n * This is intended to be used in conjunction with subclasses that populate themselves automatically\n * via the player API, e.g. {@link SubtitleSelectBox}.\n */\nexport interface ListItemLabelTranslator {\n  /**\n   * Takes a list item, optionally changes the label, and returns the new label.\n   * @param {ListItem} listItem the item to translate\n   * @returns {string} the translated or original label\n   */\n  (listItem: ListItem): string;\n}\n\n/**\n * Configuration interface for a {@link ListSelector}.\n */\nexport interface ListSelectorConfig extends ComponentConfig {\n  items?: ListItem[];\n  filter?: ListItemFilter;\n  translator?: ListItemLabelTranslator;\n}\n\nexport abstract class ListSelector<Config extends ListSelectorConfig> extends Component<ListSelectorConfig> {\n\n  protected items: ListItem[];\n  protected selectedItem: string;\n\n  private listSelectorEvents = {\n    onItemAdded: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemRemoved: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemSelected: new EventDispatcher<ListSelector<Config>, string>(),\n  };\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      items: [],\n      cssClass: 'ui-listselector',\n    }, this.config);\n\n    this.items = this.config.items;\n  }\n\n  private getItemIndex(key: string): number {\n    for (let index in this.items) {\n      if (key === this.items[index].key) {\n        return parseInt(index);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if the specified item is part of this selector.\n   * @param key the key of the item to check\n   * @returns {boolean} true if the item is part of this selector, else false\n   */\n  hasItem(key: string): boolean {\n    return this.getItemIndex(key) > -1;\n  }\n\n  /**\n   * Adds an item to this selector by appending it to the end of the list of items. If an item with the specified\n   * key already exists, it is replaced.\n   * @param key the key of the item to add\n   * @param label the (human-readable) label of the item to add\n   */\n  addItem(key: string, label: string) {\n    const listItem = { key: key, label: label };\n\n    // Apply filter function\n    if (this.config.filter && !this.config.filter(listItem)) {\n      return;\n    }\n\n    // Apply translator function\n    if (this.config.translator) {\n      listItem.label = this.config.translator(listItem);\n    }\n\n    this.removeItem(key); // Try to remove key first to get overwrite behavior and avoid duplicate keys\n    this.items.push(listItem);\n    this.onItemAddedEvent(key);\n  }\n\n  /**\n   * Removes an item from this selector.\n   * @param key the key of the item to remove\n   * @returns {boolean} true if removal was successful, false if the item is not part of this selector\n   */\n  removeItem(key: string): boolean {\n    let index = this.getItemIndex(key);\n    if (index > -1) {\n      ArrayUtils.remove(this.items, this.items[index]);\n      this.onItemRemovedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Selects an item from the items in this selector.\n   * @param key the key of the item to select\n   * @returns {boolean} true is the selection was successful, false if the selected item is not part of the selector\n   */\n  selectItem(key: string): boolean {\n    if (key === this.selectedItem) {\n      // itemConfig is already selected, suppress any further action\n      return true;\n    }\n\n    let index = this.getItemIndex(key);\n\n    if (index > -1) {\n      this.selectedItem = key;\n      this.onItemSelectedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the key of the selected item.\n   * @returns {string} the key of the selected item or null if no item is selected\n   */\n  getSelectedItem(): string | null {\n    return this.selectedItem;\n  }\n\n  /**\n   * Removes all items from this selector.\n   */\n  clearItems() {\n    // local copy for iteration after clear\n    let items = this.items;\n    // clear items\n    this.items = [];\n\n    // clear the selection as the selected item is also removed\n    this.selectedItem = null;\n\n    // fire events\n    for (let item of items) {\n      this.onItemRemovedEvent(item.key);\n    }\n  }\n\n  /**\n   * Returns the number of items in this selector.\n   * @returns {number}\n   */\n  itemCount(): number {\n    return Object.keys(this.items).length;\n  }\n\n  protected onItemAddedEvent(key: string) {\n    this.listSelectorEvents.onItemAdded.dispatch(this, key);\n  }\n\n  protected onItemRemovedEvent(key: string) {\n    this.listSelectorEvents.onItemRemoved.dispatch(this, key);\n  }\n\n  protected onItemSelectedEvent(key: string) {\n    this.listSelectorEvents.onItemSelected.dispatch(this, key);\n  }\n\n  /**\n   * Gets the event that is fired when an item is added to the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemAdded(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemAdded.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is removed from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemRemoved(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemRemoved.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is selected from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemSelected(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemSelected.getEvent();\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Enumerates the types of content that the {@link MetadataLabel} can display.\n */\nexport enum MetadataLabelContent {\n  /**\n   * Title of the data source.\n   */\n  Title,\n  /**\n   * Description fo the data source.\n   */\n  Description,\n}\n\n/**\n * Configuration interface for {@link MetadataLabel}.\n */\nexport interface MetadataLabelConfig extends LabelConfig {\n  /**\n   * The type of content that should be displayed in the label.\n   */\n  content: MetadataLabelContent;\n}\n\n/**\n * A label that can be configured to display certain metadata.\n */\nexport class MetadataLabel extends Label<MetadataLabelConfig> {\n\n  constructor(config: MetadataLabelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClasses: ['label-metadata', 'label-metadata-' + MetadataLabelContent[config.content].toLowerCase()],\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <MetadataLabelConfig>this.getConfig();\n    let uiconfig = uimanager.getConfig();\n\n    let init = () => {\n      switch (config.content) {\n        case MetadataLabelContent.Title:\n          this.setText(uiconfig.metadata.title);\n          break;\n        case MetadataLabelContent.Description:\n          this.setText(uiconfig.metadata.description);\n          break;\n      }\n    };\n\n    let unload = () => {\n      this.setText(null);\n    };\n\n    // Init label\n    init();\n    // Reinit label when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, init);\n    // Clear labels when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, unload);\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple macOS picture-in-picture mode.\n */\nexport class PictureInPictureToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-piptogglebutton',\n      text: 'Picture-in-Picture',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    if (!player.isPictureInPictureAvailable) {\n      // If the player does not support PIP (player 7.0), we just hide this component and skip configuration\n      this.hide();\n      return;\n    }\n\n    this.onClick.subscribe(() => {\n      if (player.isPictureInPictureAvailable()) {\n        if (player.isPictureInPicture()) {\n          player.exitPictureInPicture();\n        } else {\n          player.enterPictureInPicture();\n        }\n      } else {\n        if (console) {\n          console.log('PIP unavailable');\n        }\n      }\n    });\n\n    let pipAvailableHander = () => {\n      if (player.isPictureInPictureAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, pipAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_ENTER, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_EXIT, () => {\n      this.off();\n    });\n\n    // Startup init\n    pipAvailableHander(); // Hide button if PIP not available\n    if (player.isPictureInPicture()) {\n      this.on();\n    }\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection of different playback speeds.\n */\nexport class PlaybackSpeedSelectBox extends SelectBox {\n  protected defaultPlaybackSpeeds: number[];\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n    this.defaultPlaybackSpeeds = [0.25, 0.5, 1, 1.5, 2];\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addDefaultItems();\n\n    this.onItemSelected.subscribe((sender: PlaybackSpeedSelectBox, value: string) => {\n      player.setPlaybackSpeed(parseFloat(value));\n      this.selectItem(value);\n    });\n\n    const setDefaultValue = (): void => {\n      const playbackSpeed = player.getPlaybackSpeed();\n      this.setSpeed(playbackSpeed);\n    };\n\n    // when the player hits onReady again, adjust the playback speed selection\n    player.addEventHandler(player.EVENT.ON_READY, setDefaultValue);\n\n    if (player.EVENT.ON_PLAYBACK_SPEED_CHANGED) {\n      // Since player 7.8.0\n      player.addEventHandler(player.EVENT.ON_PLAYBACK_SPEED_CHANGED, setDefaultValue);\n    }\n  }\n\n  setSpeed(speed: number): void {\n    if (!this.selectItem(String(speed))) {\n      // a playback speed was set which is not in the list, add it to the list to show it to the user\n      this.clearItems();\n      this.addDefaultItems([speed]);\n      this.selectItem(String(speed));\n    }\n  }\n\n  addDefaultItems(customItems: number[] = []): void {\n    const sortedSpeeds = this.defaultPlaybackSpeeds.concat(customItems).sort();\n\n    sortedSpeeds.forEach(element => {\n      if (element !== 1) {\n        this.addItem(String(element), `${element}x`);\n      } else {\n        this.addItem(String(element), 'Normal');\n      }\n    });\n  }\n\n  clearItems(): void {\n    this.items = [];\n    this.selectedItem = null;\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\nimport {PlayerUtils} from '../playerutils';\nimport {StringUtils} from '../stringutils';\n\nexport enum PlaybackTimeLabelMode {\n  CurrentTime,\n  TotalTime,\n  CurrentAndTotalTime,\n}\n\nexport interface PlaybackTimeLabelConfig extends LabelConfig {\n  timeLabelMode?: PlaybackTimeLabelMode;\n  hideInLivePlayback?: boolean;\n}\n\n/**\n * A label that display the current playback time and the total time through {@link PlaybackTimeLabel#setTime setTime}\n * or any string through {@link PlaybackTimeLabel#setText setText}.\n */\nexport class PlaybackTimeLabel extends Label<PlaybackTimeLabelConfig> {\n\n  private timeFormat: string;\n\n  constructor(config: PlaybackTimeLabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <PlaybackTimeLabelConfig>{\n      cssClass: 'ui-playbacktimelabel',\n      timeLabelMode: PlaybackTimeLabelMode.CurrentAndTotalTime,\n      hideInLivePlayback: false,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <PlaybackTimeLabelConfig>this.getConfig();\n    let live = false;\n    let liveCssClass = this.prefixCss('ui-playbacktimelabel-live');\n    let liveEdgeCssClass = this.prefixCss('ui-playbacktimelabel-live-edge');\n    let minWidth = 0;\n\n    let liveClickHandler = () => {\n      player.timeShift(0);\n    };\n\n    let updateLiveState = () => {\n      // Player is playing a live stream when the duration is infinite\n      live = player.isLive();\n\n      // Attach/detach live marker class\n      if (live) {\n        this.getDomElement().addClass(liveCssClass);\n        this.setText('Live');\n        if (config.hideInLivePlayback) {\n          this.hide();\n        }\n        this.onClick.subscribe(liveClickHandler);\n        updateLiveTimeshiftState();\n      } else {\n        this.getDomElement().removeClass(liveCssClass);\n        this.getDomElement().removeClass(liveEdgeCssClass);\n        this.show();\n        this.onClick.unsubscribe(liveClickHandler);\n      }\n    };\n\n    let updateLiveTimeshiftState = () => {\n      if (!live) {\n        return;\n      }\n\n      // The player is only at the live edge iff the stream is not shifted and it is actually playing or playback has\n      // never been started (meaning it isn't paused). A player that is paused is always behind the live edge.\n      // An exception is made for live streams without a timeshift window, because here we \"stop\" playback instead\n      // of pausing it (from a UI perspective), so we keep the live edge indicator on because a play would always\n      // resume at the live edge.\n      const isTimeshifted = player.getTimeShift() < 0;\n      const isTimeshiftAvailable = player.getMaxTimeShift() < 0;\n      if (!isTimeshifted && (!player.isPaused() || !isTimeshiftAvailable)) {\n        this.getDomElement().addClass(liveEdgeCssClass);\n      } else {\n        this.getDomElement().removeClass(liveEdgeCssClass);\n      }\n    };\n\n    let liveStreamDetector = new PlayerUtils.LiveStreamDetector(player);\n    liveStreamDetector.onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      live = args.live;\n      updateLiveState();\n    });\n    liveStreamDetector.detect(); // Initial detection\n\n    let playbackTimeHandler = () => {\n      if (!live && player.getDuration() !== Infinity) {\n        this.setTime(player.getCurrentTime(), player.getDuration());\n      }\n\n      // To avoid 'jumping' in the UI by varying label sizes due to non-monospaced fonts,\n      // we gradually increase the min-width with the content to reach a stable size.\n      let width = this.getDomElement().width();\n      if (width > minWidth) {\n        minWidth = width;\n        this.getDomElement().css({\n          'min-width': minWidth + 'px',\n        });\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackTimeHandler);\n\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_PLAY, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_PAUSED, updateLiveTimeshiftState);\n\n    let init = () => {\n      // Reset min-width when a new source is ready (especially for switching VOD/Live modes where the label content\n      // changes)\n      minWidth = 0;\n      this.getDomElement().css({\n        'min-width': null,\n      });\n\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n\n      // Update time after the format has been set\n      playbackTimeHandler();\n    };\n    player.addEventHandler(player.EVENT.ON_READY, init);\n\n    init();\n  }\n\n  /**\n   * Sets the current playback time and total duration.\n   * @param playbackSeconds the current playback time in seconds\n   * @param durationSeconds the total duration in seconds\n   */\n  setTime(playbackSeconds: number, durationSeconds: number) {\n    let currentTime = StringUtils.secondsToTime(playbackSeconds, this.timeFormat);\n    let totalTime = StringUtils.secondsToTime(durationSeconds, this.timeFormat);\n\n    switch ((<PlaybackTimeLabelConfig>this.config).timeLabelMode) {\n      case PlaybackTimeLabelMode.CurrentTime:\n        this.setText(`${currentTime}`);\n        break;\n      case PlaybackTimeLabelMode.TotalTime:\n        this.setText(`${totalTime}`);\n        break;\n      case PlaybackTimeLabelMode.CurrentAndTotalTime:\n        this.setText(`${currentTime} / ${totalTime}`);\n        break;\n    }\n  }\n\n  /**\n   * Sets the current time format\n   * @param timeFormat the time format\n   */\n  protected setTimeFormat(timeFormat: string): void {\n    this.timeFormat = timeFormat;\n  }\n}\n","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.PlayerAPI.PlayerEvent;\nimport {PlayerUtils} from '../playerutils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\nimport WarningEvent = bitmovin.PlayerAPI.WarningEvent;\n\n/**\n * A button that toggles between playback and pause.\n */\nexport class PlaybackToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  private static readonly CLASS_STOPTOGGLE = 'stoptoggle';\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktogglebutton',\n      text: 'Play/Pause',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager, handleClickEvent: boolean = true): void {\n    super.configure(player, uimanager);\n\n    let isSeeking = false;\n\n    // Handler to update button state based on player state\n    let playbackStateHandler = (event: PlayerEvent) => {\n      // If the UI is currently seeking, playback is temporarily stopped but the buttons should\n      // not reflect that and stay as-is (e.g indicate playback while seeking).\n      if (isSeeking) {\n        return;\n      }\n\n      if (player.isPlaying()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    // Call handler upon these events\n    player.addEventHandler(player.EVENT.ON_PLAY, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_PAUSED, playbackStateHandler);\n    if (player.EVENT.ON_PLAYING) {\n      // Since player 7.3. Not really necessary but just in case we ever miss the ON_PLAY event.\n      player.addEventHandler(player.EVENT.ON_PLAYING, playbackStateHandler);\n    }\n    // after unloading + loading a new source, the player might be in a different playing state (from playing into stopped)\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, playbackStateHandler);\n    // when playback finishes, player turns to paused mode\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYBACK_FINISHED, playbackStateHandler);\n\n    // When a playback attempt is rejected with warning 5008, we switch the button state back to off\n    // This is required for blocked autoplay, because there is no ON_PAUSED event in such case\n    player.addEventHandler(player.EVENT.ON_WARNING, (event: WarningEvent) => {\n      if (event.code === 5008) {\n        this.off();\n      }\n    });\n\n    // Detect absence of timeshifting on live streams and add tagging class to convert button icons to play/stop\n    let timeShiftDetector = new PlayerUtils.TimeShiftAvailabilityDetector(player);\n    timeShiftDetector.onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        if (!args.timeShiftAvailable) {\n          this.getDomElement().addClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        } else {\n          this.getDomElement().removeClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        }\n      }\n    );\n    timeShiftDetector.detect(); // Initial detection\n\n    if (handleClickEvent) {\n      // Control player by button events\n      // When a button event triggers a player API call, events are fired which in turn call the event handler\n      // above that updated the button state.\n      this.onClick.subscribe(() => {\n        if (player.isPlaying()) {\n          player.pause('ui');\n        } else {\n          player.play('ui');\n        }\n      });\n    }\n\n    // Track UI seeking status\n    uimanager.onSeek.subscribe(() => {\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n    });\n\n    // Startup init\n    playbackStateHandler(null);\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {HugePlaybackToggleButton} from './hugeplaybacktogglebutton';\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class PlaybackToggleOverlay extends Container<ContainerConfig> {\n\n  private playbackToggleButton: HugePlaybackToggleButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.playbackToggleButton = new HugePlaybackToggleButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktoggle-overlay',\n      components: [this.playbackToggleButton],\n    }, this.config);\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {UIInstanceManager, UIRecommendationConfig} from '../uimanager';\nimport {StringUtils} from '../stringutils';\nimport {HugeReplayButton} from './hugereplaybutton';\n\n/**\n * Overlays the player and displays recommended videos.\n */\nexport class RecommendationOverlay extends Container<ContainerConfig> {\n\n  private replayButton: HugeReplayButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.replayButton = new HugeReplayButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-overlay',\n      hidden: true,\n      components: [this.replayButton],\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clearRecommendations = () => {\n      for (let component of this.getComponents().slice()) {\n        if (component instanceof RecommendationItem) {\n          this.removeComponent(component);\n        }\n      }\n      this.updateComponents();\n      this.getDomElement().removeClass(this.prefixCss('recommendations'));\n    };\n\n    let setupRecommendations = () => {\n      clearRecommendations();\n\n      const recommendations = uimanager.getConfig().recommendations;\n\n      if (recommendations.length > 0) {\n        let index = 1;\n        for (let item of recommendations) {\n          this.addComponent(new RecommendationItem({\n            itemConfig: item,\n            cssClasses: ['recommendation-item-' + (index++)],\n          }));\n        }\n        this.updateComponents(); // create container DOM elements\n\n        this.getDomElement().addClass(this.prefixCss('recommendations'));\n      }\n    };\n\n    // Add recommendation when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupRecommendations);\n    // Remove recommendations and hide overlay when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      clearRecommendations();\n      this.hide();\n    });\n    // Display recommendations when playback has finished\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      // Dismiss ON_PLAYBACK_FINISHED events at the end of ads\n      // TODO remove this workaround once issue #1278 is solved\n      if (player.isAd()) {\n        return;\n      }\n\n      this.show();\n    });\n    // Hide recommendations when playback starts, e.g. a restart\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      this.hide();\n    });\n\n    // Init on startup\n    setupRecommendations();\n  }\n}\n\n/**\n * Configuration interface for the {@link RecommendationItem}\n */\ninterface RecommendationItemConfig extends ComponentConfig {\n  itemConfig: UIRecommendationConfig;\n}\n\n/**\n * An item of the {@link RecommendationOverlay}. Used only internally in {@link RecommendationOverlay}.\n */\nclass RecommendationItem extends Component<RecommendationItemConfig> {\n\n  constructor(config: RecommendationItemConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-item',\n      itemConfig: null, // this must be passed in from outside\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let config = (<RecommendationItemConfig>this.config).itemConfig; // TODO fix generics and get rid of cast\n\n    let itemElement = new DOM('a', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n      'href': config.url,\n    }).css({ 'background-image': `url(${config.thumbnail})` });\n\n    let bgElement = new DOM('div', {\n      'class': this.prefixCss('background'),\n    });\n    itemElement.append(bgElement);\n\n    let titleElement = new DOM('span', {\n      'class': this.prefixCss('title'),\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innertitle'),\n    }).html(config.title));\n    itemElement.append(titleElement);\n\n    let timeElement = new DOM('span', {\n      'class': this.prefixCss('duration'),\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innerduration'),\n    }).html(config.duration ? StringUtils.secondsToTime(config.duration) : ''));\n    itemElement.append(timeElement);\n\n    return itemElement;\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\nimport {SeekBarLabel} from './seekbarlabel';\nimport {UIInstanceManager, TimelineMarker, SeekPreviewArgs} from '../uimanager';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../playerutils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\nimport PlayerEvent = bitmovin.PlayerAPI.PlayerEvent;\n\n/**\n * Configuration interface for the {@link SeekBar} component.\n */\nexport interface SeekBarConfig extends ComponentConfig {\n  /**\n   * The label above the seek position.\n   */\n  label?: SeekBarLabel;\n  /**\n   * Bar will be vertical instead of horizontal if set to true.\n   */\n  vertical?: boolean;\n  /**\n   * The interval in milliseconds in which the playback position on the seek bar will be updated. The shorter the\n   * interval, the smoother it looks and the more resource intense it is. The update interval will be kept as steady\n   * as possible to avoid jitter.\n   * Set to -1 to disable smooth updating and update it on player ON_TIME_CHANGED events instead.\n   * Default: 50 (50ms = 20fps).\n   */\n  smoothPlaybackPositionUpdateIntervalMs?: number;\n}\n\n/**\n * Event argument interface for a seek preview event.\n */\nexport interface SeekPreviewEventArgs extends SeekPreviewArgs {\n  /**\n   * Tells if the seek preview event comes from a scrubbing.\n   */\n  scrubbing: boolean;\n}\n\nexport interface SeekBarMarker {\n  marker: TimelineMarker;\n  position: number;\n  duration?: number;\n}\n\n/**\n * A seek bar to seek within the player's media. It displays the current playback position, amount of buffed data, seek\n * target, and keeps status about an ongoing seek.\n *\n * The seek bar displays different 'bars':\n *  - the playback position, i.e. the position in the media at which the player current playback pointer is positioned\n *  - the buffer position, which usually is the playback position plus the time span that is already buffered ahead\n *  - the seek position, used to preview to where in the timeline a seek will jump to\n */\nexport class SeekBar extends Component<SeekBarConfig> {\n\n  public static readonly SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED = -1;\n\n  /**\n   * The CSS class that is added to the DOM element while the seek bar is in 'seeking' state.\n   */\n  private static readonly CLASS_SEEKING = 'seeking';\n\n  private seekBar: DOM;\n  private seekBarPlaybackPosition: DOM;\n  private seekBarPlaybackPositionMarker: DOM;\n  private seekBarBufferPosition: DOM;\n  private seekBarSeekPosition: DOM;\n  private seekBarBackdrop: DOM;\n  private seekBarMarkersContainer: DOM;\n\n  private label: SeekBarLabel;\n\n  private timelineMarkers: SeekBarMarker[];\n\n  /**\n   * Buffer of the the current playback position. The position must be buffered in case the element\n   * needs to be refreshed with {@link #refreshPlaybackPosition}.\n   * @type {number}\n   */\n  private playbackPositionPercentage = 0;\n\n  private smoothPlaybackPositionUpdater: Timeout;\n\n  // https://hacks.mozilla.org/2013/04/detecting-touch-its-the-why-not-the-how/\n  private touchSupported = ('ontouchstart' in window);\n\n  private seekBarEvents = {\n    /**\n     * Fired when a scrubbing seek operation is started.\n     */\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    /**\n     * Fired during a scrubbing seek to indicate that the seek preview (i.e. the video frame) should be updated.\n     */\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewEventArgs>(),\n    /**\n     * Fired when a scrubbing seek has finished or when a direct seek is issued.\n     */\n    onSeeked: new EventDispatcher<SeekBar, number>(),\n  };\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar',\n      vertical: false,\n      smoothPlaybackPositionUpdateIntervalMs: 50,\n    }, this.config);\n\n    this.label = this.config.label;\n    this.timelineMarkers = [];\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    if (this.hasLabel()) {\n      this.getLabel().initialize();\n    }\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager, configureSeek: boolean = true): void {\n    super.configure(player, uimanager);\n\n    // Apply scaling transform to the backdrop bar to have all bars rendered similarly\n    // (the call must be up here to be executed for the volume slider as well)\n    this.setPosition(this.seekBarBackdrop, 100);\n\n    if (!configureSeek) {\n      // The configureSeek flag can be used by subclasses to disable configuration as seek bar. E.g. the volume\n      // slider is reusing this component but adds its own functionality, and does not need the seek functionality.\n      // This is actually a hack, the proper solution would be for both seek bar and volume sliders to extend\n      // a common base slider component and implement their functionality there.\n      return;\n    }\n\n    let isPlaying = false;\n    let isSeeking = false;\n\n    // Update playback and buffer positions\n    let playbackPositionHandler = (event: PlayerEvent = null, forceUpdate: boolean = false) => {\n      if (isSeeking) {\n        // We caught a seek preview seek, do not update the seekbar\n        return;\n      }\n\n      if (player.isLive()) {\n        if (player.getMaxTimeShift() === 0) {\n          // This case must be explicitly handled to avoid division by zero\n          this.setPlaybackPosition(100);\n        }\n        else {\n          let playbackPositionPercentage = 100 - (100 / player.getMaxTimeShift() * player.getTimeShift());\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        // Always show full buffer for live streams\n        this.setBufferPosition(100);\n      }\n      else {\n        let playbackPositionPercentage = 100 / player.getDuration() * player.getCurrentTime();\n\n        let videoBufferLength = player.getVideoBufferLength();\n        let audioBufferLength = player.getAudioBufferLength();\n        // Calculate the buffer length which is the smaller length of the audio and video buffers. If one of these\n        // buffers is not available, we set it's value to MAX_VALUE to make sure that the other real value is taken\n        // as the buffer length.\n        let bufferLength = Math.min(\n          videoBufferLength != null ? videoBufferLength : Number.MAX_VALUE,\n          audioBufferLength != null ? audioBufferLength : Number.MAX_VALUE);\n        // If both buffer lengths are missing, we set the buffer length to zero\n        if (bufferLength === Number.MAX_VALUE) {\n          bufferLength = 0;\n        }\n\n        let bufferPercentage = 100 / player.getDuration() * bufferLength;\n\n        // Update playback position only in paused state or in the initial startup state where player is neither\n        // paused nor playing. Playback updates are handled in the Timeout below.\n        if (this.config.smoothPlaybackPositionUpdateIntervalMs === SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED\n          || forceUpdate || player.isPaused() || (player.isPaused() === player.isPlaying())) {\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        this.setBufferPosition(playbackPositionPercentage + bufferPercentage);\n      }\n    };\n\n    // Update seekbar upon these events\n    // init playback position when the player is ready\n    player.addEventHandler(player.EVENT.ON_READY, playbackPositionHandler);\n    // update playback position when it changes\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackPositionHandler);\n    // update bufferlevel when buffering is complete\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, playbackPositionHandler);\n    // update playback position when a seek has finished\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackPositionHandler);\n    // update playback position when a timeshift has finished\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, playbackPositionHandler);\n    // update bufferlevel when a segment has been downloaded\n    player.addEventHandler(player.EVENT.ON_SEGMENT_REQUEST_FINISHED, playbackPositionHandler);\n    // update playback position of Cast playback\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackPositionHandler);\n\n    this.configureLivePausedTimeshiftUpdater(player, uimanager, playbackPositionHandler);\n\n    // Seek handling\n    player.addEventHandler(player.EVENT.ON_SEEK, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      this.setSeeking(false);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, () => {\n      this.setSeeking(false);\n    });\n\n    let seek = (percentage: number) => {\n      if (player.isLive()) {\n        player.timeShift(player.getMaxTimeShift() - (player.getMaxTimeShift() * (percentage / 100)), 'ui');\n      } else {\n        player.seek(player.getDuration() * (percentage / 100), 'ui');\n      }\n    };\n    this.onSeek.subscribe((sender) => {\n      isSeeking = true; // track seeking status so we can catch events from seek preview seeks\n\n      // Notify UI manager of started seek\n      uimanager.onSeek.dispatch(sender);\n\n      // Save current playback state\n      isPlaying = player.isPlaying();\n\n      // Pause playback while seeking\n      if (isPlaying) {\n        player.pause('ui');\n      }\n    });\n    this.onSeekPreview.subscribe((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Notify UI manager of seek preview\n      uimanager.onSeekPreview.dispatch(sender, args);\n    });\n    this.onSeekPreview.subscribeRateLimited((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Rate-limited scrubbing seek\n      if (args.scrubbing) {\n        seek(args.position);\n      }\n    }, 200);\n    this.onSeeked.subscribe((sender, percentage) => {\n      isSeeking = false;\n\n      // Do the seek\n      seek(percentage);\n\n      // Continue playback after seek if player was playing when seek started\n      if (isPlaying) {\n        player.play('ui');\n      }\n\n      // Notify UI manager of finished seek\n      uimanager.onSeeked.dispatch(sender);\n    });\n\n    if (this.hasLabel()) {\n      // Configure a seekbar label that is internal to the seekbar)\n      this.getLabel().configure(player, uimanager);\n    }\n\n    // Hide seekbar for live sources without timeshift\n    let isLive = false;\n    let hasTimeShift = false;\n    let switchVisibility = (isLive: boolean, hasTimeShift: boolean) => {\n      if (isLive && !hasTimeShift) {\n        this.hide();\n      } else {\n        this.show();\n      }\n      playbackPositionHandler(null, true);\n      this.refreshPlaybackPosition();\n    };\n    let liveStreamDetector = new PlayerUtils.LiveStreamDetector(player);\n    liveStreamDetector.onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      isLive = args.live;\n      switchVisibility(isLive, hasTimeShift);\n    });\n    let timeShiftDetector = new PlayerUtils.TimeShiftAvailabilityDetector(player);\n    timeShiftDetector.onTimeShiftAvailabilityChanged.subscribe((sender, args: TimeShiftAvailabilityChangedArgs) => {\n        hasTimeShift = args.timeShiftAvailable;\n        switchVisibility(isLive, hasTimeShift);\n      }\n    );\n    // Initial detection\n    liveStreamDetector.detect();\n    timeShiftDetector.detect();\n\n    // Refresh the playback position when the player resized or the UI is configured. The playback position marker\n    // is positioned absolutely and must therefore be updated when the size of the seekbar changes.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    // Additionally, when this code is called, the seekbar is not part of the UI yet and therefore does not have a size,\n    // resulting in a wrong initial position of the marker. Refreshing it once the UI is configured solved this issue.\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n    // It can also happen that the value changes once the player is ready, or when a new source is loaded, so we need\n    // to update on ON_READY too\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Initialize seekbar\n    playbackPositionHandler(); // Set the playback position\n    this.setBufferPosition(0);\n    this.setSeekPosition(0);\n    if (this.config.smoothPlaybackPositionUpdateIntervalMs !== SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED) {\n      this.configureSmoothPlaybackPositionUpdater(player, uimanager);\n    }\n    this.configureMarkers(player, uimanager);\n  }\n\n  /**\n   * Update seekbar while a live stream with DVR window is paused.\n   * The playback position stays still and the position indicator visually moves towards the back.\n   */\n  private configureLivePausedTimeshiftUpdater(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager,\n                                              playbackPositionHandler: () => void): void {\n    // Regularly update the playback position while the timeout is active\n    const pausedTimeshiftUpdater = new Timeout(1000, playbackPositionHandler, true);\n\n    // Start updater when a live stream with timeshift window is paused\n    player.addEventHandler(player.EVENT.ON_PAUSED, () => {\n      if (player.isLive() && player.getMaxTimeShift() < 0) {\n        pausedTimeshiftUpdater.start();\n      }\n    });\n\n    // Stop updater when playback continues (no matter if the updater was started before)\n    player.addEventHandler(player.EVENT.ON_PLAY, () => pausedTimeshiftUpdater.clear());\n  }\n\n  private configureSmoothPlaybackPositionUpdater(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    /*\n     * Playback position update\n     *\n     * We do not update the position directly from the ON_TIME_CHANGED event, because it arrives very jittery and\n     * results in a jittery position indicator since the CSS transition time is statically set.\n     * To work around this issue, we maintain a local playback position that is updated in a stable regular interval\n     * and kept in sync with the player.\n     */\n    let currentTimeSeekBar = 0;\n    let currentTimePlayer = 0;\n    let updateIntervalMs = 50;\n    let currentTimeUpdateDeltaSecs = updateIntervalMs / 1000;\n\n    this.smoothPlaybackPositionUpdater = new Timeout(updateIntervalMs, () => {\n      currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      currentTimePlayer = player.getCurrentTime();\n\n      // Sync currentTime of seekbar to player\n      let currentTimeDelta = currentTimeSeekBar - currentTimePlayer;\n      // If the delta is larger that 2 secs, directly jump the seekbar to the\n      // player time instead of smoothly fast forwarding/rewinding.\n      if (Math.abs(currentTimeDelta) > 2) {\n        currentTimeSeekBar = currentTimePlayer;\n      }\n      // If currentTimeDelta is negative and below the adjustment threshold,\n      // the player is ahead of the seekbar and we 'fast forward' the seekbar\n      else if (currentTimeDelta <= -currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      }\n      // If currentTimeDelta is positive and above the adjustment threshold,\n      // the player is behind the seekbar and we 'rewind' the seekbar\n      else if (currentTimeDelta >= currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar -= currentTimeUpdateDeltaSecs;\n      }\n\n      let playbackPositionPercentage = 100 / player.getDuration() * currentTimeSeekBar;\n      this.setPlaybackPosition(playbackPositionPercentage);\n    }, true);\n\n    let startSmoothPlaybackPositionUpdater = () => {\n      if (!player.isLive()) {\n        currentTimeSeekBar = player.getCurrentTime();\n        this.smoothPlaybackPositionUpdater.start();\n      }\n    };\n\n    let stopSmoothPlaybackPositionUpdater = () => {\n      this.smoothPlaybackPositionUpdater.clear();\n    };\n\n    player.addEventHandler(player.EVENT.ON_PLAY, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      currentTimeSeekBar = player.getCurrentTime();\n    });\n\n    if (player.isPlaying()) {\n      startSmoothPlaybackPositionUpdater();\n    }\n  }\n\n  private configureMarkers(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    let clearMarkers = () => {\n      this.timelineMarkers = [];\n      this.updateMarkers();\n    };\n\n    let setupMarkers = () => {\n      clearMarkers();\n\n      const duration = player.getDuration();\n\n      if (duration === Infinity) {\n        // Don't generate timeline markers if we don't yet have a duration\n        // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n        return;\n      }\n\n      for (let marker of uimanager.getConfig().metadata.markers) {\n        const markerPosition = 100 / duration * marker.time; // convert absolute time to percentage\n        const markerDuration = 100 / duration * marker.duration;\n        this.timelineMarkers.push({ marker, position: markerPosition, duration: markerDuration });\n      }\n\n      // Populate the timeline with the markers\n      this.updateMarkers();\n    };\n\n    // Add markers when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupMarkers);\n    // Remove markers when unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, clearMarkers);\n    // Update markers when the size of the seekbar changes\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => this.updateMarkers());\n    // Update markers when a marker is added or removed\n    uimanager.getConfig().events.onUpdated.subscribe(setupMarkers);\n    uimanager.onRelease.subscribe(() => uimanager.getConfig().events.onUpdated.unsubscribe(setupMarkers));\n\n    // Init markers at startup\n    setupMarkers();\n  }\n\n  release(): void {\n    super.release();\n\n    if (this.smoothPlaybackPositionUpdater) { // object must not necessarily exist, e.g. in volume slider subclass\n      this.smoothPlaybackPositionUpdater.clear();\n    }\n  }\n\n  protected toDomElement(): DOM {\n    if (this.config.vertical) {\n      this.config.cssClasses.push('vertical');\n    }\n\n    let seekBarContainer = new DOM('div', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    });\n\n    let seekBar = new DOM('div', {\n      'class': this.prefixCss('seekbar'),\n    });\n    this.seekBar = seekBar;\n\n    // Indicator that shows the buffer fill level\n    let seekBarBufferLevel = new DOM('div', {\n      'class': this.prefixCss('seekbar-bufferlevel'),\n    });\n    this.seekBarBufferPosition = seekBarBufferLevel;\n\n    // Indicator that shows the current playback position\n    let seekBarPlaybackPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition'),\n    });\n    this.seekBarPlaybackPosition = seekBarPlaybackPosition;\n\n    // A marker of the current playback position, e.g. a dot or line\n    let seekBarPlaybackPositionMarker = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition-marker'),\n    });\n    this.seekBarPlaybackPositionMarker = seekBarPlaybackPositionMarker;\n\n    // Indicator that show where a seek will go to\n    let seekBarSeekPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-seekposition'),\n    });\n    this.seekBarSeekPosition = seekBarSeekPosition;\n\n    // Indicator that shows the full seekbar\n    let seekBarBackdrop = new DOM('div', {\n      'class': this.prefixCss('seekbar-backdrop'),\n    });\n    this.seekBarBackdrop = seekBarBackdrop;\n\n    let seekBarChapterMarkersContainer = new DOM('div', {\n      'class': this.prefixCss('seekbar-markers'),\n    });\n    this.seekBarMarkersContainer = seekBarChapterMarkersContainer;\n\n    seekBar.append(this.seekBarBackdrop, this.seekBarBufferPosition, this.seekBarSeekPosition,\n      this.seekBarPlaybackPosition, this.seekBarMarkersContainer, this.seekBarPlaybackPositionMarker);\n\n    let seeking = false;\n\n    // Define handler functions so we can attach/remove them later\n    let mouseTouchMoveHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      let targetPercentage = 100 * this.getOffset(e);\n      this.setSeekPosition(targetPercentage);\n      this.setPlaybackPosition(targetPercentage);\n      this.onSeekPreviewEvent(targetPercentage, true);\n    };\n    let mouseTouchUpHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      // Remove handlers, seek operation is finished\n      new DOM(document).off('touchmove mousemove', mouseTouchMoveHandler);\n      new DOM(document).off('touchend mouseup', mouseTouchUpHandler);\n\n      let targetPercentage = 100 * this.getOffset(e);\n      let snappedChapter = this.getMarkerAtPosition(targetPercentage);\n\n      this.setSeeking(false);\n      seeking = false;\n\n      // Fire seeked event\n      this.onSeekedEvent(snappedChapter ? snappedChapter.position : targetPercentage);\n    };\n\n    // A seek always start with a touchstart or mousedown directly on the seekbar.\n    // To track a mouse seek also outside the seekbar (for touch events this works automatically),\n    // so the user does not need to take care that the mouse always stays on the seekbar, we attach the mousemove\n    // and mouseup handlers to the whole document. A seek is triggered when the user lifts the mouse key.\n    // A seek mouse gesture is thus basically a click with a long time frame between down and up events.\n    seekBar.on('touchstart mousedown', (e: MouseEvent | TouchEvent) => {\n      let isTouchEvent = this.touchSupported && e instanceof TouchEvent;\n\n      // Prevent selection of DOM elements (also prevents mousedown if current event is touchstart)\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      this.setSeeking(true); // Set seeking class on DOM element\n      seeking = true; // Set seek tracking flag\n\n      // Fire seeked event\n      this.onSeekEvent();\n\n      // Add handler to track the seek operation over the whole document\n      new DOM(document).on(isTouchEvent ? 'touchmove' : 'mousemove', mouseTouchMoveHandler);\n      new DOM(document).on(isTouchEvent ? 'touchend' : 'mouseup', mouseTouchUpHandler);\n    });\n\n    // Display seek target indicator when mouse hovers or finger slides over seekbar\n    seekBar.on('touchmove mousemove', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      if (seeking) {\n        // During a seek (when mouse is down or touch move active), we need to stop propagation to avoid\n        // the VR viewport reacting to the moves.\n        e.stopPropagation();\n        // Because the stopped propagation inhibits the event on the document, we need to call it from here\n        mouseTouchMoveHandler(e);\n      }\n\n      let position = 100 * this.getOffset(e);\n      this.setSeekPosition(position);\n      this.onSeekPreviewEvent(position, false);\n\n      if (this.hasLabel() && this.getLabel().isHidden()) {\n        this.getLabel().show();\n      }\n    });\n\n    // Hide seek target indicator when mouse or finger leaves seekbar\n    seekBar.on('touchend mouseleave', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      this.setSeekPosition(0);\n\n      if (this.hasLabel()) {\n        this.getLabel().hide();\n      }\n    });\n\n    seekBarContainer.append(seekBar);\n\n    if (this.label) {\n      seekBarContainer.append(this.label.getDomElement());\n    }\n\n    return seekBarContainer;\n  }\n\n  protected updateMarkers(): void {\n    this.seekBarMarkersContainer.empty();\n\n    const seekBarWidthPx = this.seekBar.width();\n\n    for (let marker of this.timelineMarkers) {\n      const markerClasses = ['seekbar-marker'].concat(marker.marker.cssClasses || [])\n        .map(cssClass => this.prefixCss(cssClass));\n\n      const cssProperties: {[propertyName: string]: string} = {\n        'width': marker.position + '%',\n      };\n\n      if (marker.duration > 0) {\n        const markerWidthPx = Math.round(seekBarWidthPx / 100 * marker.duration);\n        cssProperties['border-right-width'] = markerWidthPx + 'px';\n        cssProperties['margin-left'] = '0';\n      }\n\n      this.seekBarMarkersContainer.append(new DOM('div', {\n        'class': markerClasses.join(' '),\n        'data-marker-time': String(marker.marker.time),\n        'data-marker-title': String(marker.marker.title),\n      }).css(cssProperties));\n    }\n  }\n\n  protected getMarkerAtPosition(percentage: number): SeekBarMarker | null {\n    const snappingRange = 1;\n\n    if (this.timelineMarkers.length > 0) {\n      for (let marker of this.timelineMarkers) {\n        // Handle interval markers\n        if (marker.duration > 0\n          && percentage >= marker.position - snappingRange\n          && percentage <= marker.position + marker.duration + snappingRange) {\n          return marker;\n        }\n        // Handle position markers\n        else if (percentage >= marker.position - snappingRange\n          && percentage <= marker.position + snappingRange) {\n          return marker;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets the horizontal offset of a mouse/touch event point from the left edge of the seek bar.\n   * @param eventPageX the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the left edge and 1 is the right edge\n   */\n  private getHorizontalOffset(eventPageX: number): number {\n    let elementOffsetPx = this.seekBar.offset().left;\n    let widthPx = this.seekBar.width();\n    let offsetPx = eventPageX - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the vertical offset of a mouse/touch event point from the bottom edge of the seek bar.\n   * @param eventPageY the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the bottom edge and 1 is the top edge\n   */\n  private getVerticalOffset(eventPageY: number): number {\n    let elementOffsetPx = this.seekBar.offset().top;\n    let widthPx = this.seekBar.height();\n    let offsetPx = eventPageY - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return 1 - this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the mouse or touch event offset for the current configuration (horizontal or vertical).\n   * @param e the event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1]\n   * @see #getHorizontalOffset\n   * @see #getVerticalOffset\n   */\n  private getOffset(e: MouseEvent | TouchEvent): number {\n    if (this.touchSupported && e instanceof TouchEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.type === 'touchend' ? e.changedTouches[0].pageY : e.touches[0].pageY);\n      } else {\n        return this.getHorizontalOffset(e.type === 'touchend' ? e.changedTouches[0].pageX : e.touches[0].pageX);\n      }\n    }\n    else if (e instanceof MouseEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.pageY);\n      } else {\n        return this.getHorizontalOffset(e.pageX);\n      }\n    }\n    else {\n      if (console) {\n        console.warn('invalid event');\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Sanitizes the mouse offset to the range of [0, 1].\n   *\n   * When tracking the mouse outside the seek bar, the offset can be outside the desired range and this method\n   * limits it to the desired range. E.g. a mouse event left of the left edge of a seek bar yields an offset below\n   * zero, but to display the seek target on the seek bar, we need to limit it to zero.\n   *\n   * @param offset the offset to sanitize\n   * @returns {number} the sanitized offset.\n   */\n  private sanitizeOffset(offset: number) {\n    // Since we track mouse moves over the whole document, the target can be outside the seek range,\n    // and we need to limit it to the [0, 1] range.\n    if (offset < 0) {\n      offset = 0;\n    } else if (offset > 1) {\n      offset = 1;\n    }\n\n    return offset;\n  }\n\n  /**\n   * Sets the position of the playback position indicator.\n   * @param percent a number between 0 and 100 as returned by the player\n   */\n  setPlaybackPosition(percent: number) {\n    this.playbackPositionPercentage = percent;\n\n    // Set position of the bar\n    this.setPosition(this.seekBarPlaybackPosition, percent);\n\n    // Set position of the marker\n    let totalSize = (this.config.vertical ? (this.seekBar.height() - this.seekBarPlaybackPositionMarker.height()) : this.seekBar.width());\n    let px = (totalSize) / 100 * percent;\n    if (this.config.vertical) {\n      px = this.seekBar.height() - px - this.seekBarPlaybackPositionMarker.height();\n    }\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      // -webkit-transform required for Android 4.4 WebView\n      {\n        'transform': 'translateY(' + px + 'px)',\n        '-ms-transform': 'translateY(' + px + 'px)',\n        '-webkit-transform': 'translateY(' + px + 'px)',\n      } :\n      {\n        'transform': 'translateX(' + px + 'px)',\n        '-ms-transform': 'translateX(' + px + 'px)',\n        '-webkit-transform': 'translateX(' + px + 'px)',\n      };\n    this.seekBarPlaybackPositionMarker.css(style);\n  }\n\n  /**\n   * Refreshes the playback position. Can be used by subclasses to refresh the position when\n   * the size of the component changes.\n   */\n  protected refreshPlaybackPosition() {\n    this.setPlaybackPosition(this.playbackPositionPercentage);\n  }\n\n  /**\n   * Sets the position until which media is buffered.\n   * @param percent a number between 0 and 100\n   */\n  setBufferPosition(percent: number) {\n    this.setPosition(this.seekBarBufferPosition, percent);\n  }\n\n  /**\n   * Sets the position where a seek, if executed, would jump to.\n   * @param percent a number between 0 and 100\n   */\n  setSeekPosition(percent: number) {\n    this.setPosition(this.seekBarSeekPosition, percent);\n  }\n\n  /**\n   * Set the actual position (width or height) of a DOM element that represent a bar in the seek bar.\n   * @param element the element to set the position for\n   * @param percent a number between 0 and 100\n   */\n  private setPosition(element: DOM, percent: number) {\n    let scale = percent / 100;\n\n    // When the scale is exactly 1 or very near 1 (and the browser internally rounds it to 1), browsers seem to render\n    // the elements differently and the height gets slightly off, leading to mismatching heights when e.g. the buffer\n    // level bar has a width of 1 and the playback position bar has a width < 1. A jittering buffer level around 1\n    // leads to an even worse flickering effect.\n    // Various changes in CSS styling and DOM hierarchy did not solve the issue so the workaround is to avoid a scale\n    // of exactly 1.\n    if (scale >= 0.99999 && scale <= 1.00001) {\n      scale = 0.99999;\n    }\n\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      // -webkit-transform required for Android 4.4 WebView\n      {\n        'transform': 'scaleY(' + scale + ')',\n        '-ms-transform': 'scaleY(' + scale + ')',\n        '-webkit-transform': 'scaleY(' + scale + ')',\n      } :\n      {\n        'transform': 'scaleX(' + scale + ')',\n        '-ms-transform': 'scaleX(' + scale + ')',\n        '-webkit-transform': 'scaleX(' + scale + ')',\n      };\n    element.css(style);\n  }\n\n  /**\n   * Puts the seek bar into or out of seeking state by adding/removing a class to the DOM element. This can be used\n   * to adjust the styling while seeking.\n   *\n   * @param seeking should be true when entering seek state, false when exiting the seek state\n   */\n  setSeeking(seeking: boolean) {\n    if (seeking) {\n      this.getDomElement().addClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    } else {\n      this.getDomElement().removeClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    }\n  }\n\n  /**\n   * Checks if the seek bar is currently in the seek state.\n   * @returns {boolean} true if in seek state, else false\n   */\n  isSeeking(): boolean {\n    return this.getDomElement().hasClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n  }\n\n  /**\n   * Checks if the seek bar has a {@link SeekBarLabel}.\n   * @returns {boolean} true if the seek bar has a label, else false\n   */\n  hasLabel(): boolean {\n    return this.label != null;\n  }\n\n  /**\n   * Gets the label of this seek bar.\n   * @returns {SeekBarLabel} the label if this seek bar has a label, else null\n   */\n  getLabel(): SeekBarLabel | null {\n    return this.label;\n  }\n\n  protected onSeekEvent() {\n    this.seekBarEvents.onSeek.dispatch(this);\n  }\n\n  protected onSeekPreviewEvent(percentage: number, scrubbing: boolean) {\n    let snappedMarker = this.getMarkerAtPosition(percentage);\n\n    let seekPositionPercentage = percentage;\n\n    if (snappedMarker) {\n      if (snappedMarker.duration > 0) {\n        if (percentage < snappedMarker.position) {\n          // Snap the position to the start of the interval if the seek is within the left snap margin\n          // We know that we are within a snap margin when we are outside the marker interval but still\n          // have a snappedMarker\n          seekPositionPercentage = snappedMarker.position;\n        } else if (percentage > snappedMarker.position + snappedMarker.duration) {\n          // Snap the position to the end of the interval if the seek is within the right snap margin\n          seekPositionPercentage = snappedMarker.position + snappedMarker.duration;\n        }\n      } else {\n        // Position markers always snap to their marker position\n        seekPositionPercentage = snappedMarker.position;\n      }\n    }\n\n    if (this.label) {\n      this.label.getDomElement().css({\n        'left': seekPositionPercentage + '%',\n      });\n    }\n\n    this.seekBarEvents.onSeekPreview.dispatch(this, {\n      scrubbing: scrubbing,\n      position: seekPositionPercentage,\n      marker: snappedMarker,\n    });\n  }\n\n  protected onSeekedEvent(percentage: number) {\n    this.seekBarEvents.onSeeked.dispatch(this, percentage);\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek operation is started.\n   * @returns {Event<SeekBar, NoArgs>}\n   */\n  get onSeek(): Event<SeekBar, NoArgs> {\n    return this.seekBarEvents.onSeek.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired during a scrubbing seek (to indicate that the seek preview, i.e. the video frame,\n   * should be updated), or during a normal seek preview when the seek bar is hovered (and the seek target,\n   * i.e. the seek bar label, should be updated).\n   * @returns {Event<SeekBar, SeekPreviewEventArgs>}\n   */\n  get onSeekPreview(): Event<SeekBar, SeekPreviewEventArgs> {\n    return this.seekBarEvents.onSeekPreview.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek has finished or when a direct seek is issued.\n   * @returns {Event<SeekBar, number>}\n   */\n  get onSeeked(): Event<SeekBar, number> {\n    return this.seekBarEvents.onSeeked.getEvent();\n  }\n\n\n  protected onShowEvent(): void {\n    super.onShowEvent();\n\n    // Refresh the position of the playback position when the seek bar becomes visible. To correctly set the position,\n    // the DOM element must be fully initialized an have its size calculated, because the position is set as an absolute\n    // value calculated from the size. This required size is not known when it is hidden.\n    // For such cases, we refresh the position here in onShow because here it is guaranteed that the component knows\n    // its size and can set the position correctly.\n    this.refreshPlaybackPosition();\n  }\n}\n","import {Container, ContainerConfig} from './container';\nimport {Label, LabelConfig} from './label';\nimport {Component, ComponentConfig} from './component';\nimport {UIInstanceManager, SeekPreviewArgs} from '../uimanager';\nimport {StringUtils} from '../stringutils';\nimport {ImageLoader} from '../imageloader';\n\n/**\n * Configuration interface for a {@link SeekBarLabel}.\n */\nexport interface SeekBarLabelConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A label for a {@link SeekBar} that can display the seek target time, a thumbnail, and title (e.g. chapter title).\n */\nexport class SeekBarLabel extends Container<SeekBarLabelConfig> {\n\n  private timeLabel: Label<LabelConfig>;\n  private titleLabel: Label<LabelConfig>;\n  private thumbnail: Component<ComponentConfig>;\n\n  private thumbnailImageLoader: ImageLoader;\n\n  private timeFormat: string;\n\n  constructor(config: SeekBarLabelConfig = {}) {\n    super(config);\n\n    this.timeLabel = new Label({ cssClasses: ['seekbar-label-time'] });\n    this.titleLabel = new Label({ cssClasses: ['seekbar-label-title'] });\n    this.thumbnail = new Component({ cssClasses: ['seekbar-thumbnail'] });\n    this.thumbnailImageLoader = new ImageLoader();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar-label',\n      components: [new Container({\n        components: [\n          this.thumbnail,\n          new Container({\n            components: [this.titleLabel, this.timeLabel],\n            cssClass: 'seekbar-label-metadata',\n          })],\n        cssClass: 'seekbar-label-inner',\n      })],\n      hidden: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let appliedMarkerCssClasses: string[] = [];\n\n    uimanager.onSeekPreview.subscribeRateLimited((sender, args: SeekPreviewArgs) => {\n      if (player.isLive()) {\n        let maxTimeShift = player.getMaxTimeShift();\n        let time = maxTimeShift - maxTimeShift * (args.position / 100);\n        this.setTime(time);\n      } else {\n        if (args.marker) {\n          this.setTitleText(args.marker.marker.title);\n        } else {\n          this.setTitleText(null);\n        }\n        let time = player.getDuration() * (args.position / 100);\n        this.setTime(time);\n        this.setThumbnail(player.getThumb(time));\n      }\n\n      // Remove CSS classes from previous marker\n      if (appliedMarkerCssClasses.length > 0) {\n        this.getDomElement().removeClass(appliedMarkerCssClasses.join(' '));\n        appliedMarkerCssClasses = [];\n      }\n\n      // Add CSS classes of current marker\n      if (args.marker) {\n        const cssClasses = (args.marker.marker.cssClasses || []).map(cssClass => this.prefixCss(cssClass));\n        this.getDomElement().addClass(cssClasses.join(' '));\n        appliedMarkerCssClasses = cssClasses;\n      }\n    }, 100);\n\n    let init = () => {\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, init);\n    init();\n  }\n\n  /**\n   * Sets arbitrary text on the label.\n   * @param text the text to show on the label\n   */\n  setText(text: string) {\n    this.timeLabel.setText(text);\n  }\n\n  /**\n   * Sets a time to be displayed on the label.\n   * @param seconds the time in seconds to display on the label\n   */\n  setTime(seconds: number) {\n    this.setText(StringUtils.secondsToTime(seconds, this.timeFormat));\n  }\n\n  /**\n   * Sets the text on the title label.\n   * @param text the text to show on the label\n   */\n  setTitleText(text: string) {\n    this.titleLabel.setText(text);\n  }\n\n  /**\n   * Sets or removes a thumbnail on the label.\n   * @param thumbnail the thumbnail to display on the label or null to remove a displayed thumbnail\n   */\n  setThumbnail(thumbnail: bitmovin.PlayerAPI.Thumbnail = null) {\n    let thumbnailElement = this.thumbnail.getDomElement();\n\n    if (thumbnail == null) {\n      thumbnailElement.css({\n        'background-image': null,\n        'display': null,\n        'width': null,\n        'height': null,\n      });\n    }\n    else {\n      // We use the thumbnail image loader to make sure the thumbnail is loaded and it's size is known before be can\n      // calculate the CSS properties and set them on the element.\n      this.thumbnailImageLoader.load(thumbnail.url, (url, width, height) => {\n        let thumbnailCountX = width / thumbnail.w;\n        let thumbnailCountY = height / thumbnail.h;\n\n        let thumbnailIndexX = thumbnail.x / thumbnail.w;\n        let thumbnailIndexY = thumbnail.y / thumbnail.h;\n\n        let sizeX = 100 * thumbnailCountX;\n        let sizeY = 100 * thumbnailCountY;\n\n        let offsetX = 100 * thumbnailIndexX;\n        let offsetY = 100 * thumbnailIndexY;\n\n        let aspectRatio = 1 / thumbnail.w * thumbnail.h;\n\n        // The thumbnail size is set by setting the CSS 'width' and 'padding-bottom' properties. 'padding-bottom' is\n        // used because it is relative to the width and can be used to set the aspect ratio of the thumbnail.\n        // A default value for width is set in the stylesheet and can be overwritten from there or anywhere else.\n        thumbnailElement.css({\n          'display': 'inherit',\n          'background-image': `url(${thumbnail.url})`,\n          'padding-bottom': `${100 * aspectRatio}%`,\n          'background-size': `${sizeX}% ${sizeY}%`,\n          'background-position': `-${offsetX}% -${offsetY}%`,\n        });\n      });\n    }\n  }\n}","import {ListSelector, ListSelectorConfig} from './listselector';\nimport {DOM} from '../dom';\n\n/**\n * A simple select box providing the possibility to select a single item out of a list of available items.\n *\n * DOM example:\n * <code>\n *     <select class='ui-selectbox'>\n *         <option value='key'>label</option>\n *         ...\n *     </select>\n * </code>\n */\nexport class SelectBox extends ListSelector<ListSelectorConfig> {\n\n  private selectElement: DOM;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-selectbox',\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let selectElement = new DOM('select', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    });\n\n    this.selectElement = selectElement;\n    this.updateDomItems();\n\n    selectElement.on('change', () => {\n      let value = selectElement.val();\n      this.onItemSelectedEvent(value, false);\n    });\n\n    return selectElement;\n  }\n\n  protected updateDomItems(selectedValue: string = null) {\n    // Delete all children\n    this.selectElement.empty();\n\n    // Add updated children\n    for (let item of this.items) {\n      let optionElement = new DOM('option', {\n        'value': item.key,\n      }).html(item.label);\n\n      if (item.key === String(selectedValue)) { // convert selectedValue to string to catch 'null'/null case\n        optionElement.attr('selected', 'selected');\n      }\n\n      this.selectElement.append(optionElement);\n    }\n  }\n\n  protected onItemAddedEvent(value: string) {\n    super.onItemAddedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemRemovedEvent(value: string) {\n    super.onItemRemovedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemSelectedEvent(value: string, updateDomItems: boolean = true) {\n    super.onItemSelectedEvent(value);\n    if (updateDomItems) {\n      this.updateDomItems(value);\n    }\n  }\n}\n","import {ContainerConfig, Container} from './container';\nimport {ComponentConfig, Component} from './component';\nimport {SelectBox} from './selectbox';\nimport {Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {VideoQualitySelectBox} from './videoqualityselectbox';\nimport {AudioQualitySelectBox} from './audioqualityselectbox';\nimport {Timeout} from '../timeout';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link SettingsPanel}.\n */\nexport interface SettingsPanelConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the settings panel will be hidden when there is no user interaction.\n   * Set to -1 to disable automatic hiding.\n   * Default: 3 seconds (3000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * A panel containing a list of {@link SettingsPanelItem items} that represent labelled settings.\n */\nexport class SettingsPanel extends Container<SettingsPanelConfig> {\n\n  private static readonly CLASS_LAST = 'last';\n\n  private settingsPanelEvents = {\n    onSettingsStateChanged: new EventDispatcher<SettingsPanel, NoArgs>(),\n  };\n\n  private hideTimeout: Timeout;\n\n  constructor(config: SettingsPanelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig<SettingsPanelConfig>(config, {\n      cssClass: 'ui-settings-panel',\n      hideDelay: 3000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsPanelConfig>this.getConfig(); // TODO fix generics type inference\n\n    if (config.hideDelay > -1) {\n      this.hideTimeout = new Timeout(config.hideDelay, () => {\n        this.hide();\n        this.hideHoveredSelectBoxes();\n      });\n\n      this.onShow.subscribe(() => {\n        // Activate timeout when shown\n        this.hideTimeout.start();\n      });\n      this.getDomElement().on('mouseenter', () => {\n        // On mouse enter clear the timeout\n        this.hideTimeout.clear();\n      });\n      this.getDomElement().on('mouseleave', () => {\n        // On mouse leave activate the timeout\n        this.hideTimeout.reset();\n      });\n      this.onHide.subscribe(() => {\n        // Clear timeout when hidden from outside\n        this.hideTimeout.clear();\n      });\n    }\n\n    // Fire event when the state of a settings-item has changed\n    let settingsStateChangedHandler = () => {\n      this.onSettingsStateChangedEvent();\n\n      // Attach marker class to last visible item\n      let lastShownItem = null;\n      for (let component of this.getItems()) {\n        component.getDomElement().removeClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n        if (component.isShown()) {\n          lastShownItem = component;\n        }\n      }\n      if (lastShownItem) {\n        lastShownItem.getDomElement().addClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n      }\n    };\n    for (let component of this.getItems()) {\n      component.onActiveChanged.subscribe(settingsStateChangedHandler);\n    }\n  }\n\n  /**\n   * Hack for IE + Firefox\n   * when the settings panel fades out while an item of a select box is still hovered, the select box will not fade out\n   * while the settings panel does. This would leave a floating select box, which is just weird\n   */\n  private hideHoveredSelectBoxes() {\n    this.getItems().forEach((item: SettingsPanelItem) => {\n      if (item.isActive() && (item as any).setting instanceof SelectBox) {\n        const selectBox = (item as any).setting as SelectBox;\n        const oldDisplay = selectBox.getDomElement().css('display');\n        // updating the display to none marks the select-box as inactive, so it will be hidden with the rest\n        // we just have to make sure to reset this as soon as possible\n        selectBox.getDomElement().css('display', 'none');\n        if (window.requestAnimationFrame) {\n          requestAnimationFrame(() => { selectBox.getDomElement().css('display', oldDisplay); });\n        } else {\n          // IE9 has no requestAnimationFrame, set the value directly. It has no optimization about ignoring DOM-changes\n          // between animationFrames\n          selectBox.getDomElement().css('display', oldDisplay);\n        }\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n    if (this.hideTimeout) {\n      this.hideTimeout.clear();\n    }\n  }\n\n  /**\n   * Checks if there are active settings within this settings panel. An active setting is a setting that is visible\n   * and enabled, which the user can interact with.\n   * @returns {boolean} true if there are active settings, false if the panel is functionally empty to a user\n   */\n  hasActiveSettings(): boolean {\n    for (let component of this.getItems()) {\n      if (component.isActive()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private getItems(): SettingsPanelItem[] {\n    return <SettingsPanelItem[]>this.config.components.filter(component => component instanceof SettingsPanelItem);\n  }\n\n  protected onSettingsStateChangedEvent() {\n    this.settingsPanelEvents.onSettingsStateChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when one or more {@link SettingsPanelItem items} have changed state.\n   * @returns {Event<SettingsPanel, NoArgs>}\n   */\n  get onSettingsStateChanged(): Event<SettingsPanel, NoArgs> {\n    return this.settingsPanelEvents.onSettingsStateChanged.getEvent();\n  }\n}\n\n/**\n * An item for a {@link SettingsPanel},\n * Containing an optionnal {@link Label} and a component that configures a setting.\n * If the components is a {@link SelectBox} it will handle the logic of displaying it or not\n */\nexport class SettingsPanelItem extends Container<ContainerConfig> {\n\n  private label: Component<ComponentConfig>;\n  private setting: Component<ComponentConfig>;\n\n  private settingsPanelItemEvents = {\n    onActiveChanged: new EventDispatcher<SettingsPanelItem, NoArgs>(),\n  };\n\n  constructor(label: string | Component<ComponentConfig>, setting: Component<ComponentConfig>, config: ContainerConfig = {}) {\n    super(config);\n\n    this.setting = setting;\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settings-panel-item',\n    }, this.config);\n\n    if (label !== null) {\n      if (label instanceof Component) {\n        this.label = label;\n      } else {\n        this.label = new Label({ text: label });\n      }\n      this.addComponent(this.label);\n    }\n\n    this.addComponent(this.setting);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    if (this.setting instanceof SelectBox) {\n      let handleConfigItemChanged = () => {\n        if (! (this.setting instanceof SelectBox)) {\n          return;\n        }\n        // The minimum number of items that must be available for the setting to be displayed\n        // By default, at least two items must be available, else a selection is not possible\n        let minItemsToDisplay = 2;\n        // Audio/video quality select boxes contain an additional 'auto' mode, which in combination with a single\n        // available quality also does not make sense\n        if ((this.setting instanceof VideoQualitySelectBox && this.setting.hasAutoItem())\n          || this.setting instanceof AudioQualitySelectBox) {\n          minItemsToDisplay = 3;\n        }\n\n        // Hide the setting if no meaningful choice is available\n        if (this.setting.itemCount() < minItemsToDisplay) {\n          this.hide();\n        } else {\n          this.show();\n        }\n\n        // Visibility might have changed and therefore the active state might have changed so we fire the event\n        // TODO fire only when state has really changed (e.g. check if visibility has really changed)\n        this.onActiveChangedEvent();\n      };\n\n      this.setting.onItemAdded.subscribe(handleConfigItemChanged);\n      this.setting.onItemRemoved.subscribe(handleConfigItemChanged);\n\n      // Initialize hidden state\n      handleConfigItemChanged();\n    }\n  }\n\n  /**\n   * Checks if this settings panel item is active, i.e. visible and enabled and a user can interact with it.\n   * @returns {boolean} true if the panel is active, else false\n   */\n  isActive(): boolean {\n    return this.isShown();\n  }\n\n  protected onActiveChangedEvent() {\n    this.settingsPanelItemEvents.onActiveChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the 'active' state of this item changes.\n   * @see #isActive\n   * @returns {Event<SettingsPanelItem, NoArgs>}\n   */\n  get onActiveChanged(): Event<SettingsPanelItem, NoArgs> {\n    return this.settingsPanelItemEvents.onActiveChanged.getEvent();\n  }\n}\n","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {SettingsPanel} from './settingspanel';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link SettingsToggleButton}.\n */\nexport interface SettingsToggleButtonConfig extends ToggleButtonConfig {\n  /**\n   * The settings panel whose visibility the button should toggle.\n   */\n  settingsPanel: SettingsPanel;\n\n  /**\n   * Decides if the button should be automatically hidden when the settings panel does not contain any active settings.\n   * Default: true\n   */\n  autoHideWhenNoActiveSettings?: boolean;\n}\n\n/**\n * A button that toggles visibility of a settings panel.\n */\nexport class SettingsToggleButton extends ToggleButton<SettingsToggleButtonConfig> {\n\n  constructor(config: SettingsToggleButtonConfig) {\n    super(config);\n\n    if (!config.settingsPanel) {\n      throw new Error('Required SettingsPanel is missing');\n    }\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settingstogglebutton',\n      text: 'Settings',\n      settingsPanel: null,\n      autoHideWhenNoActiveSettings: true,\n    }, <SettingsToggleButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsToggleButtonConfig>this.getConfig(); // TODO fix generics type inference\n    let settingsPanel = config.settingsPanel;\n\n    this.onClick.subscribe(() => {\n      settingsPanel.toggleHidden();\n    });\n    settingsPanel.onShow.subscribe(() => {\n      // Set toggle status to on when the settings panel shows\n      this.on();\n    });\n    settingsPanel.onHide.subscribe(() => {\n      // Set toggle status to off when the settings panel hides\n      this.off();\n    });\n\n    // Handle automatic hiding of the button if there are no settings for the user to interact with\n    if (config.autoHideWhenNoActiveSettings) {\n      // Setup handler to show/hide button when the settings change\n      let settingsPanelItemsChangedHandler = () => {\n        if (settingsPanel.hasActiveSettings()) {\n          if (this.isHidden()) {\n            this.show();\n          }\n        } else {\n          if (this.isShown()) {\n            this.hide();\n          }\n        }\n      };\n      // Wire the handler to the event\n      settingsPanel.onSettingsStateChanged.subscribe(settingsPanelItemsChangedHandler);\n      // Call handler for first init at startup\n      settingsPanelItemsChangedHandler();\n    }\n  }\n}","import {Component, ComponentConfig} from './component';\n\n/**\n * A dummy component that just reserves some space and does nothing else.\n */\nexport class Spacer extends Component<ComponentConfig> {\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-spacer',\n    }, this.config);\n  }\n\n\n  protected onShowEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHideEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHoverChangedEvent(hovered: boolean): void {\n    // disable event firing by overwriting and not calling super\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleCueEvent = bitmovin.PlayerAPI.SubtitleCueEvent;\nimport {Label, LabelConfig} from './label';\nimport {ComponentConfig, Component} from './component';\nimport {ControlBar} from './controlbar';\nimport { EventDispatcher } from '../eventdispatcher';\n\n/**\n * Overlays the player to display subtitles.\n */\nexport class SubtitleOverlay extends Container<ContainerConfig> {\n\n  private subtitleManager: ActiveSubtitleManager;\n  private previewSubtitleActive: boolean;\n  private previewSubtitle: SubtitleLabel;\n\n  private preprocessLabelEventCallback = new EventDispatcher<SubtitleCueEvent, SubtitleLabel>();\n\n  private static readonly CLASS_CONTROLBAR_VISIBLE = 'controlbar-visible';\n  private static readonly CLASS_CEA_608 = 'cea608';\n  // The number of rows in a cea608 grid\n  private static readonly CEA608_NUM_ROWS = 15;\n  // The number of columns in a cea608 grid\n  private static readonly CEA608_NUM_COLUMNS = 32;\n  // The offset in percent for one row (which is also the height of a row)\n  private static readonly CEA608_ROW_OFFSET = 100 / SubtitleOverlay.CEA608_NUM_ROWS;\n  // The offset in percent for one column (which is also the width of a column)\n  private static readonly CEA608_COLUMN_OFFSET = 100 / SubtitleOverlay.CEA608_NUM_COLUMNS;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.previewSubtitleActive = false;\n    this.previewSubtitle = new SubtitleLabel({ text: 'example subtitle' });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-overlay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let subtitleManager = new ActiveSubtitleManager();\n    this.subtitleManager = subtitleManager;\n\n    player.addEventHandler(player.EVENT.ON_CUE_ENTER, (event: SubtitleCueEvent) => {\n      // Sanitize cue data (must be done before the cue ID is generated in subtitleManager.cueEnter)\n      if (event.position) {\n        // Sometimes the positions are undefined, we assume them to be zero\n        event.position.row = event.position.row || 0;\n        event.position.column = event.position.column || 0;\n      }\n\n      let labelToAdd = subtitleManager.cueEnter(event);\n\n      this.preprocessLabelEventCallback.dispatch(event, labelToAdd);\n\n      if (this.previewSubtitleActive) {\n        this.removeComponent(this.previewSubtitle);\n      }\n      this.addComponent(labelToAdd);\n      this.updateComponents();\n\n      this.show();\n    });\n    player.addEventHandler(player.EVENT.ON_CUE_EXIT, (event: SubtitleCueEvent) => {\n      let labelToRemove = subtitleManager.cueExit(event);\n\n      if (labelToRemove) {\n        this.removeComponent(labelToRemove);\n        this.updateComponents();\n      }\n\n      if (!subtitleManager.hasCues) {\n        if (!this.previewSubtitleActive) {\n          this.hide();\n        } else {\n          this.addComponent(this.previewSubtitle);\n          this.updateComponents();\n        }\n      }\n    });\n\n    let subtitleClearHandler = () => {\n      this.hide();\n      subtitleManager.clear();\n      this.removeComponents();\n      this.updateComponents();\n    };\n\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SEEK, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, subtitleClearHandler);\n\n    uimanager.onComponentShow.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().addClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n    uimanager.onComponentHide.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().removeClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n\n    this.configureCea608Captions(player, uimanager);\n    // Init\n    subtitleClearHandler();\n  }\n\n  configureCea608Captions(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    // The calculated font size\n    let fontSize = 0;\n    // The required letter spacing spread the text characters evenly across the grid\n    let fontLetterSpacing = 0;\n    // Flag telling if a font size calculation is required of if the current values are valid\n    let fontSizeCalculationRequired = true;\n    // Flag telling if the CEA-608 mode is enabled\n    let enabled = false;\n\n    const updateCEA608FontSize = () => {\n      const dummyLabel = new SubtitleLabel({ text: 'X' });\n      dummyLabel.getDomElement().css({\n        // By using a large font size we do not need to use multiple letters and can get still an\n        // accurate measurement even though the returned size is an integer value\n        'font-size': '200px',\n        'line-height': '200px',\n        'visibility': 'hidden',\n      });\n      this.addComponent(dummyLabel);\n      this.updateComponents();\n      this.show();\n\n      const dummyLabelCharWidth = dummyLabel.getDomElement().width();\n      const dummyLabelCharHeight = dummyLabel.getDomElement().height();\n      const fontSizeRatio = dummyLabelCharWidth / dummyLabelCharHeight;\n\n      this.removeComponent(dummyLabel);\n      this.updateComponents();\n      if (!this.subtitleManager.hasCues) {\n        this.hide();\n      }\n\n      // We subtract 1px here to avoid line breaks at the right border of the subtitle overlay that can happen\n      // when texts contain whitespaces. It's probably some kind of pixel rounding issue in the browser's\n      // layouting, but the actual reason could not be determined. Aiming for a target width - 1px would work in\n      // most browsers, but Safari has a \"quantized\" font size rendering with huge steps in between so we need\n      // to subtract some more pixels to avoid line breaks there as well.\n      const subtitleOverlayWidth = this.getDomElement().width() - 10;\n      const subtitleOverlayHeight = this.getDomElement().height();\n\n      // The size ratio of the letter grid\n      const fontGridSizeRatio = (dummyLabelCharWidth * SubtitleOverlay.CEA608_NUM_COLUMNS) /\n        (dummyLabelCharHeight * SubtitleOverlay.CEA608_NUM_ROWS);\n      // The size ratio of the available space for the grid\n      const subtitleOverlaySizeRatio = subtitleOverlayWidth / subtitleOverlayHeight;\n\n      if (subtitleOverlaySizeRatio > fontGridSizeRatio) {\n        // When the available space is wider than the text grid, the font size is simply\n        // determined by the height of the available space.\n        fontSize = subtitleOverlayHeight / SubtitleOverlay.CEA608_NUM_ROWS;\n\n        // Calculate the additional letter spacing required to evenly spread the text across the grid's width\n        const gridSlotWidth = subtitleOverlayWidth / SubtitleOverlay.CEA608_NUM_COLUMNS;\n        const fontCharWidth = fontSize * fontSizeRatio;\n        fontLetterSpacing = gridSlotWidth - fontCharWidth;\n      } else {\n        // When the available space is not wide enough, texts would vertically overlap if we take\n        // the height as a base for the font size, so we need to limit the height. We do that\n        // by determining the font size by the width of the available space.\n        fontSize = subtitleOverlayWidth / SubtitleOverlay.CEA608_NUM_COLUMNS / fontSizeRatio;\n        fontLetterSpacing = 0;\n      }\n\n      // Update font-size of all active subtitle labels\n      for (let label of this.getComponents()) {\n        if (label instanceof SubtitleLabel) {\n          label.getDomElement().css({\n            'font-size': `${fontSize}px`,\n            'letter-spacing': `${fontLetterSpacing}px`,\n          });\n        }\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      if (enabled) {\n        updateCEA608FontSize();\n      } else {\n        fontSizeCalculationRequired = true;\n      }\n    });\n\n    this.preprocessLabelEventCallback.subscribe((event: SubtitleCueEvent, label: SubtitleLabel) => {\n      const isCEA608 = event.position != null;\n      if (!isCEA608) {\n        // Skip all non-CEA608 cues\n        return;\n      }\n\n      if (!enabled) {\n        enabled = true;\n        this.getDomElement().addClass(this.prefixCss(SubtitleOverlay.CLASS_CEA_608));\n\n        // We conditionally update the font size by this flag here to avoid updating every time a subtitle\n        // is added into an empty overlay. Because we reset the overlay when all subtitles are gone, this\n        // would trigger an unnecessary update every time, but it's only required under certain conditions,\n        // e.g. after the player size has changed.\n        if (fontSizeCalculationRequired) {\n          updateCEA608FontSize();\n          fontSizeCalculationRequired = false;\n        }\n      }\n\n      label.getDomElement().css({\n        'left': `${event.position.column * SubtitleOverlay.CEA608_COLUMN_OFFSET}%`,\n        'top': `${event.position.row * SubtitleOverlay.CEA608_ROW_OFFSET}%`,\n        'font-size': `${fontSize}px`,\n        'letter-spacing': `${fontLetterSpacing}px`,\n      });\n    });\n\n    const reset = () => {\n      this.getDomElement().removeClass(this.prefixCss(SubtitleOverlay.CLASS_CEA_608));\n      enabled = false;\n    };\n\n    player.addEventHandler(player.EVENT.ON_CUE_EXIT, () => {\n      if (!this.subtitleManager.hasCues) {\n        // Disable CEA-608 mode when all subtitles are gone (to allow correct formatting and\n        // display of other types of subtitles, e.g. the formatting preview subtitle)\n        reset();\n      }\n    });\n\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, reset);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, reset);\n  }\n\n  enablePreviewSubtitleLabel(): void {\n    this.previewSubtitleActive = true;\n    if (!this.subtitleManager.hasCues) {\n      this.addComponent(this.previewSubtitle);\n      this.updateComponents();\n      this.show();\n    }\n  }\n\n  removePreviewSubtitleLabel(): void {\n    this.previewSubtitleActive = false;\n    this.removeComponent(this.previewSubtitle);\n    this.updateComponents();\n  }\n}\n\ninterface ActiveSubtitleCue {\n  event: SubtitleCueEvent;\n  label: SubtitleLabel;\n}\n\ninterface ActiveSubtitleCueMap {\n  [id: string]: ActiveSubtitleCue[];\n}\n\nclass SubtitleLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-label',\n    }, this.config);\n  }\n}\n\nclass ActiveSubtitleManager {\n\n  private activeSubtitleCueMap: ActiveSubtitleCueMap;\n  private activeSubtitleCueCount: number;\n\n  constructor() {\n    this.activeSubtitleCueMap = {};\n    this.activeSubtitleCueCount = 0;\n  }\n\n  /**\n   * Calculates a unique ID for a subtitle cue, which is needed to associate an ON_CUE_ENTER with its ON_CUE_EXIT\n   * event so we can remove the correct subtitle in ON_CUE_EXIT when multiple subtitles are active at the same time.\n   * The start time plus the text should make a unique identifier, and in the only case where a collision\n   * can happen, two similar texts will be displayed at a similar time and a similar position (or without position).\n   * The start time should always be known, because it is required to schedule the ON_CUE_ENTER event. The end time\n   * must not necessarily be known and therefore cannot be used for the ID.\n   * @param event\n   * @return {string}\n   */\n  private static calculateId(event: SubtitleCueEvent): string {\n    let id = event.start + '-' + event.text;\n\n    if (event.position) {\n      id += '-' + event.position.row + '-' + event.position.column;\n    }\n\n    return id;\n  }\n\n  /**\n   * Adds a subtitle cue to the manager and returns the label that should be added to the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueEnter(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n\n    let label = new SubtitleLabel({\n      // Prefer the HTML subtitle text if set, else use the plain text\n      text: event.html || event.text,\n    });\n\n    // Create array for id if it does not exist\n    this.activeSubtitleCueMap[id] = this.activeSubtitleCueMap[id] || [];\n\n    // Add cue\n    this.activeSubtitleCueMap[id].push({ event, label });\n    this.activeSubtitleCueCount++;\n\n    return label;\n  }\n\n  /**\n   * Returns the label associated with an already added cue.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  getCues(event: SubtitleCueEvent): SubtitleLabel[] {\n    let id = ActiveSubtitleManager.calculateId(event);\n    let activeSubtitleCues = this.activeSubtitleCueMap[id];\n    if (activeSubtitleCues && activeSubtitleCues.length > 0) {\n      return activeSubtitleCues.map((cue) => cue.label);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Removes the subtitle cue from the manager and returns the label that should be removed from the subtitle overlay,\n   * or null if there is no associated label existing (e.g. because all labels have been {@link #clear cleared}.\n   * @param event\n   * @return {SubtitleLabel|null}\n   */\n  cueExit(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n    let activeSubtitleCues = this.activeSubtitleCueMap[id];\n\n    if (activeSubtitleCues && activeSubtitleCues.length > 0) {\n      // Remove cue\n      /* We apply the FIFO approach here and remove the oldest cue from the associated id. When there are multiple cues\n       * with the same id, there is no way to know which one of the cues is to be deleted, so we just hope that FIFO\n       * works fine. Theoretically it can happen that two cues with colliding ids are removed at different times, in\n       * the wrong order. This rare case has yet to be observed. If it ever gets an issue, we can take the unstable\n       * cue end time (which can change between ON_CUE_ENTER and ON_CUE_EXIT IN ON_CUE_UPDATE) and use it as an\n       * additional hint to try and remove the correct one of the colliding cues.\n       */\n      let activeSubtitleCue = activeSubtitleCues.shift();\n      this.activeSubtitleCueCount--;\n\n      return activeSubtitleCue.label;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns the number of active subtitle cues.\n   * @return {number}\n   */\n  get cueCount(): number {\n    // We explicitly count the cues to save an Array.reduce on every cueCount call (which can happen frequently)\n    return this.activeSubtitleCueCount;\n  }\n\n  /**\n   * Returns true if there are active subtitle cues, else false.\n   * @return {boolean}\n   */\n  get hasCues(): boolean {\n    return this.cueCount > 0;\n  }\n\n  /**\n   * Removes all subtitle cues from the manager.\n   */\n  clear(): void {\n    this.activeSubtitleCueMap = {};\n    this.activeSubtitleCueCount = 0;\n  }\n}\n","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between available subtitle and caption tracks.\n */\nexport class SubtitleSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let selectCurrentSubtitle = () => {\n      let currentSubtitle = player.getSubtitle();\n\n      if (currentSubtitle) {\n        this.selectItem(currentSubtitle.id);\n      }\n    };\n\n    let updateSubtitles = () => {\n      this.clearItems();\n\n      for (let subtitle of player.getAvailableSubtitles()) {\n        this.addItem(subtitle.id, subtitle.label);\n      }\n\n      // Select the correct subtitle after the subtitles have been added\n      selectCurrentSubtitle();\n    };\n\n    this.onItemSelected.subscribe((sender: SubtitleSelectBox, value: string) => {\n      player.setSubtitle(value === 'null' ? null : value);\n    });\n\n    // React to API events\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_ADDED, updateSubtitles);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, selectCurrentSubtitle);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_REMOVED, updateSubtitles);\n    // Update subtitles when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateSubtitles);\n    // Update subtitles when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateSubtitles);\n    // Update subtitles when the period within a source changes\n    player.addEventHandler(player.EVENT.ON_PERIOD_SWITCHED, updateSubtitles);\n\n    // Populate subtitles at startup\n    updateSubtitles();\n  }\n}","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different background colors.\n */\nexport class BackgroundColorSelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('white', 'white');\n    this.addItem('black', 'black');\n    this.addItem('red', 'red');\n    this.addItem('green', 'green');\n    this.addItem('blue', 'blue');\n    this.addItem('cyan', 'cyan');\n    this.addItem('yellow', 'yellow');\n    this.addItem('magenta', 'magenta');\n\n    let setColorAndOpacity = () => {\n      if (this.settingsManager.backgroundColor.isSet() && this.settingsManager.backgroundOpacity.isSet()) {\n        this.toggleOverlayClass(\n          'bgcolor-' + this.settingsManager.backgroundColor.value + this.settingsManager.backgroundOpacity.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.backgroundColor.value = key;\n    });\n\n    this.settingsManager.backgroundColor.onChanged.subscribe((sender, property) => {\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.backgroundColor.isSet()) {\n        // ... clear the opacity when the color is not set\n        this.settingsManager.backgroundOpacity.clear();\n      } else if (!this.settingsManager.backgroundOpacity.isSet()) {\n        // ... set an opacity when the color is set\n        this.settingsManager.backgroundOpacity.value = '100';\n      }\n      this.selectItem(property.value);\n      setColorAndOpacity();\n    });\n\n    this.settingsManager.backgroundOpacity.onChanged.subscribe(() => {\n      setColorAndOpacity();\n    });\n\n    // Load initial value\n    if (this.settingsManager.backgroundColor.isSet()) {\n      this.selectItem(this.settingsManager.backgroundColor.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different background opacity.\n */\nexport class BackgroundOpacitySelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('100', '100%');\n    this.addItem('75', '75%');\n    this.addItem('50', '50%');\n    this.addItem('25', '25%');\n    this.addItem('0', '0%');\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.backgroundOpacity.value = key;\n\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.backgroundOpacity.isSet()) {\n        // ... clear the color when the opacity is not set\n        this.settingsManager.backgroundColor.clear();\n      } else if (!this.settingsManager.backgroundColor.isSet()) {\n        // ... set a color when the opacity is set\n        this.settingsManager.backgroundColor.value = 'black';\n      }\n    });\n\n    // Update selected item when value is set from somewhere else\n    this.settingsManager.backgroundOpacity.onChanged.subscribe((sender, property) => {\n      this.selectItem(property.value);\n    });\n\n    // Load initial value\n    if (this.settingsManager.backgroundOpacity.isSet()) {\n      this.selectItem(this.settingsManager.backgroundOpacity.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different character edge.\n */\nexport class CharacterEdgeSelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('raised', 'raised');\n    this.addItem('depressed', 'depressed');\n    this.addItem('uniform', 'uniform');\n    this.addItem('dropshadowed', 'drop shadowed');\n\n    this.settingsManager.characterEdge.onChanged.subscribe((sender, property) => {\n      if (property.isSet()) {\n        this.toggleOverlayClass('characteredge-' + property.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n\n      // Select the item in case the property was set from outside\n      this.selectItem(property.value);\n    });\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.characterEdge.value = key;\n    });\n\n    // Load initial value\n    if (this.settingsManager.characterEdge.isSet()) {\n      this.selectItem(this.settingsManager.characterEdge.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different font colors.\n */\nexport class FontColorSelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('white', 'white');\n    this.addItem('black', 'black');\n    this.addItem('red', 'red');\n    this.addItem('green', 'green');\n    this.addItem('blue', 'blue');\n    this.addItem('cyan', 'cyan');\n    this.addItem('yellow', 'yellow');\n    this.addItem('magenta', 'magenta');\n\n    let setColorAndOpacity = () => {\n      if (this.settingsManager.fontColor.isSet() && this.settingsManager.fontOpacity.isSet()) {\n        this.toggleOverlayClass(\n          'fontcolor-' + this.settingsManager.fontColor.value + this.settingsManager.fontOpacity.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.fontColor.value = key;\n    });\n\n    this.settingsManager.fontColor.onChanged.subscribe((sender, property) => {\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.fontColor.isSet()) {\n        // ... clear the opacity when the color is not set\n        this.settingsManager.fontOpacity.clear();\n      } else if (!this.settingsManager.fontOpacity.isSet()) {\n        // ... set an opacity when the color is set\n        this.settingsManager.fontOpacity.value = '100';\n      }\n      this.selectItem(property.value);\n      setColorAndOpacity();\n    });\n\n    this.settingsManager.fontOpacity.onChanged.subscribe(() => {\n      setColorAndOpacity();\n    });\n\n    // Load initial value\n    if (this.settingsManager.fontColor.isSet()) {\n      this.selectItem(this.settingsManager.fontColor.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different font family.\n */\nexport class FontFamilySelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('monospacedserif', 'monospaced serif');\n    this.addItem('proportionalserif', 'proportional serif');\n    this.addItem('monospacedsansserif', 'monospaced sans serif');\n    this.addItem('proportionalsansserif', 'proportional sans serif');\n    this.addItem('casual', 'casual');\n    this.addItem('cursive', 'cursive');\n    this.addItem('smallcapital', 'small capital');\n\n    this.settingsManager.fontFamily.onChanged.subscribe((sender, property) => {\n      if (property.isSet()) {\n        this.toggleOverlayClass('fontfamily-' + property.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n\n      // Select the item in case the property was set from outside\n      this.selectItem(property.value);\n    });\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.fontFamily.value = key;\n    });\n\n    // Load initial value\n    if (this.settingsManager.fontFamily.isSet()) {\n      this.selectItem(this.settingsManager.fontFamily.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different font colors.\n */\nexport class FontOpacitySelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('100', '100%');\n    this.addItem('75', '75%');\n    this.addItem('50', '50%');\n    this.addItem('25', '25%');\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.fontOpacity.value = key;\n\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.fontOpacity.isSet()) {\n        // ... clear the color when the opacity is not set\n        this.settingsManager.fontColor.clear();\n      } else if (!this.settingsManager.fontColor.isSet()) {\n        // ... set a color when the opacity is set\n        this.settingsManager.fontColor.value = 'white';\n      }\n    });\n\n    // Update selected item when value is set from somewhere else\n    this.settingsManager.fontOpacity.onChanged.subscribe((sender, property) => {\n      this.selectItem(property.value);\n    });\n\n    // Load initial value\n    if (this.settingsManager.fontOpacity.isSet()) {\n      this.selectItem(this.settingsManager.fontOpacity.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different font colors.\n */\nexport class FontSizeSelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('50', '50%');\n    this.addItem('75', '75%');\n    this.addItem('100', '100%');\n    this.addItem('150', '150%');\n    this.addItem('200', '200%');\n    this.addItem('300', '300%');\n    this.addItem('400', '400%');\n\n    this.settingsManager.fontSize.onChanged.subscribe((sender, property) => {\n      if (property.isSet()) {\n        this.toggleOverlayClass('fontsize-' + property.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n\n      // Select the item in case the property was set from outside\n      this.selectItem(property.value);\n    });\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.fontSize.value = key;\n    });\n\n    // Load initial value\n    if (this.settingsManager.fontSize.isSet()) {\n      this.selectItem(this.settingsManager.fontSize.value);\n    }\n  }\n}\n","import {Button, ButtonConfig} from '../button';\nimport {SettingsPanel} from '../settingspanel';\nimport {SubtitleSettingsPanel} from './subtitlesettingspanel';\n\nexport interface SubtitleSettingsButtonConfig extends ButtonConfig {\n  subtitleSettingsPanel: SubtitleSettingsPanel;\n  settingsPanel: SettingsPanel;\n}\n\nexport class SubtitleSettingsButton extends Button<ButtonConfig> {\n\n  protected subtitleSettingsPanel: SubtitleSettingsPanel;\n  protected settingsPanel: SettingsPanel;\n\n  constructor(config: SubtitleSettingsButtonConfig) {\n    super(config);\n\n    this.subtitleSettingsPanel = config.subtitleSettingsPanel;\n    this.settingsPanel = config.settingsPanel;\n  }\n}\n","import {SubtitleSettingsButton} from './subtitlesettingsbutton';\nimport {SubtitleSettingsButtonConfig} from './subtitlesettingsbutton';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A button that toggles the option menu for subtitles\n */\nexport class SubtitleSettingsCloseButton extends SubtitleSettingsButton {\n\n  constructor(config: SubtitleSettingsButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitlesettingsclosebutton',\n      text: 'Back',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      this.subtitleSettingsPanel.hide();\n      this.settingsPanel.show();\n    });\n  }\n}\n","import {SubtitleOverlay} from '../subtitleoverlay';\nimport {ListSelectorConfig} from '../listselector';\nimport {SelectBox} from '../selectbox';\nimport {SubtitleSettingsManager} from './subtitlesettingsmanager';\n\nexport interface SubtitleSettingSelectBoxConfig extends ListSelectorConfig {\n  overlay: SubtitleOverlay;\n  settingsManager: SubtitleSettingsManager;\n}\n\n/**\n * Base class for all subtitles settings select box\n **/\nexport class SubtitleSettingSelectBox extends SelectBox {\n\n  protected settingsManager: SubtitleSettingsManager;\n  protected overlay: SubtitleOverlay;\n  private currentCssClass: string;\n\n  constructor(config: SubtitleSettingSelectBoxConfig) {\n    super(config);\n\n    this.settingsManager = config.settingsManager;\n    this.overlay = config.overlay;\n  }\n\n  /**\n   * Removes a previously set class and adds the passed in class.\n   * @param cssClass The new class to replace the previous class with or null to just remove the previous class\n   */\n  protected toggleOverlayClass(cssClass: string): void {\n    // Remove previous class if existing\n    if (this.currentCssClass) {\n      this.overlay.getDomElement().removeClass(this.currentCssClass);\n      this.currentCssClass = null;\n    }\n\n    // Add new class if specified. If the new class is null, we don't add anything.\n    if (cssClass) {\n      this.currentCssClass = this.prefixCss(cssClass);\n      this.overlay.getDomElement().addClass(this.currentCssClass);\n    }\n  }\n}\n","import {LabelConfig} from '../label';\nimport {Container, ContainerConfig} from '../container';\nimport {SubtitleSettingsOpenButton} from './subtitlesettingsopenbutton';\nimport {DOM} from '../../dom';\n\nexport interface SubtitleSettingsLabelConfig extends LabelConfig {\n  opener: SubtitleSettingsOpenButton;\n}\n\nexport class SubtitleSettingsLabel extends Container<ContainerConfig> {\n\n  private opener: SubtitleSettingsOpenButton;\n\n  private text: string;\n\n  constructor(config: SubtitleSettingsLabelConfig) {\n    super(config);\n\n    this.opener = config.opener;\n    this.text = config.text;\n\n    this.config = this.mergeConfig(<ContainerConfig>config, {\n      cssClass: 'ui-label',\n      components: [\n        this.opener,\n      ],\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let labelElement = new DOM('span', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    }).append(\n      new DOM('span', {}).html(this.text),\n      this.opener.getDomElement()\n    );\n\n    return labelElement;\n  }\n}\n","import {StorageUtils} from '../../storageutils';\nimport {Component, ComponentConfig} from '../component';\nimport {EventDispatcher, Event} from '../../eventdispatcher';\n\ninterface SubtitleSettings {\n  fontColor?: string;\n  fontOpacity?: string;\n  fontFamily?: string;\n  fontSize?: string;\n  characterEdge?: string;\n  backgroundColor?: string;\n  backgroundOpacity?: string;\n  windowColor?: string;\n  windowOpacity?: string;\n}\n\ninterface Properties {\n  [name: string]: SubtitleSettingsProperty<string>;\n}\n\nexport class SubtitleSettingsManager {\n\n  private userSettings: SubtitleSettings;\n  private localStorageKey: string;\n\n  private _properties: Properties = {\n    fontColor: new SubtitleSettingsProperty<string>(this),\n    fontOpacity: new SubtitleSettingsProperty<string>(this),\n    fontFamily: new SubtitleSettingsProperty<string>(this),\n    fontSize: new SubtitleSettingsProperty<string>(this),\n    characterEdge: new SubtitleSettingsProperty<string>(this),\n    backgroundColor: new SubtitleSettingsProperty<string>(this),\n    backgroundOpacity: new SubtitleSettingsProperty<string>(this),\n    windowColor: new SubtitleSettingsProperty<string>(this),\n    windowOpacity: new SubtitleSettingsProperty<string>(this),\n  };\n\n  constructor() {\n    this.userSettings = {};\n    this.localStorageKey = DummyComponent.instance().prefixCss('subtitlesettings');\n\n    for (let propertyName in this._properties) {\n      this._properties[propertyName].onChanged.subscribe((sender, property) => {\n        if (property.isSet()) {\n          (<any>this.userSettings)[propertyName] = property.value;\n        } else {\n          // Delete the property from the settings object if unset to avoid serialization of null values\n          delete (<any>this.userSettings)[propertyName];\n        }\n\n        // Save the settings object when a property has changed\n        this.save();\n      });\n    }\n\n    this.load();\n  }\n\n  public reset(): void {\n    for (let propertyName in this._properties) {\n      this._properties[propertyName].clear();\n    }\n  }\n\n  public get fontColor(): SubtitleSettingsProperty<string> {\n    return this._properties.fontColor;\n  }\n\n  public get fontOpacity(): SubtitleSettingsProperty<string> {\n    return this._properties.fontOpacity;\n  }\n\n  public get fontFamily(): SubtitleSettingsProperty<string> {\n    return this._properties.fontFamily;\n  }\n\n  public get fontSize(): SubtitleSettingsProperty<string> {\n    return this._properties.fontSize;\n  }\n\n  public get characterEdge(): SubtitleSettingsProperty<string> {\n    return this._properties.characterEdge;\n  }\n\n  public get backgroundColor(): SubtitleSettingsProperty<string> {\n    return this._properties.backgroundColor;\n  }\n\n  public get backgroundOpacity(): SubtitleSettingsProperty<string> {\n    return this._properties.backgroundOpacity;\n  }\n\n  public get windowColor(): SubtitleSettingsProperty<string> {\n    return this._properties.windowColor;\n  }\n\n  public get windowOpacity(): SubtitleSettingsProperty<string> {\n    return this._properties.windowOpacity;\n  }\n\n  /**\n   * Saves the settings to local storage.\n   */\n  public save(): void {\n    StorageUtils.setObject(this.localStorageKey, this.userSettings);\n  }\n\n  /**\n   * Loads the settings from local storage\n   */\n  public load(): void {\n    this.userSettings = StorageUtils.getObject<SubtitleSettings>(this.localStorageKey) || {};\n\n    // Apply the loaded settings\n    for (let property in this.userSettings) {\n      this._properties[property].value = (<any>this.userSettings)[property];\n    }\n  }\n}\n\n/**\n * A dummy component whose sole purpose is to expose the {@link #prefixCss} method to the\n * {@link SubtitleSettingsManager}.\n */\nclass DummyComponent extends Component<ComponentConfig> {\n\n  private static _instance: DummyComponent;\n\n  public static instance(): DummyComponent {\n    if (!DummyComponent._instance) {\n      DummyComponent._instance = new DummyComponent();\n    }\n\n    return DummyComponent._instance;\n  }\n\n  public prefixCss(cssClassOrId: string): string {\n    return super.prefixCss(cssClassOrId);\n  }\n}\n\nexport class SubtitleSettingsProperty<T> {\n\n  private _manager: SubtitleSettingsManager;\n  private _onChanged: EventDispatcher<SubtitleSettingsManager, SubtitleSettingsProperty<T>>;\n  private _value: T;\n\n  constructor(manager: SubtitleSettingsManager) {\n    this._manager = manager;\n    this._onChanged = new EventDispatcher<SubtitleSettingsManager, SubtitleSettingsProperty<T>>();\n  }\n\n  public isSet(): boolean {\n    return this._value != null;\n  }\n\n  public clear(): void {\n    this._value = null;\n    this.onChangedEvent(null);\n  }\n\n  public get value(): T {\n    return this._value;\n  }\n\n  public set value(value: T) {\n    if (typeof value === 'string' && value === 'null') {\n      value = null;\n    }\n\n    this._value = value;\n    this.onChangedEvent(value);\n  }\n\n  protected onChangedEvent(value: T) {\n    this._onChanged.dispatch(this._manager, this);\n  }\n\n  public get onChanged(): Event<SubtitleSettingsManager, SubtitleSettingsProperty<T>> {\n    return this._onChanged.getEvent();\n  }\n}","import {SubtitleSettingsButton} from './subtitlesettingsbutton';\nimport {SubtitleSettingsButtonConfig} from './subtitlesettingsbutton';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A button that toggles the option menu for subtitles\n */\nexport class SubtitleSettingsOpenButton extends SubtitleSettingsButton {\n\n  constructor(config: SubtitleSettingsButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitlesettingsopenbutton',\n      text: 'Subtitles settings',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      this.subtitleSettingsPanel.show();\n      this.settingsPanel.hide();\n    });\n  }\n}\n\n","import {SettingsPanel, SettingsPanelConfig, SettingsPanelItem} from '../settingspanel';\nimport {FontColorSelectBox} from './fontcolorselectbox';\nimport {FontOpacitySelectBox} from './fontopacityselectbox';\nimport {FontFamilySelectBox} from './fontfamilyselectbox';\nimport {FontSizeSelectBox} from './fontsizeselectbox';\nimport {BackgroundColorSelectBox} from './backgroundcolorselectbox';\nimport {BackgroundOpacitySelectBox} from './backgroundopacityselectbox';\nimport {WindowColorSelectBox} from './windowcolorselectbox';\nimport {WindowOpacitySelectBox} from './windowopacityselectbox';\nimport {CharacterEdgeSelectBox} from './characteredgeselectbox';\nimport {SubtitleOverlay} from '../subtitleoverlay';\nimport {Component, ComponentConfig} from '../component';\nimport {UIInstanceManager} from '../../uimanager';\nimport {SubtitleSettingsManager} from './subtitlesettingsmanager';\nimport {SubtitleSettingsCloseButton} from './subtitlesettingsclosebutton';\nimport {SubtitleSettingsResetButton} from './subtitlesettingsresetbutton';\n\nexport interface SubtitleSettingsPanelConfig extends SettingsPanelConfig {\n  overlay: SubtitleOverlay;\n  settingsPanel: SettingsPanel;\n}\n\n/**\n * SubtitleSettingsPanel is a settings panel specific to subtitles settings\n **/\nexport class SubtitleSettingsPanel extends SettingsPanel {\n\n  private overlay: SubtitleOverlay;\n\n  constructor(config: SubtitleSettingsPanelConfig) {\n    super(config);\n\n    this.overlay = config.overlay;\n\n    let manager = new SubtitleSettingsManager();\n\n    this.config = this.mergeConfig(config, {\n      components: <Component<ComponentConfig>[]>[\n        new SettingsPanelItem('Font size', new FontSizeSelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Font family', new FontFamilySelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Font color', new FontColorSelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Font opacity', new FontOpacitySelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Character edge', new CharacterEdgeSelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Background color', new BackgroundColorSelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Background opacity', new BackgroundOpacitySelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Window color', new WindowColorSelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Window opacity', new WindowOpacitySelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem(new SubtitleSettingsCloseButton({\n          subtitleSettingsPanel: this, settingsPanel: config.settingsPanel,\n        }), new SubtitleSettingsResetButton({\n          settingsManager: manager,\n        })),\n      ],\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onShow.subscribe(() => {\n      this.overlay.enablePreviewSubtitleLabel();\n    });\n\n    this.onHide.subscribe(() => {\n      this.overlay.removePreviewSubtitleLabel();\n    });\n  }\n}\n","import {UIInstanceManager} from '../../uimanager';\nimport {SubtitleSettingsManager} from './subtitlesettingsmanager';\nimport {Button, ButtonConfig} from '../button';\n\nexport interface SubtitleSettingsResetButtonConfig extends ButtonConfig {\n  settingsManager: SubtitleSettingsManager;\n}\n\n/**\n * A button that resets all subtitle settings to their defaults.\n */\nexport class SubtitleSettingsResetButton extends Button<ButtonConfig> {\n\n  constructor(config: SubtitleSettingsResetButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitlesettingsresetbutton',\n      text: 'Reset',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      (<SubtitleSettingsResetButtonConfig>this.config).settingsManager.reset();\n    });\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different background colors.\n */\nexport class WindowColorSelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('white', 'white');\n    this.addItem('black', 'black');\n    this.addItem('red', 'red');\n    this.addItem('green', 'green');\n    this.addItem('blue', 'blue');\n    this.addItem('cyan', 'cyan');\n    this.addItem('yellow', 'yellow');\n    this.addItem('magenta', 'magenta');\n\n    let setColorAndOpacity = () => {\n      if (this.settingsManager.windowColor.isSet() && this.settingsManager.windowOpacity.isSet()) {\n        this.toggleOverlayClass(\n          'windowcolor-' + this.settingsManager.windowColor.value + this.settingsManager.windowOpacity.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.windowColor.value = key;\n    });\n\n    this.settingsManager.windowColor.onChanged.subscribe((sender, property) => {\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.windowColor.isSet()) {\n        // ... clear the opacity when the color is not set\n        this.settingsManager.windowOpacity.clear();\n      } else if (!this.settingsManager.windowOpacity.isSet()) {\n        // ... set an opacity when the color is set\n        this.settingsManager.windowOpacity.value = '100';\n      }\n      this.selectItem(property.value);\n      setColorAndOpacity();\n    });\n\n    this.settingsManager.windowOpacity.onChanged.subscribe(() => {\n      setColorAndOpacity();\n    });\n\n    // Load initial value\n    if (this.settingsManager.windowColor.isSet()) {\n      this.selectItem(this.settingsManager.windowColor.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different background opacity.\n */\nexport class WindowOpacitySelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('100', '100%');\n    this.addItem('75', '75%');\n    this.addItem('50', '50%');\n    this.addItem('25', '25%');\n    this.addItem('0', '0%');\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.windowOpacity.value = key;\n\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.windowOpacity.isSet()) {\n        // ... clear the color when the opacity is not set\n        this.settingsManager.windowColor.clear();\n      } else if (!this.settingsManager.windowColor.isSet()) {\n        // ... set a color when the opacity is set\n        this.settingsManager.windowColor.value = 'black';\n      }\n    });\n\n    // Update selected item when value is set from somewhere else\n    this.settingsManager.windowOpacity.onChanged.subscribe((sender, property) => {\n      this.selectItem(property.value);\n    });\n\n    // Load initial value\n    if (this.settingsManager.windowOpacity.isSet()) {\n      this.selectItem(this.settingsManager.windowOpacity.value);\n    }\n  }\n}\n","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {MetadataLabel, MetadataLabelContent} from './metadatalabel';\n\n/**\n * Configuration interface for a {@link TitleBar}.\n */\nexport interface TitleBarConfig extends ContainerConfig {\n  /**\n   * Specifies if the title bar should stay hidden when no metadata label contains any text. Does not make a lot\n   * of sense if the title bar contains other components than just MetadataLabels (like in the default configuration).\n   * Default: false\n   */\n  keepHiddenWithoutMetadata?: boolean;\n}\n\n/**\n * Displays a title bar containing a label with the title of the video.\n */\nexport class TitleBar extends Container<TitleBarConfig> {\n\n  constructor(config: TitleBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-titlebar',\n      hidden: true,\n      components: [\n        new MetadataLabel({ content: MetadataLabelContent.Title }),\n        new MetadataLabel({ content: MetadataLabelContent.Description }),\n      ],\n      keepHiddenWithoutMetadata: false,\n    }, <TitleBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <TitleBarConfig>this.getConfig();\n    let shouldBeShown = !this.isHidden();\n    let hasMetadataText = true; // Flag to track if any metadata label contains text\n\n    let checkMetadataTextAndUpdateVisibility = () => {\n      hasMetadataText = false;\n\n      // Iterate through metadata labels and check if at least one of them contains text\n      for (let component of this.getComponents()) {\n        if (component instanceof MetadataLabel) {\n          if (!component.isEmpty()) {\n            hasMetadataText = true;\n            break;\n          }\n        }\n      }\n\n      if (this.isShown()) {\n        // Hide a visible titlebar if it does not contain any text and the hidden flag is set\n        if (config.keepHiddenWithoutMetadata && !hasMetadataText) {\n          this.hide();\n        }\n      } else if (shouldBeShown) {\n        // Show a hidden titlebar if it should actually be shown\n        this.show();\n      }\n    };\n\n    // Listen to text change events to update the hasMetadataText flag when the metadata dynamically changes\n    for (let component of this.getComponents()) {\n      if (component instanceof MetadataLabel) {\n        component.onTextChanged.subscribe(checkMetadataTextAndUpdateVisibility);\n      }\n    }\n\n    uimanager.onControlsShow.subscribe(() => {\n      shouldBeShown = true;\n      if (!(config.keepHiddenWithoutMetadata && !hasMetadataText)) {\n        this.show();\n      }\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      shouldBeShown = false;\n      this.hide();\n    });\n\n    // init\n    checkMetadataTextAndUpdateVisibility();\n  }\n}","import {Button, ButtonConfig} from './button';\nimport {NoArgs, EventDispatcher, Event} from '../eventdispatcher';\nimport { UIInstanceManager } from '../uimanager';\n\n/**\n * Configuration interface for a toggle button component.\n */\nexport interface ToggleButtonConfig extends ButtonConfig {\n  /**\n   * The CSS class that marks the on-state of the button.\n   */\n  onClass?: string;\n  /**\n   * The CSS class that marks the off-state of the button.\n   */\n  offClass?: string;\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A button that can be toggled between 'on' and 'off' states.\n */\nexport class ToggleButton<Config extends ToggleButtonConfig> extends Button<ToggleButtonConfig> {\n\n  private onState: boolean;\n\n  private toggleButtonEvents = {\n    onToggle: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOn: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOff: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n  };\n\n  constructor(config: ToggleButtonConfig) {\n    super(config);\n\n    const defaultConfig: ToggleButtonConfig = {\n      cssClass: 'ui-togglebutton',\n      onClass: 'on',\n      offClass: 'off',\n    };\n\n    this.config = this.mergeConfig(config, defaultConfig, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    const config = this.getConfig() as ToggleButtonConfig;\n    this.getDomElement().addClass(this.prefixCss(config.offClass));\n  }\n\n  /**\n   * Toggles the button to the 'on' state.\n   */\n  on() {\n    if (this.isOff()) {\n      const config = this.getConfig() as ToggleButtonConfig;\n\n      this.onState = true;\n      this.getDomElement().removeClass(this.prefixCss(config.offClass));\n      this.getDomElement().addClass(this.prefixCss(config.onClass));\n\n      this.onToggleEvent();\n      this.onToggleOnEvent();\n    }\n  }\n\n  /**\n   * Toggles the button to the 'off' state.\n   */\n  off() {\n    if (this.isOn()) {\n      const config = this.getConfig() as ToggleButtonConfig;\n\n      this.onState = false;\n      this.getDomElement().removeClass(this.prefixCss(config.onClass));\n      this.getDomElement().addClass(this.prefixCss(config.offClass));\n\n      this.onToggleEvent();\n      this.onToggleOffEvent();\n    }\n  }\n\n  /**\n   * Toggle the button 'on' if it is 'off', or 'off' if it is 'on'.\n   */\n  toggle() {\n    if (this.isOn()) {\n      this.off();\n    } else {\n      this.on();\n    }\n  }\n\n  /**\n   * Checks if the toggle button is in the 'on' state.\n   * @returns {boolean} true if button is 'on', false if 'off'\n   */\n  isOn(): boolean {\n    return this.onState;\n  }\n\n  /**\n   * Checks if the toggle button is in the 'off' state.\n   * @returns {boolean} true if button is 'off', false if 'on'\n   */\n  isOff(): boolean {\n    return !this.isOn();\n  }\n\n  protected onClickEvent() {\n    super.onClickEvent();\n\n    // Fire the toggle event together with the click event\n    // (they are technically the same, only the semantics are different)\n    this.onToggleEvent();\n  }\n\n  protected onToggleEvent() {\n    this.toggleButtonEvents.onToggle.dispatch(this);\n  }\n\n  protected onToggleOnEvent() {\n    this.toggleButtonEvents.onToggleOn.dispatch(this);\n  }\n\n  protected onToggleOffEvent() {\n    this.toggleButtonEvents.onToggleOff.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggle(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggle.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'on'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOn(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOn.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'off'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOff(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOff.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\n\n/**\n * Animated analog TV static noise.\n */\nexport class TvNoiseCanvas extends Component<ComponentConfig> {\n\n  private canvas: DOM;\n\n  private canvasElement: HTMLCanvasElement;\n  private canvasContext: CanvasRenderingContext2D;\n  private canvasWidth = 160;\n  private canvasHeight = 90;\n  private interferenceHeight = 50;\n  private lastFrameUpdate: number = 0;\n  private frameInterval: number = 60;\n  private useAnimationFrame: boolean = !!window.requestAnimationFrame;\n  private noiseAnimationWindowPos: number;\n  private frameUpdateHandlerId: number;\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-tvnoisecanvas',\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    return this.canvas = new DOM('canvas', { 'class': this.getCssClasses() });\n  }\n\n  start(): void {\n    this.canvasElement = <HTMLCanvasElement>this.canvas.get(0);\n    this.canvasContext = this.canvasElement.getContext('2d');\n    this.noiseAnimationWindowPos = -this.canvasHeight;\n    this.lastFrameUpdate = 0;\n\n    this.canvasElement.width = this.canvasWidth;\n    this.canvasElement.height = this.canvasHeight;\n\n    this.renderFrame();\n  }\n\n  stop(): void {\n    if (this.useAnimationFrame) {\n      cancelAnimationFrame(this.frameUpdateHandlerId);\n    } else {\n      clearTimeout(this.frameUpdateHandlerId);\n    }\n  }\n\n  private renderFrame(): void {\n    // This code has been copied from the player controls.js and simplified\n\n    if (this.lastFrameUpdate + this.frameInterval > new Date().getTime()) {\n      // It's too early to render the next frame\n      this.scheduleNextRender();\n      return;\n    }\n\n    let currentPixelOffset;\n    let canvasWidth = this.canvasWidth;\n    let canvasHeight = this.canvasHeight;\n\n    // Create texture\n    let noiseImage = this.canvasContext.createImageData(canvasWidth, canvasHeight);\n\n    // Fill texture with noise\n    for (let y = 0; y < canvasHeight; y++) {\n      for (let x = 0; x < canvasWidth; x++) {\n        currentPixelOffset = (canvasWidth * y * 4) + x * 4;\n        noiseImage.data[currentPixelOffset] = Math.random() * 255;\n        if (y < this.noiseAnimationWindowPos || y > this.noiseAnimationWindowPos + this.interferenceHeight) {\n          noiseImage.data[currentPixelOffset] *= 0.85;\n        }\n        noiseImage.data[currentPixelOffset + 1] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 2] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 3] = 50;\n      }\n    }\n\n    // Put texture onto canvas\n    this.canvasContext.putImageData(noiseImage, 0, 0);\n\n    this.lastFrameUpdate = new Date().getTime();\n    this.noiseAnimationWindowPos += 7;\n    if (this.noiseAnimationWindowPos > canvasHeight) {\n      this.noiseAnimationWindowPos = -canvasHeight;\n    }\n\n    this.scheduleNextRender();\n  }\n\n  private scheduleNextRender(): void {\n    if (this.useAnimationFrame) {\n      this.frameUpdateHandlerId = window.requestAnimationFrame(this.renderFrame.bind(this));\n    } else {\n      this.frameUpdateHandlerId = setTimeout(this.renderFrame.bind(this), this.frameInterval);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {DOM} from '../dom';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../playerutils';\nimport PlayerResizeEvent = bitmovin.PlayerAPI.PlayerResizeEvent;\nimport {CancelEventArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link UIContainer}.\n */\nexport interface UIContainerConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the control bar will be hidden when there is no user interaction.\n   * Set to -1 for the UI to be always shown.\n   * Default: 5 seconds (5000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * The base container that contains all of the UI. The UIContainer is passed to the {@link UIManager} to build and\n * setup the UI.\n */\nexport class UIContainer extends Container<UIContainerConfig> {\n\n  private static readonly STATE_PREFIX = 'player-state-';\n\n  private static readonly FULLSCREEN = 'fullscreen';\n  private static readonly BUFFERING = 'buffering';\n  private static readonly REMOTE_CONTROL = 'remote-control';\n  private static readonly CONTROLS_SHOWN = 'controls-shown';\n  private static readonly CONTROLS_HIDDEN = 'controls-hidden';\n\n  private uiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <UIContainerConfig>{\n      cssClass: 'ui-uicontainer',\n      hideDelay: 5000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.configureUIShowHide(player, uimanager);\n    this.configurePlayerStates(player, uimanager);\n  }\n\n  private configureUIShowHide(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n    let config = <UIContainerConfig>this.getConfig();\n\n    if (config.hideDelay === -1) {\n      uimanager.onConfigured.subscribe(() => uimanager.onControlsShow.dispatch(this));\n      return;\n    }\n\n    let isUiShown = false;\n    let isSeeking = false;\n    let isFirstTouch = true;\n\n    let showUi = () => {\n      if (!isUiShown) {\n        // Let subscribers know that they should reveal themselves\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n      // Don't trigger timeout while seeking (it will be triggered once the seek is finished) or casting\n      if (!isSeeking && !player.isCasting()) {\n        this.uiHideTimeout.start();\n      }\n    };\n\n    let hideUi = () => {\n      // Hide the UI only if it is shown, and if not casting\n      if (isUiShown && !player.isCasting()) {\n        // Issue a preview event to check if we are good to hide the controls\n        let previewHideEventArgs = <CancelEventArgs>{};\n        uimanager.onPreviewControlsHide.dispatch(this, previewHideEventArgs);\n\n        if (!previewHideEventArgs.cancel) {\n          // If the preview wasn't canceled, let subscribers know that they should now hide themselves\n          uimanager.onControlsHide.dispatch(this);\n          isUiShown = false;\n        } else {\n          // If the hide preview was canceled, continue to show UI\n          showUi();\n        }\n      }\n    };\n\n    // Timeout to defer UI hiding by the configured delay time\n    this.uiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    // On touch displays, the first touch reveals the UI\n    container.on('touchend', (e) => {\n      if (!isUiShown) {\n        // Only if the UI is hidden, we prevent other actions (except for the first touch) and reveal the UI instead.\n        // The first touch is not prevented to let other listeners receive the event and trigger an initial action, e.g.\n        // the huge playback button can directly start playback instead of requiring a double tap which 1. reveals\n        // the UI and 2. starts playback.\n        if (isFirstTouch) {\n          isFirstTouch = false;\n        } else {\n          e.preventDefault();\n        }\n        showUi();\n      }\n    });\n    // When the mouse enters, we show the UI\n    container.on('mouseenter', () => {\n      showUi();\n    });\n    // When the mouse moves within, we show the UI\n    container.on('mousemove', () => {\n      showUi();\n    });\n    // When the mouse leaves, we can prepare to hide the UI, except a seek is going on\n    container.on('mouseleave', () => {\n      // When a seek is going on, the seek scrub pointer may exit the UI area while still seeking, and we do not hide\n      // the UI in such cases\n      if (!isSeeking) {\n        this.uiHideTimeout.start();\n      }\n    });\n\n    uimanager.onSeek.subscribe(() => {\n      this.uiHideTimeout.clear(); // Don't hide UI while a seek is in progress\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n      this.uiHideTimeout.start(); // Re-enable UI hide timeout after a seek\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      showUi(); // Show UI when a Cast session has started (UI will then stay permanently on during the session)\n    });\n  }\n\n  private configurePlayerStates(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n\n    // Convert player states into CSS class names\n    let stateClassNames = <any>[];\n    for (let state in PlayerUtils.PlayerState) {\n      if (isNaN(Number(state))) {\n        let enumName = PlayerUtils.PlayerState[<any>PlayerUtils.PlayerState[state]];\n        stateClassNames[PlayerUtils.PlayerState[state]] =\n          this.prefixCss(UIContainer.STATE_PREFIX + enumName.toLowerCase());\n      }\n    }\n\n    let removeStates = () => {\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    };\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n    });\n    player.addEventHandler(player.EVENT.ON_PAUSED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    });\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n    });\n    // Init in current player state\n    container.addClass(stateClassNames[PlayerUtils.getState(player)]);\n\n    // Fullscreen marker class\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, () => {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, () => {\n      container.removeClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    // Init fullscreen state\n    if (player.isFullscreen()) {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    }\n\n    // Buffering marker class\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, () => {\n      container.removeClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    // Init buffering state\n    if (player.isStalled()) {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    }\n\n    // RemoteControl marker class\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      container.removeClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    // Init RemoteControl state\n    if (player.isCasting()) {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    }\n\n    // Controls visibility marker class\n    uimanager.onControlsShow.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n    });\n\n    // Layout size classes\n    let updateLayoutSizeClasses = (width: number, height: number) => {\n      container.removeClass(this.prefixCss('layout-max-width-400'));\n      container.removeClass(this.prefixCss('layout-max-width-600'));\n      container.removeClass(this.prefixCss('layout-max-width-800'));\n      container.removeClass(this.prefixCss('layout-max-width-1200'));\n\n      if (width <= 400) {\n        container.addClass(this.prefixCss('layout-max-width-400'));\n      } else if (width <= 600) {\n        container.addClass(this.prefixCss('layout-max-width-600'));\n      } else if (width <= 800) {\n        container.addClass(this.prefixCss('layout-max-width-800'));\n      } else if (width <= 1200) {\n        container.addClass(this.prefixCss('layout-max-width-1200'));\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, (e: PlayerResizeEvent) => {\n      // Convert strings (with \"px\" suffix) to ints\n      let width = Math.round(Number(e.width.substring(0, e.width.length - 2)));\n      let height = Math.round(Number(e.height.substring(0, e.height.length - 2)));\n\n      updateLayoutSizeClasses(width, height);\n    });\n    // Init layout state\n    updateLayoutSizeClasses(new DOM(player.getFigure()).width(), new DOM(player.getFigure()).height());\n  }\n\n  release(): void {\n    super.release();\n    this.uiHideTimeout.clear();\n  }\n\n  protected toDomElement(): DOM {\n    let container = super.toDomElement();\n\n    // Detect flexbox support (not supported in IE9)\n    if (document && typeof document.createElement('p').style.flex !== 'undefined') {\n      container.addClass(this.prefixCss('flexbox'));\n    } else {\n      container.addClass(this.prefixCss('no-flexbox'));\n    }\n\n    return container;\n  }\n}\n","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available video qualities.\n */\nexport class VideoQualitySelectBox extends SelectBox {\n\n  private hasAuto: boolean;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let selectCurrentVideoQuality = () => {\n      if (player.getVideoQuality) {\n        // Since player 7.3.1\n        this.selectItem(player.getVideoQuality().id);\n      } else {\n        // Backwards compatibility for players <= 7.3.0\n        // TODO remove in next major release\n        let data = player.getDownloadedVideoData();\n        this.selectItem(data.isAuto ? 'auto' : data.id);\n      }\n    };\n\n    let updateVideoQualities = () => {\n      let videoQualities = player.getAvailableVideoQualities();\n\n      this.clearItems();\n\n      // Progressive streams do not support automatic quality selection\n      this.hasAuto = player.getStreamType() !== 'progressive';\n\n      if (this.hasAuto) {\n        // Add entry for automatic quality switching (default setting)\n        this.addItem('auto', 'auto');\n      }\n\n      // Add video qualities\n      for (let videoQuality of videoQualities) {\n        this.addItem(videoQuality.id, videoQuality.label);\n      }\n\n      // Select initial quality\n      selectCurrentVideoQuality();\n    };\n\n    this.onItemSelected.subscribe((sender: VideoQualitySelectBox, value: string) => {\n      player.setVideoQuality(value);\n    });\n\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateVideoQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateVideoQualities);\n    // Update qualities when the period within a source changes\n    player.addEventHandler(player.EVENT.ON_PERIOD_SWITCHED, updateVideoQualities);\n    // Update quality selection when quality is changed (from outside)\n    if (player.EVENT.ON_VIDEO_QUALITY_CHANGED) {\n      // Since player 7.3.1\n      player.addEventHandler(player.EVENT.ON_VIDEO_QUALITY_CHANGED, selectCurrentVideoQuality);\n    } else {\n      // Backwards compatibility for players <= 7.3.0\n      // TODO remove in next major release\n      player.addEventHandler(player.EVENT.ON_VIDEO_DOWNLOAD_QUALITY_CHANGE, selectCurrentVideoQuality);\n    }\n  }\n\n  /**\n   * Returns true if the select box contains an 'auto' item for automatic quality selection mode.\n   * @return {boolean}\n   */\n  hasAutoItem(): boolean {\n    return this.hasAuto;\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {VolumeSlider} from './volumeslider';\nimport {VolumeToggleButton} from './volumetogglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for a {@link VolumeControlButton}.\n */\nexport interface VolumeControlButtonConfig extends ContainerConfig {\n  /**\n   * The delay after which the volume slider will be hidden when there is no user interaction.\n   * Care must be taken that the delay is long enough so users can reach the slider from the toggle button, e.g. by\n   * mouse movement. If the delay is too short, the sliders disappears before the mouse pointer has reached it and\n   * the user is not able to use it.\n   * Default: 500ms\n   */\n  hideDelay?: number;\n  /**\n   * Specifies if the volume slider should be vertically or horizontally aligned.\n   * Default: true\n   */\n  vertical?: boolean;\n}\n\n/**\n * A composite volume control that consists of and internally manages a volume control button that can be used\n * for muting, and a (depending on the CSS style, e.g. slide-out) volume control bar.\n */\nexport class VolumeControlButton extends Container<VolumeControlButtonConfig> {\n\n  private volumeToggleButton: VolumeToggleButton;\n  private volumeSlider: VolumeSlider;\n\n  private volumeSliderHideTimeout: Timeout;\n\n  constructor(config: VolumeControlButtonConfig = {}) {\n    super(config);\n\n    this.volumeToggleButton = new VolumeToggleButton();\n    this.volumeSlider = new VolumeSlider({\n      vertical: config.vertical != null ? config.vertical : true,\n      hidden: true,\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumecontrolbutton',\n      components: [this.volumeToggleButton, this.volumeSlider],\n      hideDelay: 500,\n    }, <VolumeControlButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let volumeToggleButton = this.getVolumeToggleButton();\n    let volumeSlider = this.getVolumeSlider();\n\n    this.volumeSliderHideTimeout = new Timeout((<VolumeControlButtonConfig>this.getConfig()).hideDelay, () => {\n      volumeSlider.hide();\n    });\n\n    /*\n     * Volume Slider visibility handling\n     *\n     * The volume slider shall be visible while the user hovers the mute toggle button, while the user hovers the\n     * volume slider, and while the user slides the volume slider. If none of these situations are true, the slider\n     * shall disappear.\n     */\n    let volumeSliderHovered = false;\n    volumeToggleButton.getDomElement().on('mouseenter', () => {\n      // Show volume slider when mouse enters the button area\n      if (volumeSlider.isHidden()) {\n        volumeSlider.show();\n      }\n      // Avoid hiding of the slider when button is hovered\n      this.volumeSliderHideTimeout.clear();\n    });\n    volumeToggleButton.getDomElement().on('mouseleave', () => {\n      // Hide slider delayed when button is left\n      this.volumeSliderHideTimeout.reset();\n    });\n    volumeSlider.getDomElement().on('mouseenter', () => {\n      // When the slider is entered, cancel the hide timeout activated by leaving the button\n      this.volumeSliderHideTimeout.clear();\n      volumeSliderHovered = true;\n    });\n    volumeSlider.getDomElement().on('mouseleave', () => {\n      // When mouse leaves the slider, only hide it if there is no slide operation in progress\n      if (volumeSlider.isSeeking()) {\n        this.volumeSliderHideTimeout.clear();\n      } else {\n        this.volumeSliderHideTimeout.reset();\n      }\n      volumeSliderHovered = false;\n    });\n    volumeSlider.onSeeked.subscribe(() => {\n      // When a slide operation is done and the slider not hovered (mouse outside slider), hide slider delayed\n      if (!volumeSliderHovered) {\n        this.volumeSliderHideTimeout.reset();\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n    this.volumeSliderHideTimeout.clear();\n  }\n\n  /**\n   * Provides access to the internally managed volume toggle button.\n   * @returns {VolumeToggleButton}\n   */\n  getVolumeToggleButton(): VolumeToggleButton {\n    return this.volumeToggleButton;\n  }\n\n  /**\n   * Provides access to the internally managed volume silder.\n   * @returns {VolumeSlider}\n   */\n  getVolumeSlider(): VolumeSlider {\n    return this.volumeSlider;\n  }\n}","import {SeekBar, SeekBarConfig} from './seekbar';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link VolumeSlider} component.\n */\nexport interface VolumeSliderConfig extends SeekBarConfig {\n  /**\n   * Specifies if the volume slider should be automatically hidden when volume control is prohibited by the\n   * browser or platform. This currently only applies to iOS.\n   * Default: true\n   */\n  hideIfVolumeControlProhibited: boolean;\n}\n\n/**\n * A simple volume slider component to adjust the player's volume setting.\n */\nexport class VolumeSlider extends SeekBar {\n\n  private static readonly issuerName = 'ui';\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <VolumeSliderConfig>{\n      cssClass: 'ui-volumeslider',\n      hideIfVolumeControlProhibited: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager, false);\n\n    let config = <VolumeSliderConfig>this.getConfig();\n\n    if (config.hideIfVolumeControlProhibited && !this.detectVolumeControlAvailability()) {\n      this.hide();\n\n      // We can just return from here, because the user will never interact with the control and any configured\n      // functionality would only eat resources for no reason.\n      return;\n    }\n\n    let volumeChangeHandler = () => {\n      if (player.isMuted()) {\n        this.setPlaybackPosition(0);\n      } else {\n        this.setPlaybackPosition(player.getVolume());\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_MUTED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, volumeChangeHandler);\n\n    this.onSeekPreview.subscribeRateLimited((sender, args) => {\n      if (args.scrubbing) {\n        player.setVolume(args.position, VolumeSlider.issuerName);\n      }\n    }, 50);\n    this.onSeeked.subscribe((sender, percentage) => {\n      player.setVolume(percentage, VolumeSlider.issuerName);\n    });\n\n    // Update the volume slider marker when the player resized, a source is loaded and player is ready,\n    // or the UI is configured. Check the seekbar for a detailed description.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Init volume bar\n    volumeChangeHandler();\n  }\n\n  private detectVolumeControlAvailability(): boolean {\n    /*\n     * \"On iOS devices, the audio level is always under the users physical control. The volume property is not\n     * settable in JavaScript. Reading the volume property always returns 1.\"\n     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n     */\n    // as muted autoplay gets paused as soon as we unmute it, we may not touch the volume of the actual player so we\n    // probe a dummy audio element\n    const dummyVideoElement = document.createElement('video');\n    // try setting the volume to 0.7 and if it's still 1 we are on a volume control restricted device\n    dummyVideoElement.volume = 0.7;\n    return dummyVideoElement.volume !== 1;\n  }\n}\n","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles audio muting.\n */\nexport class VolumeToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    const defaultConfig: ToggleButtonConfig = {\n      cssClass: 'ui-volumetogglebutton',\n      text: 'Volume/Mute',\n      onClass: 'muted',\n      offClass: 'unmuted',\n    };\n\n    this.config = this.mergeConfig(config, defaultConfig, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let muteStateHandler = () => {\n      if (player.isMuted()) {\n        this.on();\n\n        // When the volume is unmuted and the volume level is veeeery low, we increase it to 10%. This especially helps\n        // in the case when the volume is first turned down to 0 and then the player is muted; when the player gets\n        // unmuted it would switch to volume level 0 which would seem like unmuting did not work, and increasing the\n        // level a bit helps to overcome this issue.\n        if (player.getVolume() < 10) {\n          player.setVolume(10);\n        }\n      } else {\n        this.off();\n      }\n    };\n\n    let volumeLevelHandler = () => {\n      const volumeLevelTens = Math.ceil(player.getVolume() / 10);\n      this.getDomElement().data(this.prefixCss('volume-level-tens'), String(volumeLevelTens));\n\n      // When the volume is turned down to zero, switch into the mute state of the button. This avoids the usability\n      // issue where the volume is turned down to zero, the button shows the muted icon but is not really unmuted, and\n      // the next button press would switch it into the mute state, visually staying the same which would seem like\n      // an expected unmute did not work.\n      if (volumeLevelTens === 0) {\n        this.off();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_MUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeLevelHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isMuted()) {\n        player.unmute('ui-volumetogglebutton');\n      } else {\n        player.mute('ui-volumetogglebutton');\n      }\n    });\n\n    // Startup init\n    muteStateHandler();\n    volumeLevelHandler();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the video view between normal/mono and VR/stereo.\n */\nexport class VRToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-vrtogglebutton',\n      text: 'VR',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let isVRConfigured = () => {\n      // VR availability cannot be checked through getVRStatus() because it is asynchronously populated and not\n      // available at UI initialization. As an alternative, we check the VR settings in the config.\n      // TODO use getVRStatus() through isVRStereoAvailable() once the player has been rewritten and the status is\n      // available in ON_READY\n      let config = player.getConfig();\n      return config.source && config.source.vr && config.source.vr.contentType !== 'none';\n    };\n\n    let isVRStereoAvailable = () => {\n      return player.getVRStatus().contentType !== 'none';\n    };\n\n    let vrStateHandler = () => {\n      if (isVRConfigured() && isVRStereoAvailable()) {\n        this.show(); // show button in case it is hidden\n\n        if (player.getVRStatus().isStereo) {\n          this.on();\n        } else {\n          this.off();\n        }\n      } else {\n        this.hide(); // hide button if no stereo mode available\n      }\n    };\n\n    let vrButtonVisibilityHandler = () => {\n      if (isVRConfigured()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_VR_MODE_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_STEREO_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_ERROR, vrStateHandler);\n    // Hide button when VR source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, vrButtonVisibilityHandler);\n    // Show button when a new source is loaded and it's VR\n    player.addEventHandler(player.EVENT.ON_READY, vrButtonVisibilityHandler);\n\n    this.onClick.subscribe(() => {\n      if (!isVRStereoAvailable()) {\n        if (console) {\n          console.log('No VR content');\n        }\n      } else {\n        if (player.getVRStatus().isStereo) {\n          player.setVRStereo(false);\n        } else {\n          player.setVRStereo(true);\n        }\n      }\n    });\n\n    // Set startup visibility\n    vrButtonVisibilityHandler();\n  }\n}","import {ClickOverlay, ClickOverlayConfig} from './clickoverlay';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface WatermarkConfig extends ClickOverlayConfig {\n  // nothing yet\n}\n\n/**\n * A watermark overlay with a clickable logo.\n */\nexport class Watermark extends ClickOverlay {\n\n  constructor(config: WatermarkConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-watermark',\n      url: 'http://bitmovin.com',\n    }, <WatermarkConfig>this.config);\n  }\n}","export interface Offset {\n  left: number;\n  top: number;\n}\n\n/**\n * Simple DOM manipulation and DOM element event handling modeled after jQuery (as replacement for jQuery).\n *\n * Like jQuery, DOM operates on single elements and lists of elements. For example: creating an element returns a DOM\n * instance with a single element, selecting elements returns a DOM instance with zero, one, or many elements. Similar\n * to jQuery, setters usually affect all elements, while getters operate on only the first element.\n * Also similar to jQuery, most methods (except getters) return the DOM instance facilitating easy chaining of method\n * calls.\n *\n * Built with the help of: http://youmightnotneedjquery.com/\n */\nexport class DOM {\n\n  private document: Document;\n\n  /**\n   * The list of elements that the instance wraps. Take care that not all methods can operate on the whole list,\n   * getters usually just work on the first element.\n   */\n  private elements: HTMLElement[];\n\n  /**\n   * Creates a DOM element.\n   * @param tagName the tag name of the DOM element\n   * @param attributes a list of attributes of the element\n   */\n  constructor(tagName: string, attributes: {[name: string]: string});\n  /**\n   * Selects all elements from the DOM that match the specified selector.\n   * @param selector the selector to match DOM elements with\n   */\n  constructor(selector: string);\n  /**\n   * Wraps a plain HTMLElement with a DOM instance.\n   * @param element the HTMLElement to wrap with DOM\n   */\n  constructor(element: HTMLElement);\n  /**\n   * Wraps a list of plain HTMLElements with a DOM instance.\n   * @param elements the HTMLElements to wrap with DOM\n   */\n  constructor(elements: HTMLElement[]);\n  /**\n   * Wraps the document with a DOM instance. Useful to attach event listeners to the document.\n   * @param document the document to wrap\n   */\n  constructor(document: Document);\n  constructor(something: string | HTMLElement | HTMLElement[] | Document, attributes?: {[name: string]: string}) {\n    this.document = document; // Set the global document to the local document field\n\n    if (something instanceof Array) {\n      if (something.length > 0 && something[0] instanceof HTMLElement) {\n        let elements = something;\n        this.elements = elements;\n      }\n    }\n    else if (something instanceof HTMLElement) {\n      let element = something;\n      this.elements = [element];\n    }\n    else if (something instanceof Document) {\n      // When a document is passed in, we do not do anything with it, but by setting this.elements to null\n      // we give the event handling method a means to detect if the events should be registered on the document\n      // instead of elements.\n      this.elements = null;\n    }\n    else if (attributes) {\n      let tagName = something;\n      let element = document.createElement(tagName);\n\n      for (let attributeName in attributes) {\n        let attributeValue = attributes[attributeName];\n        element.setAttribute(attributeName, attributeValue);\n      }\n\n      this.elements = [element];\n    }\n    else {\n      let selector = something;\n      this.elements = this.findChildElements(selector);\n    }\n  }\n\n  /**\n   * Gets the number of elements that this DOM instance currently holds.\n   * @returns {number} the number of elements\n   */\n  get length(): number {\n    return this.elements ? this.elements.length : 0;\n  }\n\n  /**\n   * Gets the HTML elements that this DOM instance currently holds.\n   * @returns {HTMLElement[]} the raw HTML elements\n   * @deprecated use {@link #get()} instead\n   */\n  getElements(): HTMLElement[] {\n    return this.get();\n  }\n\n  /**\n   * Gets the HTML elements that this DOM instance currently holds.\n   * @returns {HTMLElement[]} the raw HTML elements\n   */\n  get(): HTMLElement[];\n  /**\n   * Gets an HTML element from the list elements that this DOM instance currently holds.\n   * @param index The zero-based index into the element list. Can be negative to return an element from the end,\n   *    e.g. -1 returns the last element.\n   */\n  get(index: number): HTMLElement;\n  get(index?: number): HTMLElement | HTMLElement[] {\n    if (index === undefined) {\n      return this.elements;\n    } else if (!this.elements || index >= this.elements.length || index < -this.elements.length) {\n      return undefined;\n    } else if (index < 0) {\n      return this.elements[this.elements.length - index];\n    } else {\n      return this.elements[index];\n    }\n  }\n\n  /**\n   * A shortcut method for iterating all elements. Shorts this.elements.forEach(...) to this.forEach(...).\n   * @param handler the handler to execute an operation on an element\n   */\n  private forEach(handler: (element: HTMLElement) => void): void {\n    if (!this.elements) {\n      return;\n    }\n    this.elements.forEach((element) => {\n      handler(element);\n    });\n  }\n\n  private findChildElementsOfElement(element: HTMLElement | Document, selector: string): HTMLElement[] {\n    let childElements = element.querySelectorAll(selector);\n\n    // Convert NodeList to Array\n    // https://toddmotto.com/a-comprehensive-dive-into-nodelists-arrays-converting-nodelists-and-understanding-the-dom/\n    return [].slice.call(childElements);\n  }\n\n  private findChildElements(selector: string): HTMLElement[] {\n    let allChildElements = <HTMLElement[]>[];\n\n    if (this.elements) {\n      this.forEach((element) => {\n        allChildElements = allChildElements.concat(this.findChildElementsOfElement(element, selector));\n      });\n    }\n    else {\n      return this.findChildElementsOfElement(document, selector);\n    }\n\n    return allChildElements;\n  }\n\n  /**\n   * Finds all child elements of all elements matching the supplied selector.\n   * @param selector the selector to match with child elements\n   * @returns {DOM} a new DOM instance representing all matched children\n   */\n  find(selector: string): DOM {\n    let allChildElements = this.findChildElements(selector);\n    return new DOM(allChildElements);\n  }\n\n  /**\n   * Returns a string of the inner HTML content of the first element.\n   */\n  html(): string;\n  /**\n   * Sets the inner HTML content of all elements.\n   * @param content a string of plain text or HTML markup\n   */\n  html(content: string): DOM;\n  html(content?: string): string | DOM {\n    if (arguments.length > 0) {\n      return this.setHtml(content);\n    }\n    else {\n      return this.getHtml();\n    }\n  }\n\n  private getHtml(): string | null {\n    return this.elements[0].innerHTML;\n  }\n\n  private setHtml(content: string): DOM {\n    if (content === undefined || content == null) {\n      // Set to empty string to avoid innerHTML getting set to 'undefined' (all browsers) or 'null' (IE9)\n      content = '';\n    }\n\n    this.forEach((element) => {\n      element.innerHTML = content;\n    });\n\n    return this;\n  }\n\n  /**\n   * Clears the inner HTML of all elements (deletes all children).\n   * @returns {DOM}\n   */\n  empty(): DOM {\n    this.forEach((element) => {\n      element.innerHTML = '';\n    });\n    return this;\n  }\n\n  /**\n   * Returns the current value of the first form element, e.g. the selected value of a select box or the text if an\n   * input field.\n   * @returns {string} the value of a form element\n   */\n  val(): string {\n    let element = this.elements[0];\n\n    if (element instanceof HTMLSelectElement || element instanceof HTMLInputElement) {\n      return element.value;\n    }\n    else {\n      // TODO add support for missing form elements\n      throw new Error(`val() not supported for ${typeof element}`);\n    }\n  }\n\n  /**\n   * Returns the value of an attribute on the first element.\n   * @param attribute\n   */\n  attr(attribute: string): string | null;\n  /**\n   * Sets an attribute on all elements.\n   * @param attribute the name of the attribute\n   * @param value the value of the attribute\n   */\n  attr(attribute: string, value: string): DOM;\n  attr(attribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setAttr(attribute, value);\n    }\n    else {\n      return this.getAttr(attribute);\n    }\n  }\n\n  private getAttr(attribute: string): string | null {\n    return this.elements[0].getAttribute(attribute);\n  }\n\n  private setAttr(attribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute(attribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Returns the value of a data element on the first element.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   */\n  data(dataAttribute: string): string | null;\n  /**\n   * Sets a data attribute on all elements.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   * @param value the value of the data attribute\n   */\n  data(dataAttribute: string, value: string): DOM;\n  data(dataAttribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setData(dataAttribute, value);\n    }\n    else {\n      return this.getData(dataAttribute);\n    }\n  }\n\n  private getData(dataAttribute: string): string | null {\n    return this.elements[0].getAttribute('data-' + dataAttribute);\n  }\n\n  private setData(dataAttribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute('data-' + dataAttribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Appends one or more DOM elements as children to all elements.\n   * @param childElements the chrild elements to append\n   * @returns {DOM}\n   */\n  append(...childElements: DOM[]): DOM {\n    this.forEach((element) => {\n      childElements.forEach((childElement) => {\n        childElement.elements.forEach((_, index) => {\n          element.appendChild(childElement.elements[index]);\n        });\n      });\n    });\n    return this;\n  }\n\n  /**\n   * Removes all elements from the DOM.\n   */\n  remove(): void {\n    this.forEach((element) => {\n      let parent = element.parentNode;\n      if (parent) {\n        parent.removeChild(element);\n      }\n    });\n  }\n\n  /**\n   * Returns the offset of the first element from the document's top left corner.\n   * @returns {Offset}\n   */\n  offset(): Offset {\n    let element = this.elements[0];\n    let elementRect = element.getBoundingClientRect();\n    let htmlRect = document.body.parentElement.getBoundingClientRect();\n\n    // Virtual viewport scroll handling (e.g. pinch zoomed viewports in mobile browsers or desktop Chrome/Edge)\n    // 'normal' zooms and virtual viewport zooms (aka layout viewport) result in different\n    // element.getBoundingClientRect() results:\n    //  - with normal scrolls, the clientRect decreases with an increase in scroll(Top|Left)/page(X|Y)Offset\n    //  - with pinch zoom scrolls, the clientRect stays the same while scroll/pageOffset changes\n    // This means, that the combination of clientRect + scroll/pageOffset does not work to calculate the offset\n    // from the document's upper left origin when pinch zoom is used.\n    // To work around this issue, we do not use scroll/pageOffset but get the clientRect of the html element and\n    // subtract it from the element's rect, which always results in the offset from the document origin.\n    // NOTE: the current way of offset calculation was implemented specifically to track event positions on the\n    // seek bar, and it might break compatibility with jQuery's offset() method. If this ever turns out to be a\n    // problem, this method should be reverted to the old version and the offset calculation moved to the seek bar.\n\n    return {\n      top: elementRect.top - htmlRect.top,\n      left: elementRect.left - htmlRect.left,\n    };\n  }\n\n  /**\n   * Returns the width of the first element.\n   * @returns {number} the width of the first element\n   */\n  width(): number {\n    // TODO check if this is the same as jQuery's width() (probably not)\n    return this.elements[0].offsetWidth;\n  }\n\n  /**\n   * Returns the height of the first element.\n   * @returns {number} the height of the first element\n   */\n  height(): number {\n    // TODO check if this is the same as jQuery's height() (probably not)\n    return this.elements[0].offsetHeight;\n  }\n\n  /**\n   * Attaches an event handler to one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to listen to\n   * @param eventHandler the event handler to call when the event fires\n   * @returns {DOM}\n   */\n  on(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.addEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.addEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removes an event handler from one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to remove the handler from\n   * @param eventHandler the event handler to remove\n   * @returns {DOM}\n   */\n  off(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.removeEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.removeEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds the specified class(es) to all elements.\n   * @param className the class(es) to add, multiple classes separated by space\n   * @returns {DOM}\n   */\n  addClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        const classNames = className.split(' ')\n          .filter(className => className.length > 0);\n\n        if (classNames.length > 0) {\n          element.classList.add(...classNames);\n        }\n      }\n      else {\n        element.className += ' ' + className;\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removed the specified class(es) from all elements.\n   * @param className the class(es) to remove, multiple classes separated by space\n   * @returns {DOM}\n   */\n  removeClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        const classNames = className.split(' ')\n          .filter(className => className.length > 0);\n\n        if (classNames.length > 0) {\n          element.classList.remove(...classNames);\n        }\n      }\n      else {\n        element.className = element.className.replace(\n          new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Checks if any of the elements has the specified class.\n   * @param className the class name to check\n   * @returns {boolean} true if one of the elements has the class attached, else if no element has it attached\n   */\n  hasClass(className: string): boolean {\n    let hasClass = false;\n\n    this.forEach((element) => {\n      if (element.classList) {\n        if (element.classList.contains(className)) {\n          // Since we are inside a handler, we can't just 'return true'. Instead, we save it to a variable\n          // and return it at the end of the function body.\n          hasClass = true;\n        }\n      }\n      else {\n        if (new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className)) {\n          // See comment above\n          hasClass = true;\n        }\n      }\n    });\n\n    return hasClass;\n  }\n\n  /**\n   * Returns the value of a CSS property of the first element.\n   * @param propertyName the name of the CSS property to retrieve the value of\n   */\n  css(propertyName: string): string | null;\n  /**\n   * Sets the value of a CSS property on all elements.\n   * @param propertyName the name of the CSS property to set the value for\n   * @param value the value to set for the given CSS property\n   */\n  css(propertyName: string, value: string): DOM;\n  /**\n   * Sets a collection of CSS properties and their values on all elements.\n   * @param propertyValueCollection an object containing pairs of property names and their values\n   */\n  css(propertyValueCollection: {[propertyName: string]: string}): DOM;\n  css(propertyNameOrCollection: string | {[propertyName: string]: string}, value?: string): string | null | DOM {\n    if (typeof propertyNameOrCollection === 'string') {\n      let propertyName = propertyNameOrCollection;\n\n      if (arguments.length === 2) {\n        return this.setCss(propertyName, value);\n      }\n      else {\n        return this.getCss(propertyName);\n      }\n    }\n    else {\n      let propertyValueCollection = propertyNameOrCollection;\n      return this.setCssCollection(propertyValueCollection);\n    }\n  }\n\n  private getCss(propertyName: string): string | null {\n    return getComputedStyle(this.elements[0])[<any>propertyName];\n  }\n\n  private setCss(propertyName: string, value: string): DOM {\n    this.forEach((element) => {\n      // <any> cast to resolve TS7015: http://stackoverflow.com/a/36627114/370252\n      element.style[<any>propertyName] = value;\n    });\n    return this;\n  }\n\n  private setCssCollection(ruleValueCollection: {[ruleName: string]: string}): DOM {\n    this.forEach((element) => {\n      // http://stackoverflow.com/a/34490573/370252\n      Object.assign(element.style, ruleValueCollection);\n    });\n\n    return this;\n  }\n}\n","import {ArrayUtils} from './arrayutils';\n/**\n * Function interface for event listeners on the {@link EventDispatcher}.\n */\nexport interface EventListener<Sender, Args> {\n  (sender: Sender, args: Args): void;\n}\n\n/**\n * Empty type for creating {@link EventDispatcher event dispatchers} that do not carry any arguments.\n */\nexport interface NoArgs {\n}\n\n/**\n * Event args for an event that can be canceled.\n */\nexport interface CancelEventArgs extends NoArgs {\n  /**\n   * Gets or sets a flag whether the event should be canceled.\n   */\n  cancel?: boolean;\n}\n\n/**\n * Public interface that represents an event. Can be used to subscribe to and unsubscribe from events.\n */\nexport interface Event<Sender, Args> {\n  /**\n   * Subscribes an event listener to this event dispatcher.\n   * @param listener the listener to add\n   */\n  subscribe(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that is only called once.\n   * @param listener the listener to add\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that will be called at a limited rate with a minimum\n   * interval of the specified milliseconds.\n   * @param listener the listener to add\n   * @param rateMs the rate in milliseconds to which calling of the listeners should be limited\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number): void;\n\n  /**\n   * Unsubscribes a subscribed event listener from this dispatcher.\n   * @param listener the listener to remove\n   * @returns {boolean} true if the listener was successfully unsubscribed, false if it isn't subscribed on this\n   *   dispatcher\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean;\n}\n\n/**\n * Event dispatcher to subscribe and trigger events. Each event should have its own dispatcher.\n */\nexport class EventDispatcher<Sender, Args> implements Event<Sender, Args> {\n\n  private listeners: EventListenerWrapper<Sender, Args>[] = [];\n\n  constructor() {\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribe(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener, true));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number) {\n    this.listeners.push(new RateLimitedEventListenerWrapper(listener, rateMs));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean {\n    // Iterate through listeners, compare with parameter, and remove if found\n    // NOTE: In case we ever remove all matching listeners instead of just the first, we need to reverse-iterate here\n    for (let i = 0; i < this.listeners.length; i++) {\n      let subscribedListener = this.listeners[i];\n      if (subscribedListener.listener === listener) {\n        ArrayUtils.remove(this.listeners, subscribedListener);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes all listeners from this dispatcher.\n   */\n  unsubscribeAll(): void {\n    this.listeners = [];\n  }\n\n  /**\n   * Dispatches an event to all subscribed listeners.\n   * @param sender the source of the event\n   * @param args the arguments for the event\n   */\n  dispatch(sender: Sender, args: Args = null) {\n    let listenersToRemove = [];\n\n    // Call every listener\n    // We iterate over a copy of the array of listeners to avoid the case where events are not fired on listeners when\n    // listeners are unsubscribed from within the event handlers during a dispatch (because the indices change and\n    // listeners are shifted within the array).\n    // This means that listener x+1 will still be called if unsubscribed from within the handler of listener x, as well\n    // as listener y+1 will not be called when subscribed from within the handler of listener y.\n    // Array.slice(0) is the fastest array copy method according to: https://stackoverflow.com/a/21514254/370252\n    const listeners = this.listeners.slice(0);\n    for (let listener of listeners) {\n      listener.fire(sender, args);\n\n      if (listener.isOnce()) {\n        listenersToRemove.push(listener);\n      }\n    }\n\n    // Remove one-time listener\n    for (let listenerToRemove of listenersToRemove) {\n      ArrayUtils.remove(this.listeners, listenerToRemove);\n    }\n  }\n\n  /**\n   * Returns the event that this dispatcher manages and on which listeners can subscribe and unsubscribe event handlers.\n   * @returns {Event}\n   */\n  getEvent(): Event<Sender, Args> {\n    // For now, just cast the event dispatcher to the event interface. At some point in the future when the\n    // codebase grows, it might make sense to split the dispatcher into separate dispatcher and event classes.\n    return <Event<Sender, Args>>this;\n  }\n}\n\n/**\n * A basic event listener wrapper to manage listeners within the {@link EventDispatcher}. This is a 'private' class\n * for internal dispatcher use and it is therefore not exported.\n */\nclass EventListenerWrapper<Sender, Args> {\n\n  private eventListener: EventListener<Sender, Args>;\n  private once: boolean;\n\n  constructor(listener: EventListener<Sender, Args>, once: boolean = false) {\n    this.eventListener = listener;\n    this.once = once;\n  }\n\n  /**\n   * Returns the wrapped event listener.\n   * @returns {EventListener<Sender, Args>}\n   */\n  get listener(): EventListener<Sender, Args> {\n    return this.eventListener;\n  }\n\n  /**\n   * Fires the wrapped event listener with the given arguments.\n   * @param sender\n   * @param args\n   */\n  fire(sender: Sender, args: Args) {\n    this.eventListener(sender, args);\n  }\n\n  /**\n   * Checks if this listener is scheduled to be called only once.\n   * @returns {boolean} once if true\n   */\n  isOnce(): boolean {\n    return this.once;\n  }\n}\n\n/**\n * Extends the basic {@link EventListenerWrapper} with rate-limiting functionality.\n */\nclass RateLimitedEventListenerWrapper<Sender, Args> extends EventListenerWrapper<Sender, Args> {\n\n  private rateMs: number;\n  private rateLimitingEventListener: EventListener<Sender, Args>;\n\n  private lastFireTime: number;\n\n  constructor(listener: EventListener<Sender, Args>, rateMs: number) {\n    super(listener); // sets the event listener sink\n\n    this.rateMs = rateMs;\n    this.lastFireTime = 0;\n\n    // Wrap the event listener with an event listener that does the rate-limiting\n    this.rateLimitingEventListener = (sender: Sender, args: Args) => {\n      if (Date.now() - this.lastFireTime > this.rateMs) {\n        // Only if enough time since the previous call has passed, call the\n        // actual event listener and record the current time\n        this.fireSuper(sender, args);\n        this.lastFireTime = Date.now();\n      }\n    };\n  }\n\n  private fireSuper(sender: Sender, args: Args) {\n    // Fire the actual external event listener\n    super.fire(sender, args);\n  }\n\n  fire(sender: Sender, args: Args) {\n    // Fire the internal rate-limiting listener instead of the external event listener\n    this.rateLimitingEventListener(sender, args);\n  }\n}","export namespace Guid {\n\n  let guid = 1;\n\n  export function next() {\n    return guid++;\n  }\n}\n","import {DOM} from './dom';\n\nexport interface ImageLoadedCallback {\n  (url: string, width: number, height: number): void;\n}\n\ninterface ImageLoaderState {\n  url: string;\n  image: DOM;\n  loadedCallback: ImageLoadedCallback;\n  loaded: boolean;\n  width: number;\n  height: number;\n}\n\n/**\n * Tracks the loading state of images.\n */\nexport class ImageLoader {\n\n  private state: { [url: string]: ImageLoaderState; } = {};\n\n  /**\n   * Loads an image and call the callback once the image is loaded. If the image is already loaded, the callback\n   * is called immediately, else it is called once loading has finished. Calling this method multiple times for the\n   * same image while it is loading calls only let callback passed into the last call.\n   * @param url The url to the image to load\n   * @param loadedCallback The callback that is called when the image is loaded\n   */\n  load(url: string, loadedCallback: ImageLoadedCallback): void {\n    if (!this.state[url]) {\n      // When the image was never attempted to be loaded before, we create a state and store it in the state map\n      // for later use when the same image is requested to be loaded again.\n      let state: ImageLoaderState = {\n        url: url,\n        image: new DOM('img', {}),\n        loadedCallback: loadedCallback,\n        loaded: false,\n        width: 0,\n        height: 0,\n      };\n      this.state[url] = state;\n\n      // Listen to the load event, update the state and call the callback once the image is loaded\n      state.image.on('load', (e) => {\n        state.loaded = true;\n        state.width = (<HTMLImageElement>state.image.get(0)).width;\n        state.height = (<HTMLImageElement>state.image.get(0)).height;\n\n        this.callLoadedCallback(state);\n      });\n\n      // Set the image URL to start the loading\n      state.image.attr('src', state.url);\n    } else {\n      // We have a state for the requested image, so it is either already loaded or currently loading\n      let state = this.state[url];\n\n      // We overwrite the callback to make sure that only the callback of the latest call gets executed.\n      // Earlier callbacks become invalid once a new load call arrives, and they are not called as long as the image\n      // is not loaded.\n      state.loadedCallback = loadedCallback;\n\n      // When the image is already loaded, we directly execute the callback instead of waiting for the load event\n      if (state.loaded) {\n        this.callLoadedCallback(state);\n      }\n    }\n  }\n\n  private callLoadedCallback(state: ImageLoaderState): void {\n    state.loadedCallback(state.url, state.width, state.height);\n  }\n}\n","/// <reference path='player.d.ts' />\nimport {UIManager, UIInstanceManager} from './uimanager';\nimport {Button} from './components/button';\nimport {ControlBar} from './components/controlbar';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {HugePlaybackToggleButton} from './components/hugeplaybacktogglebutton';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {SelectBox} from './components/selectbox';\nimport {ItemSelectionList} from './components/itemselectionlist';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {ToggleButton} from './components/togglebutton';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {Watermark} from './components/watermark';\nimport {UIContainer} from './components/uicontainer';\nimport {Container} from './components/container';\nimport {Label} from './components/label';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {Component} from './components/component';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {TitleBar} from './components/titlebar';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {ClickOverlay} from './components/clickoverlay';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {HugeReplayButton} from './components/hugereplaybutton';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {VolumeSlider} from './components/volumeslider';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\nimport {BackgroundColorSelectBox} from './components/subtitlesettings/backgroundcolorselectbox';\nimport {BackgroundOpacitySelectBox} from './components/subtitlesettings/backgroundopacityselectbox';\nimport {CharacterEdgeSelectBox} from './components/subtitlesettings/characteredgeselectbox';\nimport {FontColorSelectBox} from './components/subtitlesettings/fontcolorselectbox';\nimport {FontFamilySelectBox} from './components/subtitlesettings/fontfamilyselectbox';\nimport {FontOpacitySelectBox} from './components/subtitlesettings/fontopacityselectbox';\nimport {FontSizeSelectBox} from './components/subtitlesettings/fontsizeselectbox';\nimport {SubtitleSettingsButton} from './components/subtitlesettings/subtitlesettingsbutton';\nimport {SubtitleSettingsCloseButton} from './components/subtitlesettings/subtitlesettingsclosebutton';\nimport {SubtitleSettingSelectBox} from './components/subtitlesettings/subtitlesettingselectbox';\nimport {SubtitleSettingsLabel} from './components/subtitlesettings/subtitlesettingslabel';\nimport {SubtitleSettingsOpenButton} from './components/subtitlesettings/subtitlesettingsopenbutton';\nimport {SubtitleSettingsPanel} from './components/subtitlesettings/subtitlesettingspanel';\nimport {WindowColorSelectBox} from './components/subtitlesettings/windowcolorselectbox';\nimport {WindowOpacitySelectBox} from './components/subtitlesettings/windowopacityselectbox';\nimport {ArrayUtils} from './arrayutils';\nimport {StringUtils} from './stringutils';\nimport {PlayerUtils} from './playerutils';\nimport {UIUtils} from './uiutils';\nimport {BrowserUtils} from './browserutils';\nimport {StorageUtils} from './storageutils';\n// HACK: gulp-tslint fails on unused files so we need this dummy import\nimport {ArrayUtils as Dummy} from './utils'; // tslint:disable-line\nimport {SubtitleSettingsResetButton} from './components/subtitlesettings/subtitlesettingsresetbutton';\n\n// Object.assign polyfill for ES5/IE9\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign !== 'function') {\n  Object.assign = function(target: any) {\n    'use strict';\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    target = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      let source = arguments[index];\n      if (source != null) {\n        for (let key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n}\n\nconst playerui = {\n  version: '{{VERSION}}',\n  // Management\n  UIManager,\n  UIInstanceManager,\n  // Utils\n  ArrayUtils,\n  StringUtils,\n  PlayerUtils,\n  UIUtils,\n  BrowserUtils,\n  StorageUtils,\n  // Components\n  AdClickOverlay,\n  AdMessageLabel,\n  AdSkipButton,\n  AirPlayToggleButton,\n  AudioQualitySelectBox,\n  AudioTrackSelectBox,\n  BufferingOverlay,\n  Button,\n  CastStatusOverlay,\n  CastToggleButton,\n  CastUIContainer,\n  ClickOverlay,\n  CloseButton,\n  Component,\n  Container,\n  ControlBar,\n  ErrorMessageOverlay,\n  FullscreenToggleButton,\n  HugePlaybackToggleButton,\n  HugeReplayButton,\n  Label,\n  MetadataLabel,\n  MetadataLabelContent,\n  PictureInPictureToggleButton,\n  PlaybackSpeedSelectBox,\n  PlaybackTimeLabel,\n  PlaybackTimeLabelMode,\n  PlaybackToggleButton,\n  PlaybackToggleOverlay,\n  RecommendationOverlay,\n  SeekBar,\n  SeekBarLabel,\n  SelectBox,\n  ItemSelectionList,\n  SettingsPanel,\n  SettingsPanelItem,\n  SettingsToggleButton,\n  Spacer,\n  SubtitleOverlay,\n  SubtitleSelectBox,\n  TitleBar,\n  ToggleButton,\n  UIContainer,\n  VideoQualitySelectBox,\n  VolumeControlButton,\n  VolumeSlider,\n  VolumeToggleButton,\n  VRToggleButton,\n  Watermark,\n  // Subtitle related components\n  subtitlesettings: {\n    BackgroundColorSelectBox,\n    BackgroundOpacitySelectBox,\n    CharacterEdgeSelectBox,\n    FontColorSelectBox,\n    FontFamilySelectBox,\n    FontOpacitySelectBox,\n    FontSizeSelectBox,\n    SubtitleSettingsButton,\n    SubtitleSettingsCloseButton,\n    SubtitleSettingSelectBox,\n    SubtitleSettingsLabel,\n    SubtitleSettingsOpenButton,\n    SubtitleSettingsPanel,\n    WindowColorSelectBox,\n    WindowOpacitySelectBox,\n    SubtitleSettingsResetButton,\n  },\n};\n\n// Export UI as UMD module\n// This goes together with the Browserify \"--standalone bitmovin.playerui\" config option (in the gulpfile)\ndeclare const module: any;\nmodule.exports = playerui;","import {Event, EventDispatcher, NoArgs} from './eventdispatcher';\nimport {BrowserUtils} from './browserutils';\n\nexport namespace PlayerUtils {\n\n  import PlayerAPI = bitmovin.PlayerAPI;\n\n  export enum PlayerState {\n    IDLE,\n    PREPARED,\n    PLAYING,\n    PAUSED,\n    FINISHED,\n  }\n\n  export function isTimeShiftAvailable(player: bitmovin.PlayerAPI): boolean {\n    return player.isLive() && player.getMaxTimeShift() !== 0;\n  }\n\n  export function getState(player: PlayerAPI): PlayerState {\n    if (player.hasEnded()) {\n      return PlayerState.FINISHED;\n    } else if (player.isPlaying()) {\n      return PlayerState.PLAYING;\n    } else if (player.isPaused()) {\n      return PlayerState.PAUSED;\n    } else if (player.isReady()) {\n      return PlayerState.PREPARED;\n    } else {\n      return PlayerState.IDLE;\n    }\n  }\n\n  export interface TimeShiftAvailabilityChangedArgs extends NoArgs {\n    timeShiftAvailable: boolean;\n  }\n\n  export class TimeShiftAvailabilityDetector {\n\n    private player: PlayerAPI;\n    private timeShiftAvailable: boolean;\n    private timeShiftAvailabilityChangedEvent = new EventDispatcher<PlayerAPI, TimeShiftAvailabilityChangedArgs>();\n\n    constructor(player: PlayerAPI) {\n      this.player = player;\n      this.timeShiftAvailable = undefined;\n\n      let timeShiftDetector = () => {\n        this.detect();\n      };\n      // Try to detect timeshift availability in ON_READY, which works for DASH streams\n      player.addEventHandler(player.EVENT.ON_READY, timeShiftDetector);\n      // With HLS/NativePlayer streams, getMaxTimeShift can be 0 before the buffer fills, so we need to additionally\n      // check timeshift availability in ON_TIME_CHANGED\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, timeShiftDetector);\n    }\n\n    detect(): void {\n      if (this.player.isLive()) {\n        let timeShiftAvailableNow = PlayerUtils.isTimeShiftAvailable(this.player);\n\n        // When the availability changes, we fire the event\n        if (timeShiftAvailableNow !== this.timeShiftAvailable) {\n          this.timeShiftAvailabilityChangedEvent.dispatch(this.player, { timeShiftAvailable: timeShiftAvailableNow });\n          this.timeShiftAvailable = timeShiftAvailableNow;\n        }\n      }\n    }\n\n    get onTimeShiftAvailabilityChanged(): Event<PlayerAPI, TimeShiftAvailabilityChangedArgs> {\n      return this.timeShiftAvailabilityChangedEvent.getEvent();\n    }\n  }\n\n  export interface LiveStreamDetectorEventArgs extends NoArgs {\n    live: boolean;\n  }\n\n  /**\n   * Detects changes of the stream type, i.e. changes of the return value of the player#isLive method.\n   * Normally, a stream cannot change its type during playback, it's either VOD or live. Due to bugs on some\n   * platforms or browsers, it can still change. It is therefore unreliable to just check #isLive and this detector\n   * should be used as a workaround instead.\n   *\n   * Known cases:\n   *\n   * - HLS VOD on Android 4.3\n   * Video duration is initially 'Infinity' and only gets available after playback starts, so streams are wrongly\n   * reported as 'live' before playback (the live-check in the player checks for infinite duration).\n   */\n  export class LiveStreamDetector {\n\n    private player: PlayerAPI;\n    private live: boolean;\n    private liveChangedEvent = new EventDispatcher<PlayerAPI, LiveStreamDetectorEventArgs>();\n\n    constructor(player: PlayerAPI) {\n      this.player = player;\n      this.live = undefined;\n\n      let liveDetector = () => {\n        this.detect();\n      };\n      // Initialize when player is ready\n      player.addEventHandler(player.EVENT.ON_READY, liveDetector);\n      // Re-evaluate when playback starts\n      player.addEventHandler(player.EVENT.ON_PLAY, liveDetector);\n\n      // HLS live detection workaround for Android:\n      // Also re-evaluate during playback, because that is when the live flag might change.\n      // (Doing it only in Android Chrome saves unnecessary overhead on other plattforms)\n      if (BrowserUtils.isAndroid && BrowserUtils.isChrome) {\n        player.addEventHandler(player.EVENT.ON_TIME_CHANGED, liveDetector);\n      }\n    }\n\n    detect(): void {\n      let liveNow = this.player.isLive();\n\n      // Compare current to previous live state flag and fire event when it changes. Since we initialize the flag\n      // with undefined, there is always at least an initial event fired that tells listeners the live state.\n      if (liveNow !== this.live) {\n        this.liveChangedEvent.dispatch(this.player, { live: liveNow });\n        this.live = liveNow;\n      }\n    }\n\n    get onLiveChanged(): Event<PlayerAPI, LiveStreamDetectorEventArgs> {\n      return this.liveChangedEvent.getEvent();\n    }\n  }\n}","export namespace StorageUtils {\n  let hasLocalStorageCache: boolean;\n\n  export function hasLocalStorage(): boolean {\n    if (hasLocalStorageCache) {\n      return hasLocalStorageCache;\n    }\n\n    // hasLocalStorage is used to safely ensure we can use localStorage\n    // taken from https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#Feature-detecting_localStorage\n    let storage = window['localStorage'];\n    try {\n      let x = '__storage_test__';\n      storage.setItem(x, x);\n      storage.removeItem(x);\n      hasLocalStorageCache = true;\n    }\n    catch (e) {\n      hasLocalStorageCache = e instanceof DOMException && (\n          // everything except Firefox\n        e.code === 22 ||\n        // Firefox\n        e.code === 1014 ||\n        // test name field too, because code might not be present\n        // everything except Firefox\n        e.name === 'QuotaExceededError' ||\n        // Firefox\n        e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n        // acknowledge QuotaExceededError only if there's something already stored\n        storage.length !== 0;\n    }\n    return hasLocalStorageCache;\n  }\n\n  /**\n   * Stores a string item into localStorage.\n   * @param key the item's key\n   * @param data the item's data\n   */\n  export function setItem(key: string, data: string): void {\n    if (StorageUtils.hasLocalStorage()) {\n      window.localStorage.setItem(key, data);\n    }\n  }\n\n  /**\n   * Gets an item's string value from the localStorage.\n   * @param key the key to look up its associated value\n   * @return {string | null} Returns the string if found, null if there is no data stored for the key\n   */\n  export function getItem(key: string): string | null {\n    if (StorageUtils.hasLocalStorage()) {\n      return window.localStorage.getItem(key);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Stores an object into localStorage. The object will be serialized to JSON. The following types are supported\n   * in addition to the default types:\n   *  - ColorUtils.Color\n   *\n   * @param key the key to store the data to\n   * @param data the object to store\n   */\n  export function setObject<T>(key: string, data: T): void {\n    if (StorageUtils.hasLocalStorage()) {\n      let json = JSON.stringify(data);\n      setItem(key, json);\n    }\n  }\n\n  /**\n   * Gets an object for the given key from localStorage. The object will be deserialized from JSON. Beside the\n   * default types, the following types are supported:\n   *  - ColorUtils.Color\n   *\n   * @param key the key to look up its associated object\n   * @return {any} Returns the object if found, null otherwise\n   */\n  export function getObject<T>(key: string): T {\n    if (StorageUtils.hasLocalStorage()) {\n      let json = getItem(key);\n\n      if (key) {\n        let object = JSON.parse(json);\n        return <T>object;\n      }\n    }\n    return null;\n  }\n}\n","export namespace StringUtils {\n\n  export let FORMAT_HHMMSS: string = 'hh:mm:ss';\n  export let FORMAT_MMSS: string = 'mm:ss';\n\n  /**\n   * Formats a number of seconds into a time string with the pattern hh:mm:ss.\n   *\n   * @param totalSeconds the total number of seconds to format to string\n   * @param format the time format to output (default: hh:mm:ss)\n   * @returns {string} the formatted time string\n   */\n  export function secondsToTime(totalSeconds: number, format: string = FORMAT_HHMMSS): string {\n    let isNegative = totalSeconds < 0;\n\n    if (isNegative) {\n      // If the time is negative, we make it positive for the calculation below\n      // (else we'd get all negative numbers) and reattach the negative sign later.\n      totalSeconds = -totalSeconds;\n    }\n\n    // Split into separate time parts\n    let hours = Math.floor(totalSeconds / 3600);\n    let minutes = Math.floor(totalSeconds / 60) - hours * 60;\n    let seconds = Math.floor(totalSeconds) % 60;\n\n    return (isNegative ? '-' : '') + format\n        .replace('hh', leftPadWithZeros(hours, 2))\n        .replace('mm', leftPadWithZeros(minutes, 2))\n        .replace('ss', leftPadWithZeros(seconds, 2));\n  }\n\n  /**\n   * Converts a number to a string and left-pads it with zeros to the specified length.\n   * Example: leftPadWithZeros(123, 5) => '00123'\n   *\n   * @param num the number to convert to string and pad with zeros\n   * @param length the desired length of the padded string\n   * @returns {string} the padded number as string\n   */\n  function leftPadWithZeros(num: number | string, length: number): string {\n    let text = num + '';\n    let padding = '0000000000'.substr(0, length - text.length);\n    return padding + text;\n  }\n\n  /**\n   * Fills out placeholders in an ad message.\n   *\n   * Has the placeholders '{remainingTime[formatString]}', '{playedTime[formatString]}' and\n   * '{adDuration[formatString]}', which are replaced by the remaining time until the ad can be skipped, the current\n   * time or the ad duration. The format string is optional. If not specified, the placeholder is replaced by the time\n   * in seconds. If specified, it must be of the following format:\n   * - %d - Inserts the time as an integer.\n   * - %0Nd - Inserts the time as an integer with leading zeroes, if the length of the time string is smaller than N.\n   * - %f - Inserts the time as a float.\n   * - %0Nf - Inserts the time as a float with leading zeroes.\n   * - %.Mf - Inserts the time as a float with M decimal places. Can be combined with %0Nf, e.g. %04.2f (the time\n   * 10.123\n   * would be printed as 0010.12).\n   * - %hh:mm:ss\n   * - %mm:ss\n   *\n   * @param adMessage an ad message with optional placeholders to fill\n   * @param skipOffset if specified, {remainingTime} will be filled with the remaining time until the ad can be skipped\n   * @param player the player to get the time data from\n   * @returns {string} the ad message with filled placeholders\n   */\n  export function replaceAdMessagePlaceholders(adMessage: string, skipOffset: number, player: bitmovin.PlayerAPI) {\n    let adMessagePlaceholderRegex = new RegExp(\n      '\\\\{(remainingTime|playedTime|adDuration)(}|%((0[1-9]\\\\d*(\\\\.\\\\d+(d|f)|d|f)|\\\\.\\\\d+f|d|f)|hh:mm:ss|mm:ss)})',\n      'g'\n    );\n\n    return adMessage.replace(adMessagePlaceholderRegex, (formatString) => {\n      let time = 0;\n      if (formatString.indexOf('remainingTime') > -1) {\n        if (skipOffset) {\n          time = Math.ceil(skipOffset - player.getCurrentTime());\n        } else {\n          time = player.getDuration() - player.getCurrentTime();\n        }\n      } else if (formatString.indexOf('playedTime') > -1) {\n        time = player.getCurrentTime();\n      } else if (formatString.indexOf('adDuration') > -1) {\n        time = player.getDuration();\n      }\n      return formatNumber(time, formatString);\n    });\n  }\n\n  function formatNumber(time: number, format: string) {\n    let formatStringValidationRegex = /%((0[1-9]\\d*(\\.\\d+(d|f)|d|f)|\\.\\d+f|d|f)|hh:mm:ss|mm:ss)/;\n    let leadingZeroesRegex = /(%0[1-9]\\d*)(?=(\\.\\d+f|f|d))/;\n    let decimalPlacesRegex = /\\.\\d*(?=f)/;\n\n    if (!formatStringValidationRegex.test(format)) {\n      // If the format is invalid, we set a default fallback format\n      format = '%d';\n    }\n\n    // Determine the number of leading zeros\n    let leadingZeroes = 0;\n    let leadingZeroesMatches = format.match(leadingZeroesRegex);\n    if (leadingZeroesMatches) {\n      leadingZeroes = parseInt(leadingZeroesMatches[0].substring(2));\n    }\n\n    // Determine the number of decimal places\n    let numDecimalPlaces = null;\n    let decimalPlacesMatches = format.match(decimalPlacesRegex);\n    if (decimalPlacesMatches && !isNaN(parseInt(decimalPlacesMatches[0].substring(1)))) {\n      numDecimalPlaces = parseInt(decimalPlacesMatches[0].substring(1));\n      if (numDecimalPlaces > 20) {\n        numDecimalPlaces = 20;\n      }\n    }\n\n    // Float format\n    if (format.indexOf('f') > -1) {\n      let timeString = '';\n\n      if (numDecimalPlaces !== null) {\n        // Apply fixed number of decimal places\n        timeString = time.toFixed(numDecimalPlaces);\n      } else {\n        timeString = '' + time;\n      }\n\n      // Apply leading zeros\n      if (timeString.indexOf('.') > -1) {\n        return leftPadWithZeros(timeString, timeString.length + (leadingZeroes - timeString.indexOf('.')));\n      } else {\n        return leftPadWithZeros(timeString, leadingZeroes);\n      }\n\n    }\n    // Time format\n    else if (format.indexOf(':') > -1) {\n      let totalSeconds = Math.ceil(time);\n\n      // hh:mm:ss format\n      if (format.indexOf('hh') > -1) {\n        return secondsToTime(totalSeconds);\n      }\n      // mm:ss format\n      else {\n        let minutes = Math.floor(totalSeconds / 60);\n        let seconds = totalSeconds % 60;\n\n        return leftPadWithZeros(minutes, 2) + ':' + leftPadWithZeros(seconds, 2);\n      }\n    }\n    // Integer format\n    else {\n      return leftPadWithZeros(Math.ceil(time), leadingZeroes);\n    }\n  }\n}\n","// TODO change to internal (not exported) class, how to use in other files?\n/**\n * Executes a callback after a specified amount of time, optionally repeatedly until stopped.\n */\nexport class Timeout {\n\n  private delay: number;\n  private callback: () => void;\n  private repeat: boolean;\n  // There's two setTimeout declarations, one on Window which returns type \"number\" and one in NodeJS which returns\n  // type \"Timer\". For unknown reasons builds on Jenkins fail due to a type mismatch when we use type \"number\" here,\n  // although it works on other platforms (e.g. Windows, Codeship).\n  // To work around the issue we use type \"any\". The type does not matter anyway because we're not working with\n  // this value except providing it to clearTimeout.\n  private timeoutHandle: any;\n\n  /**\n   * Creates a new timeout callback handler.\n   * @param delay the delay in milliseconds after which the callback should be executed\n   * @param callback the callback to execute after the delay time\n   * @param repeat if true, call the callback repeatedly in delay intervals\n   */\n  constructor(delay: number, callback: () => void, repeat: boolean = false) {\n    this.delay = delay;\n    this.callback = callback;\n    this.repeat = repeat;\n    this.timeoutHandle = 0;\n  }\n\n  /**\n   * Starts the timeout and calls the callback when the timeout delay has passed.\n   * @returns {Timeout} the current timeout (so the start call can be chained to the constructor)\n   */\n  start(): this {\n    this.reset();\n    return this;\n  }\n\n  /**\n   * Clears the timeout. The callback will not be called if clear is called during the timeout.\n   */\n  clear(): void {\n    this.clearInternal();\n  }\n\n  /**\n   * Resets the passed timeout delay to zero. Can be used to defer the calling of the callback.\n   */\n  reset(): void {\n    let lastScheduleTime = 0;\n    let delayAdjust = 0;\n\n    this.clearInternal();\n\n    let internalCallback = () => {\n      this.callback();\n\n      if (this.repeat) {\n        let now = Date.now();\n\n        // The time of one iteration from scheduling to executing the callback (usually a bit longer than the delay\n        // time)\n        let delta = now - lastScheduleTime;\n\n        // Calculate the delay adjustment for the next schedule to keep a steady delay interval over time\n        delayAdjust = this.delay - delta + delayAdjust;\n\n        lastScheduleTime = now;\n\n        // Schedule next execution by the adjusted delay\n        this.timeoutHandle = setTimeout(internalCallback, this.delay + delayAdjust);\n      }\n    };\n\n    lastScheduleTime = Date.now();\n    this.timeoutHandle = setTimeout(internalCallback, this.delay);\n  }\n\n  private clearInternal(): void {\n    clearTimeout(this.timeoutHandle);\n  }\n}","import {UIContainer} from './components/uicontainer';\nimport {DOM} from './dom';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport { SeekBar, SeekBarMarker } from './components/seekbar';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {ControlBar} from './components/controlbar';\nimport {NoArgs, EventDispatcher, CancelEventArgs} from './eventdispatcher';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {SubtitleSettingsPanel} from './components/subtitlesettings/subtitlesettingspanel';\nimport {SubtitleSettingsLabel} from './components/subtitlesettings/subtitlesettingslabel';\nimport {SubtitleSettingsOpenButton} from './components/subtitlesettings/subtitlesettingsopenbutton';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\n// import {Watermark} from './components/watermark';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {VolumeSlider} from './components/volumeslider';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\n// import {VolumeControlButton} from './components/volumecontrolbutton';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {TitleBar} from './components/titlebar';\nimport PlayerAPI = bitmovin.PlayerAPI;\nimport {RecommendationOverlay} from './components/recommendationoverlay';\n// import {AdMessageLabel} from './components/admessagelabel';\n// import {AdSkipButton} from './components/adskipbutton';\n// import {AdClickOverlay} from './components/adclickoverlay';\nimport EVENT = bitmovin.PlayerAPI.EVENT;\nimport PlayerEventCallback = bitmovin.PlayerAPI.PlayerEventCallback;\nimport AdStartedEvent = bitmovin.PlayerAPI.AdStartedEvent;\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {BufferingOverlay} from './components/bufferingoverlay';\n// import {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\n// import {Label} from './components/label';\nimport PlayerEvent = bitmovin.PlayerAPI.PlayerEvent;\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {AudioOnlyOverlay} from './components/audioonlyoverlay';\nimport {Spacer} from './components/spacer';\nimport {UIUtils} from './uiutils';\nimport {ArrayUtils} from './arrayutils';\nimport {BrowserUtils} from './browserutils';\n\nexport interface UIRecommendationConfig {\n  title: string;\n  url: string;\n  thumbnail?: string;\n  duration?: number;\n}\n\n/**\n * Marks a position on the playback timeline, e.g. a chapter or an ad break.\n */\nexport interface TimelineMarker {\n  /**\n   * The time in the playback timeline (e.g. {@link SeekBar}) that should be marked.\n   */\n  time: number;\n  /**\n   * Optional duration that makes the marker mark an interval instead of a single moment in time.\n   */\n  duration?: number;\n  /**\n   * Optional title text of the marked position, e.g. a chapter name.\n   * Will be rendered in the {@link SeekBarLabel} attached to a {@link SeekBar}.\n   */\n  title?: string;\n  /**\n   * Optional CSS classes that are applied to the marker on a {@link SeekBar} and can be used to\n   * differentiate different types of markers by their style (e.g. different color of chapter markers\n   * and ad break markers).\n   * The CSS classes are also propagated to a connected {@link SeekBarLabel}.\n   *\n   * Multiple classes can be added to allow grouping of markers into types (e.g. chapter markers,\n   * ad break markers) by a shared class and still identify and style each marker with distinct\n   * classes (e.g. `['marker-type-chapter', 'chapter-number-1']`).\n   */\n  cssClasses?: string[];\n}\n\nexport interface UIConfig {\n  /**\n   * Specifies the container in the DOM into which the UI will be added. Can be a CSS selector string or a\n   * HTMLElement object. By default, the player figure will be used ({@link PlayerAPI#getFigure}).\n   */\n  container?: string | HTMLElement;\n  metadata?: {\n    title?: string;\n    description?: string;\n    markers?: TimelineMarker[];\n  };\n  // TODO move recommendations into metadata in next major release\n  recommendations?: UIRecommendationConfig[];\n  /**\n   * Specifies if the UI variants should be resolved and switched automatically upon certain player events. The default\n   * is `true`. Should be set to `false` if purely manual switching through {@link UIManager.resolveUiVariant} is\n   * desired. A hybrid approach can be used by setting this to `true` (or leaving the default) and overriding\n   * automatic switches through a {@link UIManager.onUiVariantResolve} event handler.\n   */\n  autoUiVariantResolve?: boolean;\n}\n\nexport interface InternalUIConfig extends UIConfig {\n  events: {\n    /**\n     * Fires when the configuration has been updated/changed.\n     */\n    onUpdated: EventDispatcher<UIManager, void>;\n  };\n}\n\n/**\n * The context that will be passed to a {@link UIConditionResolver} to determine if it's conditions fulfil the context.\n */\nexport interface UIConditionContext {\n  /**\n   * Tells if the player is loading or playing an ad.\n   */\n  isAd: boolean;\n  /**\n   * Tells if the ad allows a UI. This is currently only true for VAST ads and cannot be used to differentiate between\n   * different ad clients (i.e. to display different UIs for different ad clients).\n   * @deprecated Will be removed in an upcoming major release, use {@link #adClientType} instead.\n   */\n  isAdWithUI: boolean;\n  /**\n   * Tells the ad client (e.g. 'vast, 'ima') if {@link #isAd} is true.\n   */\n  adClientType: string;\n  /**\n   * Tells if the player is currently in fullscreen mode.\n   */\n  isFullscreen: boolean;\n  /**\n   * Tells if the UI is running in a mobile browser.\n   */\n  isMobile: boolean;\n  /**\n   * Tells if the player is in playing or paused state.\n   */\n  isPlaying: boolean;\n  /**\n   * The width of the player/UI element.\n   */\n  width: number;\n  /**\n   * The width of the document where the player/UI is embedded in.\n   */\n  documentWidth: number;\n}\n\n/**\n * Resolves the conditions of its associated UI in a {@link UIVariant} upon a {@link UIConditionContext} and decides\n * if the UI should be displayed. If it returns true, the UI is a candidate for display; if it returns false, it will\n * not be displayed in the given context.\n */\nexport interface UIConditionResolver {\n  (context: UIConditionContext): boolean;\n}\n\n/**\n * Associates a UI instance with an optional {@link UIConditionResolver} that determines if the UI should be displayed.\n */\nexport interface UIVariant {\n  ui: UIContainer;\n  condition?: UIConditionResolver;\n}\n\nexport class UIManager {\n\n  private player: PlayerAPI;\n  private uiContainerElement: DOM;\n  private uiVariants: UIVariant[];\n  private uiInstanceManagers: InternalUIInstanceManager[];\n  private currentUi: InternalUIInstanceManager;\n  private config: InternalUIConfig;\n  private managerPlayerWrapper: PlayerWrapper;\n\n  private events = {\n    onUiVariantResolve: new EventDispatcher<UIManager, UIConditionContext>(),\n  };\n\n  /**\n   * Creates a UI manager with a single UI variant that will be permanently shown.\n   * @param player the associated player of this UI\n   * @param ui the UI to add to the player\n   * @param config optional UI configuration\n   */\n  constructor(player: PlayerAPI, ui: UIContainer, config?: UIConfig);\n  /**\n   * Creates a UI manager with a list of UI variants that will be dynamically selected and switched according to\n   * the context of the UI.\n   *\n   * Every time the UI context changes, the conditions of the UI variants will be sequentially resolved and the first\n   * UI, whose condition evaluates to true, will be selected and displayed. The last variant in the list might omit the\n   * condition resolver and will be selected as default/fallback UI when all other conditions fail. If there is no\n   * fallback UI and all conditions fail, no UI will be displayed.\n   *\n   * @param player the associated player of this UI\n   * @param uiVariants a list of UI variants that will be dynamically switched\n   * @param config optional UI configuration\n   */\n  constructor(player: PlayerAPI, uiVariants: UIVariant[], config?: UIConfig);\n  constructor(player: PlayerAPI, playerUiOrUiVariants: UIContainer | UIVariant[], config: UIConfig = {}) {\n    if (playerUiOrUiVariants instanceof UIContainer) {\n      // Single-UI constructor has been called, transform arguments to UIVariant[] signature\n      let playerUi = <UIContainer>playerUiOrUiVariants;\n      let uiVariants = [];\n\n      // Add the default player UI\n      uiVariants.push({ ui: playerUi });\n\n      this.uiVariants = uiVariants;\n    }\n    else {\n      // Default constructor (UIVariant[]) has been called\n      this.uiVariants = <UIVariant[]>playerUiOrUiVariants;\n    }\n\n    this.player = player;\n    this.config = {\n      ...config,\n      events: {\n        onUpdated: new EventDispatcher<UIManager, void>(),\n      },\n    };\n    this.managerPlayerWrapper = new PlayerWrapper(player);\n\n    /**\n     * Gathers configuration data from the UI config and player source config and creates a merged UI config\n     * that is used throughout the UI instance.\n     */\n    const updateConfig = () => {\n      const playerSourceConfig = player.getConfig().source || {};\n\n      const uiConfig = { ...config };\n      uiConfig.metadata = uiConfig.metadata || {};\n\n      // Extract the UI-related config properties from the source config\n      const playerSourceUiConfig: UIConfig = {\n        metadata: {\n          // TODO move metadata into source.metadata namespace in player v8\n          title: playerSourceConfig.title,\n          description: playerSourceConfig.description,\n          markers: playerSourceConfig.markers,\n        },\n        recommendations: playerSourceConfig.recommendations,\n      };\n\n      // Player source config takes precedence over the UI config, because the config in the source is attached\n      // to a source which changes with every player.load, whereas the UI config stays the same for the whole\n      // lifetime of the player instance.\n      this.config.metadata = this.config.metadata || {};\n      this.config.metadata.title = playerSourceUiConfig.metadata.title || uiConfig.metadata.title;\n      this.config.metadata.description = playerSourceUiConfig.metadata.description || uiConfig.metadata.description;\n      this.config.metadata.markers = playerSourceUiConfig.metadata.markers || uiConfig.metadata.markers || [];\n      this.config.recommendations = playerSourceUiConfig.recommendations || uiConfig.recommendations || [];\n    };\n\n    updateConfig();\n\n    // Update the configuration when a new source is loaded\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_SOURCE_LOADED, () => {\n      updateConfig();\n      this.config.events.onUpdated.dispatch(this);\n    });\n\n    if (config.container) {\n      // Unfortunately \"uiContainerElement = new DOM(config.container)\" will not accept the container with\n      // string|HTMLElement type directly, although it accepts both types, so we need to spit these two cases up here.\n      // TODO check in upcoming TS versions if the container can be passed in directly, or fix the constructor\n      this.uiContainerElement = config.container instanceof HTMLElement ?\n        new DOM(config.container) : new DOM(config.container);\n    } else {\n      this.uiContainerElement = new DOM(player.getFigure());\n    }\n\n    // Create UI instance managers for the UI variants\n    // The instance managers map to the corresponding UI variants by their array index\n    this.uiInstanceManagers = [];\n    let uiVariantsWithoutCondition = [];\n    for (let uiVariant of this.uiVariants) {\n      if (uiVariant.condition == null) {\n        // Collect variants without conditions for error checking\n        uiVariantsWithoutCondition.push(uiVariant);\n      }\n      // Create the instance manager for a UI variant\n      this.uiInstanceManagers.push(new InternalUIInstanceManager(player, uiVariant.ui, this.config));\n    }\n    // Make sure that there is only one UI variant without a condition\n    // It does not make sense to have multiple variants without condition, because only the first one in the list\n    // (the one with the lowest index) will ever be selected.\n    if (uiVariantsWithoutCondition.length > 1) {\n      throw Error('Too many UIs without a condition: You cannot have more than one default UI');\n    }\n    // Make sure that the default UI variant, if defined, is at the end of the list (last index)\n    // If it comes earlier, the variants with conditions that come afterwards will never be selected because the\n    // default variant without a condition always evaluates to 'true'\n    if (uiVariantsWithoutCondition.length > 0\n      && uiVariantsWithoutCondition[0] !== this.uiVariants[this.uiVariants.length - 1]) {\n      throw Error('Invalid UI variant order: the default UI (without condition) must be at the end of the list');\n    }\n\n    // Switch on auto UI resolving by default\n    if (config.autoUiVariantResolve === undefined) {\n      config.autoUiVariantResolve = true;\n    }\n\n    let adStartedEvent: AdStartedEvent = null; // keep the event stored here during ad playback\n\n    // Dynamically select a UI variant that matches the current UI condition.\n    let resolveUiVariant = (event: PlayerEvent) => {\n      // Make sure that the ON_AD_STARTED event data is persisted through ad playback in case other events happen\n      // in the meantime, e.g. player resize. We need to store this data because there is no other way to find out\n      // ad details (e.g. the ad client) while an ad is playing.\n      // Existing event data signals that an ad is currently active. We cannot use player.isAd() because it returns\n      // true on ad start and also on ad end events, which is problematic.\n      if (event != null) {\n        switch (event.type) {\n          // When the ad starts, we store the event data\n          case player.EVENT.ON_AD_STARTED:\n            adStartedEvent = <AdStartedEvent>event;\n            break;\n          // When the ad ends, we delete the event data\n          case player.EVENT.ON_AD_FINISHED:\n          case player.EVENT.ON_AD_SKIPPED:\n          case player.EVENT.ON_AD_ERROR:\n            adStartedEvent = null;\n            break;\n          // When a new source is loaded during ad playback, there will be no ad end event so we detect the end\n          // of the ad playback by checking isAd() in ON_READY, because ON_READY always arrives when the source\n          // changes.\n          case player.EVENT.ON_READY:\n            if (adStartedEvent && !player.isAd()) {\n              adStartedEvent = null;\n            }\n        }\n      }\n\n      // Detect if an ad has started\n      let ad = adStartedEvent != null;\n      let adWithUI = ad && adStartedEvent.clientType === 'vast';\n\n      this.resolveUiVariant({\n        isAd: ad,\n        isAdWithUI: adWithUI,\n        adClientType: ad ? adStartedEvent.clientType : null,\n      }, (context) => {\n        // If this is an ad UI, we need to relay the saved ON_AD_STARTED event data so ad components can configure\n        // themselves for the current ad.\n        if (context.isAd) {\n          /* Relay the ON_AD_STARTED event to the ads UI\n           *\n           * Because the ads UI is initialized in the ON_AD_STARTED handler, i.e. when the ON_AD_STARTED event has\n           * already been fired, components in the ads UI that listen for the ON_AD_STARTED event never receive it.\n           * Since this can break functionality of components that rely on this event, we relay the event to the\n           * ads UI components with the following call.\n           */\n          this.currentUi.getWrappedPlayer().fireEventInUI(this.player.EVENT.ON_AD_STARTED, adStartedEvent);\n        }\n      });\n    };\n\n    // Listen to the following events to trigger UI variant resolution\n    if (config.autoUiVariantResolve) {\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_READY, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PLAY, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PAUSED, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_STARTED, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_FINISHED, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_SKIPPED, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_ERROR, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PLAYER_RESIZE, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_ENTER, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_EXIT, resolveUiVariant);\n    }\n\n    // Initialize the UI\n    resolveUiVariant(null);\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  /**\n   * Returns the list of UI variants as passed into the constructor of {@link UIManager}.\n   * @returns {UIVariant[]} the list of available UI variants\n   */\n  getUiVariants(): UIVariant[] {\n    return this.uiVariants;\n  }\n\n  /**\n   * Switches to a UI variant from the list returned by {@link getUiVariants}.\n   * @param {UIVariant} uiVariant the UI variant to switch to\n   * @param {() => void} onShow a callback that is executed just before the new UI variant is shown\n   */\n  switchToUiVariant(uiVariant: UIVariant, onShow?: () => void): void {\n    let uiVariantIndex = this.uiVariants.indexOf(uiVariant);\n\n    const nextUi: InternalUIInstanceManager = this.uiInstanceManagers[uiVariantIndex];\n    let uiVariantChanged = false;\n\n    // Determine if the UI variant is changing\n    if (nextUi !== this.currentUi) {\n      uiVariantChanged = true;\n      // console.log('switched from ', this.currentUi ? this.currentUi.getUI() : 'none',\n      //   ' to ', nextUi ? nextUi.getUI() : 'none');\n    }\n\n    // Only if the UI variant is changing, we need to do some stuff. Else we just leave everything as-is.\n    if (uiVariantChanged) {\n      // Hide the currently active UI variant\n      if (this.currentUi) {\n        this.currentUi.getUI().hide();\n      }\n\n      // Assign the new UI variant as current UI\n      this.currentUi = nextUi;\n\n      // When we switch to a different UI instance, there's some additional stuff to manage. If we do not switch\n      // to an instance, we're done here.\n      if (this.currentUi != null) {\n        // Add the UI to the DOM (and configure it) the first time it is selected\n        if (!this.currentUi.isConfigured()) {\n          this.addUi(this.currentUi);\n        }\n\n        if (onShow) {\n          onShow();\n        }\n\n        this.currentUi.getUI().show();\n      }\n    }\n  }\n\n  /**\n   * Triggers a UI variant switch as triggered by events when automatic switching is enabled. It allows to overwrite\n   * properties of the {@link UIConditionContext}.\n   * @param {Partial<UIConditionContext>} context an optional set of properties that overwrite properties of the\n   *   automatically determined context\n   * @param {(context: UIConditionContext) => void} onShow a callback that is executed just before the new UI variant\n   *   is shown (if a switch is happening)\n   */\n  resolveUiVariant(context: Partial<UIConditionContext> = {}, onShow?: (context: UIConditionContext) => void): void {\n    // Determine the current context for which the UI variant will be resolved\n    const defaultContext: UIConditionContext = {\n      isAd: false,\n      isAdWithUI: false,\n      adClientType: null,\n      isFullscreen: this.player.isFullscreen(),\n      isMobile: BrowserUtils.isMobile,\n      isPlaying: this.player.isPlaying(),\n      width: this.uiContainerElement.width(),\n      documentWidth: document.body.clientWidth,\n    };\n\n    // Overwrite properties of the default context with passed in context properties\n    const switchingContext = { ...defaultContext, ...context };\n\n    // Fire the event and allow modification of the context before it is used to resolve the UI variant\n    this.events.onUiVariantResolve.dispatch(this, switchingContext);\n\n    let nextUiVariant: UIVariant = null;\n\n    // Select new UI variant\n    // If no variant condition is fulfilled, we switch to *no* UI\n    for (let uiVariant of this.uiVariants) {\n      if (uiVariant.condition == null || uiVariant.condition(switchingContext) === true) {\n        nextUiVariant = uiVariant;\n        break;\n      }\n    }\n\n    this.switchToUiVariant(nextUiVariant, () => {\n      if (onShow) {\n        onShow(switchingContext);\n      }\n    });\n  }\n\n  private addUi(ui: InternalUIInstanceManager): void {\n    let dom = ui.getUI().getDomElement();\n    let player = ui.getWrappedPlayer();\n\n    ui.configureControls();\n    /* Append the UI DOM after configuration to avoid CSS transitions at initialization\n     * Example: Components are hidden during configuration and these hides may trigger CSS transitions that are\n     * undesirable at this time. */\n    this.uiContainerElement.append(dom);\n\n    // Some components initialize their state on ON_READY. When the UI is loaded after the player is already ready,\n    // they will never receive the event so we fire it from here in such cases.\n    if (player.isReady()) {\n      player.fireEventInUI(player.EVENT.ON_READY, {});\n    }\n\n    // Fire onConfigured after UI DOM elements are successfully added. When fired immediately, the DOM elements\n    // might not be fully configured and e.g. do not have a size.\n    // https://swizec.com/blog/how-to-properly-wait-for-dom-elements-to-show-up-in-modern-browsers/swizec/6663\n    if (window.requestAnimationFrame) {\n      requestAnimationFrame(() => { ui.onConfigured.dispatch(ui.getUI()); });\n    } else {\n      // IE9 fallback\n      setTimeout(() => { ui.onConfigured.dispatch(ui.getUI()); }, 0);\n    }\n  }\n\n  private releaseUi(ui: InternalUIInstanceManager): void {\n    ui.releaseControls();\n    ui.getUI().getDomElement().remove();\n    ui.clearEventHandlers();\n  }\n\n  release(): void {\n    for (let uiInstanceManager of this.uiInstanceManagers) {\n      this.releaseUi(uiInstanceManager);\n    }\n    this.managerPlayerWrapper.clearEventHandlers();\n  }\n\n  /**\n   * Fires just before UI variants are about to be resolved and the UI variant is possibly switched. It is fired when\n   * the switch is triggered from an automatic switch and when calling {@link resolveUiVariant}.\n   * Can be used to modify the {@link UIConditionContext} before resolving is done.\n   * @returns {EventDispatcher<UIManager, UIConditionContext>}\n   */\n  get onUiVariantResolve(): EventDispatcher<UIManager, UIConditionContext> {\n    return this.events.onUiVariantResolve;\n  }\n\n  /**\n   * Returns the list of all added markers in undefined order.\n   */\n  getTimelineMarkers(): TimelineMarker[] {\n    return this.config.metadata.markers;\n  }\n\n  /**\n   * Adds a marker to the timeline. Does not check for duplicates/overlaps at the `time`.\n   */\n  addTimelineMarker(timelineMarker: TimelineMarker): void {\n    this.config.metadata.markers.push(timelineMarker);\n    this.config.events.onUpdated.dispatch(this);\n  }\n\n  /**\n   * Removes a marker from the timeline (by reference) and returns `true` if the marker has\n   * been part of the timeline and successfully removed, or `false` if the marker could not\n   * be found and thus not removed.\n   */\n  removeTimelineMarker(timelineMarker: TimelineMarker): boolean {\n    if (ArrayUtils.remove(this.config.metadata.markers, timelineMarker) === timelineMarker) {\n      this.config.events.onUpdated.dispatch(this);\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport namespace UIManager.Factory {\n\n  export function buildAudioVideoUI(player: PlayerAPI, config: UIConfig = {}): UIManager {    // show smallScreen UI only on mobile/handheld devices\n    let smallScreenSwitchWidth = 600;\n\n    return new UIManager(player, [{\n      ui: modernSmallScreenUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n      },\n    }, {\n      ui: modernUI(),\n    }], config);\n  }\n\n  export function buildAudioOnlyUI(player: PlayerAPI, config: UIConfig = {}): UIManager {   // show smallScreen UI only on mobile/handheld devices\n    let smallScreenSwitchWidth = 600;\n\n    return new UIManager(player, [{\n      ui: modernAudioOnlySmallScreenUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n      },\n    }, {\n      ui: modernAudioOnlyUI(),\n    }], config);\n  }\n\n  // export function buildDefaultUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return UIManager.Factory.buildModernUI(player, config);\n  // }\n\n  // export function buildDefaultSmallScreenUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return UIManager.Factory.buildModernSmallScreenUI(player, config);\n  // }\n\n  // export function buildDefaultCastReceiverUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return UIManager.Factory.buildModernCastReceiverUI(player, config);\n  // }\n\n  function modernUI() {\n    let subtitleOverlay = new SubtitleOverlay();\n\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n      ],\n      hidden: true,\n    });\n\n    let subtitleSettingsPanel = new SubtitleSettingsPanel({\n      hidden: true,\n      overlay: subtitleOverlay,\n      settingsPanel: settingsPanel,\n    });\n\n    let subtitleSettingsOpenButton = new SubtitleSettingsOpenButton({\n      subtitleSettingsPanel: subtitleSettingsPanel,\n      settingsPanel: settingsPanel,\n    });\n\n    settingsPanel.addComponent(\n      new SettingsPanelItem(\n        new SubtitleSettingsLabel({text: 'Subtitles', opener: subtitleSettingsOpenButton}),\n        new SubtitleSelectBox()\n    ));\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        subtitleSettingsPanel,\n        new Container({\n          components: [\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true }),\n            new SeekBar({ label: new SeekBarLabel() }),\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right'] }),\n          ],\n          cssClasses: ['controlbar-top'],\n        }),\n        new Container({\n          components: [\n            new PlaybackToggleButton(),\n            new VolumeToggleButton(),\n            new VolumeSlider(),\n            new Spacer(),\n            new PictureInPictureToggleButton(),\n            new AirPlayToggleButton(),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new SettingsToggleButton({ settingsPanel: settingsPanel }),\n            new FullscreenToggleButton(),\n          ],\n          cssClasses: ['controlbar-bottom'],\n        }),\n      ],\n    });\n\n    return new UIContainer({\n      components: [\n        subtitleOverlay,\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new CastStatusOverlay(),\n        controlBar,\n        // new TitleBar(),\n        new RecommendationOverlay(),\n        // new Watermark(),\n        new ErrorMessageOverlay(),\n      ],\n      cssClasses: ['ui-skin-mi-wbc'],\n    });\n  }\n\n  function modernAudioOnlyUI() {\n    let subtitleOverlay = new SubtitleOverlay();\n\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n      ],\n      hidden: true,\n    });\n\n    let subtitleSettingsPanel = new SubtitleSettingsPanel({\n      hidden: true,\n      overlay: subtitleOverlay,\n      settingsPanel: settingsPanel,\n    });\n\n    let subtitleSettingsOpenButton = new SubtitleSettingsOpenButton({\n      subtitleSettingsPanel: subtitleSettingsPanel,\n      settingsPanel: settingsPanel,\n    });\n\n    settingsPanel.addComponent(\n      new SettingsPanelItem(\n        new SubtitleSettingsLabel({text: 'Subtitles', opener: subtitleSettingsOpenButton}),\n        new SubtitleSelectBox()\n    ));\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        subtitleSettingsPanel,\n        new Container({\n          components: [\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true }),\n            new SeekBar({ label: new SeekBarLabel() }),\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right'] }),\n          ],\n          cssClasses: ['controlbar-top'],\n        }),\n        new Container({\n          components: [\n            new PlaybackToggleButton(),\n            new VolumeToggleButton(),\n            new VolumeSlider(),\n            new Spacer(),\n            new AirPlayToggleButton(),\n            new CastToggleButton(),\n            new SettingsToggleButton({ settingsPanel: settingsPanel }),\n            new FullscreenToggleButton(),\n          ],\n          cssClasses: ['controlbar-bottom'],\n        }),\n      ],\n    });\n\n    return new UIContainer({\n      components: [\n        new AudioOnlyOverlay(),\n        subtitleOverlay,\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new CastStatusOverlay(),\n        controlBar,\n        // new TitleBar(),\n        new RecommendationOverlay(),\n        // new Watermark(),\n        new ErrorMessageOverlay(),\n      ],\n      cssClasses: ['ui-skin-mi-wbc'],\n    });\n  }\n  // function modernAdsUI() {\n  //   return new UIContainer({\n  //     components: [\n  //       new BufferingOverlay(),\n  //       new AdClickOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new Container({\n  //         components: [\n  //           new AdMessageLabel({ text: 'Ad: {remainingTime} secs' }),\n  //           new AdSkipButton(),\n  //         ],\n  //         cssClass: 'ui-ads-status',\n  //       }),\n  //       new ControlBar({\n  //         components: [\n  //           new Container({\n  //             components: [\n  //               new PlaybackToggleButton(),\n  //               new VolumeToggleButton(),\n  //               new VolumeSlider(),\n  //               new Spacer(),\n  //               new FullscreenToggleButton(),\n  //             ],\n  //             cssClasses: ['controlbar-bottom'],\n  //           }),\n  //         ],\n  //       }),\n  //     ],\n  //     cssClasses: ['ui-skin-mi-wbc', 'ui-skin-ads'],\n  //   });\n  // }\n\n  function modernSmallScreenUI() {\n    let subtitleOverlay = new SubtitleOverlay();\n\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n      ],\n      hidden: true,\n      hideDelay: -1,\n    });\n\n    let subtitleSettingsPanel = new SubtitleSettingsPanel({\n      hidden: true,\n      hideDelay: -1,\n      overlay: subtitleOverlay,\n      settingsPanel: settingsPanel,\n    });\n\n    let subtitleSettingsOpenButton = new SubtitleSettingsOpenButton({\n      subtitleSettingsPanel: subtitleSettingsPanel,\n      settingsPanel: settingsPanel,\n    });\n\n    settingsPanel.addComponent(\n      new SettingsPanelItem(\n        new SubtitleSettingsLabel({text: 'Subtitles', opener: subtitleSettingsOpenButton}),\n        new SubtitleSelectBox()\n    ));\n\n    settingsPanel.addComponent(new CloseButton({ target: settingsPanel }));\n    subtitleSettingsPanel.addComponent(new CloseButton({ target: subtitleSettingsPanel }));\n\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true }),\n            new SeekBar({ label: new SeekBarLabel() }),\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right'] }),\n          ],\n          cssClasses: ['controlbar-top'],\n        }),\n      ],\n    });\n\n    return new UIContainer({\n      components: [\n        subtitleOverlay,\n        new BufferingOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar({\n          components: [\n            new MetadataLabel({ content: MetadataLabelContent.Title }),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new VolumeToggleButton(),\n            new SettingsToggleButton({ settingsPanel: settingsPanel }),\n            new FullscreenToggleButton(),\n          ],\n        }),\n        settingsPanel,\n        subtitleSettingsPanel,\n        new RecommendationOverlay(),\n        // new Watermark(),\n        new ErrorMessageOverlay(),\n      ],\n      cssClasses: ['ui-skin-mi-wbc', 'ui-skin-smallscreen'],\n    });\n  }\n\n  function modernAudioOnlySmallScreenUI() {\n    let subtitleOverlay = new SubtitleOverlay();\n\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n      ],\n      hidden: true,\n      hideDelay: -1,\n    });\n\n    let subtitleSettingsPanel = new SubtitleSettingsPanel({\n      hidden: true,\n      hideDelay: -1,\n      overlay: subtitleOverlay,\n      settingsPanel: settingsPanel,\n    });\n\n    let subtitleSettingsOpenButton = new SubtitleSettingsOpenButton({\n      subtitleSettingsPanel: subtitleSettingsPanel,\n      settingsPanel: settingsPanel,\n    });\n\n    settingsPanel.addComponent(\n      new SettingsPanelItem(\n        new SubtitleSettingsLabel({text: 'Subtitles', opener: subtitleSettingsOpenButton}),\n        new SubtitleSelectBox()\n    ));\n\n    settingsPanel.addComponent(new CloseButton({ target: settingsPanel }));\n    subtitleSettingsPanel.addComponent(new CloseButton({ target: subtitleSettingsPanel }));\n\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true }),\n            new SeekBar({ label: new SeekBarLabel() }),\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right'] }),\n          ],\n          cssClasses: ['controlbar-top'],\n        }),\n      ],\n    });\n\n    return new UIContainer({\n      components: [\n        new AudioOnlyOverlay(),\n        subtitleOverlay,\n        new BufferingOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar({\n          components: [\n            new MetadataLabel({ content: MetadataLabelContent.Title }),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new VolumeToggleButton(),\n            new SettingsToggleButton({ settingsPanel: settingsPanel }),\n            new FullscreenToggleButton(),\n          ],\n        }),\n        settingsPanel,\n        subtitleSettingsPanel,\n        new RecommendationOverlay(),\n        // new Watermark(),\n        new ErrorMessageOverlay(),\n      ],\n      cssClasses: ['ui-skin-mi-wbc', 'ui-skin-smallscreen'],\n    });\n  }\n\n  // function modernSmallScreenAdsUI() {\n  //   return new UIContainer({\n  //     components: [\n  //       new BufferingOverlay(),\n  //       new AdClickOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new TitleBar({\n  //         components: [\n  //           // dummy label with no content to move buttons to the right\n  //           new Label({ cssClass: 'label-metadata-title' }),\n  //           new FullscreenToggleButton(),\n  //         ],\n  //       }),\n  //       new Container({\n  //         components: [\n  //           new AdMessageLabel({ text: 'Ad: {remainingTime} secs' }),\n  //           new AdSkipButton(),\n  //         ],\n  //         cssClass: 'ui-ads-status',\n  //       }),\n  //     ],\n  //     cssClasses: ['ui-skin-mi-wbc', 'ui-skin-ads', 'ui-skin-smallscreen'],\n  //   });\n  // }\n\n  // function modernCastReceiverUI() {\n  //   let controlBar = new ControlBar({\n  //     components: [\n  //       new Container({\n  //         components: [\n  //           new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true }),\n  //           new SeekBar({ smoothPlaybackPositionUpdateIntervalMs: -1 }),\n  //           new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right'] }),\n  //         ],\n  //         cssClasses: ['controlbar-top'],\n  //       }),\n  //     ],\n  //   });\n\n  //   return new CastUIContainer({\n  //     components: [\n  //       new SubtitleOverlay(),\n  //       new BufferingOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new Watermark(),\n  //       controlBar,\n  //       new TitleBar({ keepHiddenWithoutMetadata: true }),\n  //       new ErrorMessageOverlay(),\n  //     ],\n  //     cssClasses: ['ui-skin-mi-wbc', 'ui-skin-cast-receiver'],\n  //   });\n  // }\n\n  // export function buildModernUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   // show smallScreen UI only on mobile/handheld devices\n  //   let smallScreenSwitchWidth = 600;\n\n  //   return new UIManager(player, [{\n  //     ui: modernSmallScreenAdsUI(),\n  //     condition: (context: UIConditionContext) => {\n  //       return context.isMobile && context.documentWidth < smallScreenSwitchWidth && context.isAdWithUI;\n  //     },\n  //   }, {\n  //     ui: modernAdsUI(),\n  //     condition: (context: UIConditionContext) => {\n  //       return context.isAdWithUI;\n  //     },\n  //   }, {\n  //     ui: modernSmallScreenUI(),\n  //     condition: (context: UIConditionContext) => {\n  //       return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n  //     },\n  //   }, {\n  //     ui: modernUI(),\n  //   }], config);\n  // }\n\n  // export function buildModernSmallScreenUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return new UIManager(player, [{\n  //     ui: modernSmallScreenAdsUI(),\n  //     condition: (context: UIConditionContext) => {\n  //       return context.isAdWithUI;\n  //     },\n  //   }, {\n  //     ui: modernSmallScreenUI(),\n  //   }], config);\n  // }\n\n  // export function buildModernCastReceiverUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return new UIManager(player, modernCastReceiverUI(), config);\n  // }\n\n  // function legacyUI() {\n  //   let settingsPanel = new SettingsPanel({\n  //     components: [\n  //       new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n  //       new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n  //       new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n  //       new SettingsPanelItem('Subtitles', new SubtitleSelectBox()),\n  //     ],\n  //     hidden: true,\n  //   });\n\n  //   let controlBar = new ControlBar({\n  //     components: [\n  //       settingsPanel,\n  //       new PlaybackToggleButton(),\n  //       new SeekBar({ label: new SeekBarLabel() }),\n  //       new PlaybackTimeLabel(),\n  //       new VRToggleButton(),\n  //       new VolumeControlButton(),\n  //       new SettingsToggleButton({ settingsPanel: settingsPanel }),\n  //       new CastToggleButton(),\n  //       new FullscreenToggleButton(),\n  //     ],\n  //   });\n\n  //   return new UIContainer({\n  //     components: [\n  //       new SubtitleOverlay(),\n  //       new CastStatusOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new Watermark(),\n  //       new RecommendationOverlay(),\n  //       controlBar,\n  //       new TitleBar(),\n  //       new ErrorMessageOverlay(),\n  //     ],\n  //     cssClasses: ['ui-skin-legacy'],\n  //   });\n  // }\n\n  // function legacyAdsUI() {\n  //   return new UIContainer({\n  //     components: [\n  //       new AdClickOverlay(),\n  //       new ControlBar({\n  //         components: [\n  //           new PlaybackToggleButton(),\n  //           new AdMessageLabel(),\n  //           new VolumeControlButton(),\n  //           new FullscreenToggleButton(),\n  //         ],\n  //       }),\n  //       new AdSkipButton(),\n  //     ],\n  //     cssClasses: ['ui-skin-legacy', 'ui-skin-ads'],\n  //   });\n  // }\n\n  // function legacyCastReceiverUI() {\n  //   let controlBar = new ControlBar({\n  //     components: [\n  //       new SeekBar(),\n  //       new PlaybackTimeLabel(),\n  //     ],\n  //   });\n\n  //   return new UIContainer({\n  //     components: [\n  //       new SubtitleOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new Watermark(),\n  //       controlBar,\n  //       new TitleBar(),\n  //       new ErrorMessageOverlay(),\n  //     ],\n  //     cssClasses: ['ui-skin-legacy', 'ui-skin-cast-receiver'],\n  //   });\n  // }\n\n  // function legacyTestUI() {\n  //   let settingsPanel = new SettingsPanel({\n  //     components: [\n  //       new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n  //       new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n  //       new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n  //       new SettingsPanelItem('Subtitles', new SubtitleSelectBox()),\n  //     ],\n  //     hidden: true,\n  //   });\n\n  //   let controlBar = new ControlBar({\n  //     components: [settingsPanel,\n  //       new PlaybackToggleButton(),\n  //       new SeekBar({ label: new SeekBarLabel() }),\n  //       new PlaybackTimeLabel(),\n  //       new VRToggleButton(),\n  //       new VolumeToggleButton(),\n  //       new VolumeSlider(),\n  //       new VolumeControlButton(),\n  //       new VolumeControlButton({ vertical: false }),\n  //       new SettingsToggleButton({ settingsPanel: settingsPanel }),\n  //       new CastToggleButton(),\n  //       new FullscreenToggleButton(),\n  //     ],\n  //   });\n\n  //   return new UIContainer({\n  //     components: [\n  //       new SubtitleOverlay(),\n  //       new CastStatusOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new Watermark(),\n  //       new RecommendationOverlay(),\n  //       controlBar,\n  //       new TitleBar(),\n  //       new ErrorMessageOverlay(),\n  //     ],\n  //     cssClasses: ['ui-skin-legacy'],\n  //   });\n  // }\n\n  // export function buildLegacyUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return new UIManager(player, [{\n  //     ui: legacyAdsUI(),\n  //     condition: (context: UIConditionContext) => {\n  //       return context.isAdWithUI;\n  //     },\n  //   }, {\n  //     ui: legacyUI(),\n  //   }], config);\n  // }\n\n  // export function buildLegacyCastReceiverUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return new UIManager(player, legacyCastReceiverUI(), config);\n  // }\n\n  // export function buildLegacyTestUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return new UIManager(player, legacyTestUI(), config);\n  // }\n}\n\nexport interface SeekPreviewArgs extends NoArgs {\n  /**\n   * The timeline position in percent where the event originates from.\n   */\n  position: number;\n  /**\n   * The timeline marker associated with the current position, if existing.\n   */\n  marker?: SeekBarMarker;\n}\n\n/**\n * Encapsulates functionality to manage a UI instance. Used by the {@link UIManager} to manage multiple UI instances.\n */\nexport class UIInstanceManager {\n  private playerWrapper: PlayerWrapper;\n  private ui: UIContainer;\n  private config: InternalUIConfig;\n\n  private events = {\n    onConfigured: new EventDispatcher<UIContainer, NoArgs>(),\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewArgs>(),\n    onSeeked: new EventDispatcher<SeekBar, NoArgs>(),\n    onComponentShow: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onComponentHide: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onControlsShow: new EventDispatcher<UIContainer, NoArgs>(),\n    onPreviewControlsHide: new EventDispatcher<UIContainer, CancelEventArgs>(),\n    onControlsHide: new EventDispatcher<UIContainer, NoArgs>(),\n    onRelease: new EventDispatcher<UIContainer, NoArgs>(),\n  };\n\n  constructor(player: PlayerAPI, ui: UIContainer, config: InternalUIConfig) {\n    this.playerWrapper = new PlayerWrapper(player);\n    this.ui = ui;\n    this.config = config;\n  }\n\n  getConfig(): InternalUIConfig {\n    return this.config;\n  }\n\n  getUI(): UIContainer {\n    return this.ui;\n  }\n\n  getPlayer(): PlayerAPI {\n    return this.playerWrapper.getPlayer();\n  }\n\n  /**\n   * Fires when the UI is fully configured and added to the DOM.\n   * @returns {EventDispatcher}\n   */\n  get onConfigured(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onConfigured;\n  }\n\n  /**\n   * Fires when a seek starts.\n   * @returns {EventDispatcher}\n   */\n  get onSeek(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeek;\n  }\n\n  /**\n   * Fires when the seek timeline is scrubbed.\n   * @returns {EventDispatcher}\n   */\n  get onSeekPreview(): EventDispatcher<SeekBar, SeekPreviewArgs> {\n    return this.events.onSeekPreview;\n  }\n\n  /**\n   * Fires when a seek is finished.\n   * @returns {EventDispatcher}\n   */\n  get onSeeked(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeeked;\n  }\n\n  /**\n   * Fires when a component is showing.\n   * @returns {EventDispatcher}\n   */\n  get onComponentShow(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentShow;\n  }\n\n  /**\n   * Fires when a component is hiding.\n   * @returns {EventDispatcher}\n   */\n  get onComponentHide(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentHide;\n  }\n\n  /**\n   * Fires when the UI controls are showing.\n   * @returns {EventDispatcher}\n   */\n  get onControlsShow(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsShow;\n  }\n\n  /**\n   * Fires before the UI controls are hiding to check if they are allowed to hide.\n   * @returns {EventDispatcher}\n   */\n  get onPreviewControlsHide(): EventDispatcher<UIContainer, CancelEventArgs> {\n    return this.events.onPreviewControlsHide;\n  }\n\n  /**\n   * Fires when the UI controls are hiding.\n   * @returns {EventDispatcher}\n   */\n  get onControlsHide(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsHide;\n  }\n\n  /**\n   * Fires when the UI controls are released.\n   * @returns {EventDispatcher}\n   */\n  get onRelease(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onRelease;\n  }\n\n  protected clearEventHandlers(): void {\n    this.playerWrapper.clearEventHandlers();\n\n    let events = <any>this.events; // avoid TS7017\n    for (let event in events) {\n      let dispatcher = <EventDispatcher<Object, Object>>events[event];\n      dispatcher.unsubscribeAll();\n    }\n  }\n}\n\n/**\n * Extends the {@link UIInstanceManager} for internal use in the {@link UIManager} and provides access to functionality\n * that components receiving a reference to the {@link UIInstanceManager} should not have access to.\n */\nclass InternalUIInstanceManager extends UIInstanceManager {\n\n  private configured: boolean;\n  private released: boolean;\n\n  getWrappedPlayer(): WrappedPlayer {\n    // TODO find a non-hacky way to provide the WrappedPlayer to the UIManager without exporting it\n    // getPlayer() actually returns the WrappedPlayer but its return type is set to Player so the WrappedPlayer does\n    // not need to be exported\n    return <WrappedPlayer>this.getPlayer();\n  }\n\n  configureControls(): void {\n    this.configureControlsTree(this.getUI());\n    this.configured = true;\n  }\n\n  isConfigured(): boolean {\n    return this.configured;\n  }\n\n  private configureControlsTree(component: Component<ComponentConfig>) {\n    let configuredComponents: Component<ComponentConfig>[] = [];\n\n    UIUtils.traverseTree(component, (component) => {\n      // First, check if we have already configured a component, and throw an error if we did. Multiple configuration\n      // of the same component leads to unexpected UI behavior. Also, a component that is in the UI tree multiple\n      // times hints at a wrong UI structure.\n      // We could just skip configuration in such a case and not throw an exception, but enforcing a clean UI tree\n      // seems like the better choice.\n      for (let configuredComponent of configuredComponents) {\n        if (configuredComponent === component) {\n          // Write the component to the console to simplify identification of the culprit\n          // (e.g. by inspecting the config)\n          if (console) {\n            console.error('Circular reference in UI tree', component);\n          }\n\n          // Additionally throw an error, because this case must not happen and leads to unexpected UI behavior.\n          throw Error('Circular reference in UI tree: ' + component.constructor.name);\n        }\n      }\n\n      component.initialize();\n      component.configure(this.getPlayer(), this);\n      configuredComponents.push(component);\n    });\n  }\n\n  releaseControls(): void {\n    // Do not call release methods if the components have never been configured; this can result in exceptions\n    if (this.configured) {\n      this.onRelease.dispatch(this.getUI());\n      this.releaseControlsTree(this.getUI());\n      this.configured = false;\n    }\n    this.released = true;\n  }\n\n  isReleased(): boolean {\n    return this.released;\n  }\n\n  private releaseControlsTree(component: Component<ComponentConfig>) {\n    component.release();\n\n    if (component instanceof Container) {\n      for (let childComponent of component.getComponents()) {\n        this.releaseControlsTree(childComponent);\n      }\n    }\n  }\n\n  clearEventHandlers(): void {\n    super.clearEventHandlers();\n  }\n}\n\n/**\n * Extended interface of the {@link Player} for use in the UI.\n */\ninterface WrappedPlayer extends PlayerAPI {\n  /**\n   * Fires an event on the player that targets all handlers in the UI but never enters the real player.\n   * @param event the event to fire\n   * @param data data to send with the event\n   */\n  fireEventInUI(event: EVENT, data: {}): void;\n}\n\n/**\n * Wraps the player to track event handlers and provide a simple method to remove all registered event\n * handlers from the player.\n */\nclass PlayerWrapper {\n\n  private player: PlayerAPI;\n  private wrapper: WrappedPlayer;\n\n  private eventHandlers: { [eventType: string]: PlayerEventCallback[]; } = {};\n\n  constructor(player: PlayerAPI) {\n    this.player = player;\n\n    // Collect all members of the player (public API methods and properties of the player)\n    // (Object.getOwnPropertyNames(player) does not work with the player TypeScript class starting in 7.2)\n    let members: string[] = [];\n    for (let member in player) {\n      members.push(member);\n    }\n\n    // Split the members into methods and properties\n    let methods = <any[]>[];\n    let properties = <any[]>[];\n\n    for (let member of members) {\n      if (typeof (<any>player)[member] === 'function') {\n        methods.push(member);\n      } else {\n        properties.push(member);\n      }\n    }\n\n    // Create wrapper object\n    let wrapper = <any>{};\n\n    // Add function wrappers for all API methods that do nothing but calling the base method on the player\n    for (let method of methods) {\n      wrapper[method] = function() {\n        // console.log('called ' + member); // track method calls on the player\n        return (<any>player)[method].apply(player, arguments);\n      };\n    }\n\n    // Add all public properties of the player to the wrapper\n    for (let property of properties) {\n      // Get an eventually existing property descriptor to differentiate between plain properties and properties with\n      // getters/setters.\n      let propertyDescriptor: PropertyDescriptor = Object.getOwnPropertyDescriptor(player, property) ||\n        Object.getOwnPropertyDescriptor(Object.getPrototypeOf(player), property);\n\n      // If the property has getters/setters, wrap them accordingly...\n      if (propertyDescriptor && (propertyDescriptor.get || propertyDescriptor.set)) {\n        Object.defineProperty(wrapper, property, {\n          get: () => propertyDescriptor.get.call(player),\n          set: (value: any) => propertyDescriptor.set.call(player, value),\n        });\n      }\n      // ... else just transfer the property to the wrapper\n      else {\n        wrapper[property] = (<any>player)[property];\n      }\n    }\n\n    // Explicitly add a wrapper method for 'addEventHandler' that adds added event handlers to the event list\n    wrapper.addEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      // in player V8 addEventHandler was replaced by on\n      if (player.on) {\n        player.on(eventType, callback);\n      } else {\n        // keep backward compatibility for versions <7.7\n        player.addEventHandler(eventType, callback);\n      }\n\n      if (!this.eventHandlers[eventType]) {\n        this.eventHandlers[eventType] = [];\n      }\n\n      this.eventHandlers[eventType].push(callback);\n\n      return wrapper;\n    };\n\n    // Explicitly add a wrapper method for 'removeEventHandler' that removes removed event handlers from the event list\n    wrapper.removeEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      if (player.off) {\n        player.off(eventType, callback);\n      } else {\n        // keep backward compatibility for versions <7.7\n        player.removeEventHandler(eventType, callback);\n      }\n\n      if (this.eventHandlers[eventType]) {\n        ArrayUtils.remove(this.eventHandlers[eventType], callback);\n      }\n\n      return wrapper;\n    };\n\n    wrapper.fireEventInUI = (event: EVENT, data: {}) => {\n      if (this.eventHandlers[event]) { // check if there are handlers for this event registered\n        // Extend the data object with default values to convert it to a {@link PlayerEvent} object.\n        let playerEventData = <PlayerEvent>Object.assign({}, {\n          timestamp: Date.now(),\n          type: event,\n          // Add a marker property so the UI can detect UI-internal player events\n          uiSourced: true,\n        }, data);\n\n        // Execute the registered callbacks\n        for (let callback of this.eventHandlers[event]) {\n          callback(playerEventData);\n        }\n      }\n    };\n\n    this.wrapper = <WrappedPlayer>wrapper;\n  }\n\n  /**\n   * Returns a wrapped player object that can be used on place of the normal player object.\n   * @returns {WrappedPlayer} a wrapped player\n   */\n  getPlayer(): WrappedPlayer {\n    return this.wrapper;\n  }\n\n  /**\n   * Clears all registered event handlers from the player that were added through the wrapped player.\n   */\n  clearEventHandlers(): void {\n    for (let eventType in this.eventHandlers) {\n      for (let callback of this.eventHandlers[eventType]) {\n        this.player.removeEventHandler(eventType, callback);\n      }\n    }\n  }\n}\n\n","import {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\n\nexport namespace UIUtils {\n  export interface TreeTraversalCallback {\n    (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>): void;\n  }\n\n  export function traverseTree(component: Component<ComponentConfig>, visit: TreeTraversalCallback): void {\n    let recursiveTreeWalker = (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>) => {\n      visit(component, parent);\n\n      // If the current component is a container, visit it's children\n      if (component instanceof Container) {\n        for (let childComponent of component.getComponents()) {\n          recursiveTreeWalker(childComponent, component);\n        }\n      }\n    };\n\n    // Walk and configure the component tree\n    recursiveTreeWalker(component);\n  }\n}\n"]}
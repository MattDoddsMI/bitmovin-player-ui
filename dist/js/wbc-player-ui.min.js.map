{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/ts/arrayutils.ts","src/ts/browserutils.ts","src/ts/components/adclickoverlay.ts","src/ts/components/admessagelabel.ts","src/ts/components/adskipbutton.ts","src/ts/components/airplaytogglebutton.ts","src/ts/components/audioonlyoverlay.ts","src/ts/components/audioqualityselectbox.ts","src/ts/components/audiotrackselectbox.ts","src/ts/components/bufferingoverlay.ts","src/ts/components/button.ts","src/ts/components/caststatusoverlay.ts","src/ts/components/casttogglebutton.ts","src/ts/components/castuicontainer.ts","src/ts/components/clickoverlay.ts","src/ts/components/closebutton.ts","src/ts/components/component.ts","src/ts/components/container.ts","src/ts/components/controlbar.ts","src/ts/components/errormessageoverlay.ts","src/ts/components/fullscreentogglebutton.ts","src/ts/components/hugeplaybacktogglebutton.ts","src/ts/components/hugereplaybutton.ts","src/ts/components/itemselectionlist.ts","src/ts/components/label.ts","src/ts/components/listselector.ts","src/ts/components/metadatalabel.ts","src/ts/components/pictureinpicturetogglebutton.ts","src/ts/components/playbackspeedselectbox.ts","src/ts/components/playbacktimelabel.ts","src/ts/components/playbacktogglebutton.ts","src/ts/components/playbacktoggleoverlay.ts","src/ts/components/recommendationoverlay.ts","src/ts/components/seekbar.ts","src/ts/components/seekbarlabel.ts","src/ts/components/selectbox.ts","src/ts/components/settingspanel.ts","src/ts/components/settingstogglebutton.ts","src/ts/components/spacer.ts","src/ts/components/subtitleoverlay.ts","src/ts/components/subtitleselectbox.ts","src/ts/components/subtitlesettings/backgroundcolorselectbox.ts","src/ts/components/subtitlesettings/backgroundopacityselectbox.ts","src/ts/components/subtitlesettings/characteredgeselectbox.ts","src/ts/components/subtitlesettings/fontcolorselectbox.ts","src/ts/components/subtitlesettings/fontfamilyselectbox.ts","src/ts/components/subtitlesettings/fontopacityselectbox.ts","src/ts/components/subtitlesettings/fontsizeselectbox.ts","src/ts/components/subtitlesettings/subtitlesettingsbutton.ts","src/ts/components/subtitlesettings/subtitlesettingsclosebutton.ts","src/ts/components/subtitlesettings/subtitlesettingselectbox.ts","src/ts/components/subtitlesettings/subtitlesettingslabel.ts","src/ts/components/subtitlesettings/subtitlesettingsmanager.ts","src/ts/components/subtitlesettings/subtitlesettingsopenbutton.ts","src/ts/components/subtitlesettings/subtitlesettingspanel.ts","src/ts/components/subtitlesettings/subtitlesettingsresetbutton.ts","src/ts/components/subtitlesettings/windowcolorselectbox.ts","src/ts/components/subtitlesettings/windowopacityselectbox.ts","src/ts/components/titlebar.ts","src/ts/components/togglebutton.ts","src/ts/components/tvnoisecanvas.ts","src/ts/components/uicontainer.ts","src/ts/components/videoqualityselectbox.ts","src/ts/components/volumecontrolbutton.ts","src/ts/components/volumeslider.ts","src/ts/components/volumetogglebutton.ts","src/ts/components/vrtogglebutton.ts","src/ts/components/watermark.ts","src/ts/dom.ts","src/ts/eventdispatcher.ts","src/ts/guid.ts","src/ts/imageloader.ts","src/ts/main.ts","src/ts/playerutils.ts","src/ts/storageutils.ts","src/ts/stringutils.ts","src/ts/timeout.ts","src/ts/uimanager.ts","src/ts/uiutils.ts"],"names":["f","exports","module","define","amd","g","window","global","self","this","bitmovin","playerui","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","ArrayUtils","remove","array","item","index","indexOf","splice","BrowserUtils","isMobile","navigator","userAgent","test","isChrome","isAndroid","clickoverlay_1","AdClickOverlay","_super","__extends","prototype","configure","player","uimanager","_this","clickThroughUrl","clickThroughEnabled","getConfig","advertising","hasOwnProperty","addEventHandler","EVENT","ON_AD_STARTED","event","setUrl","adFinishedHandler","ON_AD_FINISHED","ON_AD_SKIPPED","ON_AD_ERROR","onClick","subscribe","pause","fireEvent","ON_AD_CLICKED","ClickOverlay","label_1","stringutils_1","AdMessageLabel","config","mergeConfig","cssClass","text","updateMessageHandler","setText","StringUtils","replaceAdMessagePlaceholders","adStartHandler","adMessage","ON_TIME_CHANGED","ON_CAST_TIME_UPDATED","adEndHandler","removeEventHandler","Label","button_1","AdSkipButton","skipMessage","countdown","skip","adEvent","updateSkipMessageHandler","skipOffset","show","hide","getCurrentTime","skipAd","Button","togglebutton_1","AirPlayToggleButton","isAirplayAvailable","showAirplayTargetPicker","console","log","airPlayAvailableHandler","ON_AIRPLAY_AVAILABLE","ToggleButton","container_1","component_1","timeout_1","AudioOnlyOverlay","indicatorConfig","Component","tag","hidden","components","componentConfig","audioOnlyOverlayConfig","indicator","backgroundImageUrl","element","getDomElement","overlayShowTimeout","Timeout","showOverlay","start","hideOverlay","clear","css","hiddeIndicator","ON_PLAY","ON_PAUSED","Container","selectbox_1","AudioQualitySelectBox","selectCurrentAudioQuality","getAudioQuality","selectItem","id","data","getDownloadedAudioData","isAuto","updateAudioQualities","audioQualities","getAvailableAudioQualities","clearItems","addItem","_i","audioQualities_1","audioQuality","label","onItemSelected","sender","value","setAudioQuality","ON_AUDIO_CHANGED","ON_SOURCE_UNLOADED","ON_READY","ON_PERIOD_SWITCHED","ON_AUDIO_QUALITY_CHANGED","ON_AUDIO_DOWNLOAD_QUALITY_CHANGE","SelectBox","AudioTrackSelectBox","selectCurrentAudioTrack","currentAudioTrack","getAudio","updateAudioTracks","audioTracks","getAvailableAudio","audioTracks_1","audioTrack","setAudio","ON_AUDIO_ADDED","ON_AUDIO_REMOVED","BufferingOverlay","indicators","showDelayMs","ON_STALL_STARTED","ON_STALL_ENDED","isStalled","dom_1","eventdispatcher_1","buttonEvents","EventDispatcher","toDomElement","buttonElement","DOM","type","class","getCssClasses","append","prefixCss","html","on","onClickEvent","find","dispatch","Object","defineProperty","getEvent","CastStatusOverlay","statusLabel","ON_CAST_WAITING_FOR_DEVICE","castDeviceName","castPayload","deviceName","ON_CAST_STARTED","ON_CAST_STOPPED","CastToggleButton","isCastAvailable","isCasting","castStop","castVideo","castAvailableHander","ON_CAST_AVAILABLE","off","uicontainer_1","CastUIContainer","isUiShown","hideUi","onControlsHide","castUiHideTimeout","hideDelay","showUi","onControlsShow","showUiPermanently","showUiWithTimeout","showUiAfterSeek","isPlaying","ON_SOURCE_LOADED","ON_SEEK","ON_SEEKED","release","UIContainer","initialize","url","open","getUrl","undefined","CloseButton","target","guid_1","componentEvents","onShow","onHide","onHoverChanged","Guid","next","cssPrefix","cssClasses","isHidden","onComponentShow","onComponentHide","onHoverChangedEvent","defaults","base","assign","flattenedArray","concat","map","join","trim","cssClassOrId","addClass","CLASS_HIDDEN","onHideEvent","removeClass","onShowEvent","isShown","toggleHidden","isHovered","hovered","arrayutils_1","componentsToAdd","componentsToRemove","addComponent","component","push","removeComponent","getComponents","removeComponents","_a","slice","updateComponents","shift","innerContainerElement","containerElement","innerContainer","initialComponent","uiutils_1","spacer_1","ControlBar","hoverStackCount","UIUtils","traverseTree","Spacer","args","onPreviewControlsHide","cancel","tvnoisecanvas_1","ErrorMessageOverlay","errorLabel","tvNoiseBackground","TvNoiseCanvas","ON_ERROR","message","messages","customMessage","stop","FullscreenToggleButton","fullscreenStateHandler","isFullscreen","ON_FULLSCREEN_ENTER","ON_FULLSCREEN_EXIT","exitFullscreen","enterFullscreen","playbacktogglebutton_1","HugePlaybackToggleButton","togglePlayback","play","toggleFullscreen","firstPlay","clickTime","doubleClickTime","now","Date","setTimeout","ON_WARNING","castInitializationHandler","ON_CAST_START","suppressPlayButtonTransitionAnimation","setTransitionAnimationsEnabled","onToggle","subscribeOnce","isAutoplayEnabled","playback","Boolean","autoplay","isAutoplayUpcoming","isReady","enabled","noTransitionAnimationsClass","hasClass","PlaybackToggleButton","HugeReplayButton","listselector_1","ItemSelectionList","isActive","items","listElement","updateDomItems","selectedValue","empty","selectedListItem","listItem","CLASS_SELECTED","deselectItem","this_1","String","key","onItemSelectedEvent","onItemAddedEvent","selectedItem","onItemRemovedEvent","ListSelector","labelEvents","onTextChanged","labelElement","onTextChangedEvent","getText","clearText","isEmpty","listSelectorEvents","onItemAdded","onItemRemoved","getItemIndex","parseInt","hasItem","filter","translator","removeItem","getSelectedItem","items_1","itemCount","keys","MetadataLabelContent","MetadataLabel","content","toLowerCase","uiconfig","init","Title","metadata","title","Description","description","unload","PictureInPictureToggleButton","isPictureInPictureAvailable","isPictureInPicture","exitPictureInPicture","enterPictureInPicture","pipAvailableHander","ON_PICTURE_IN_PICTURE_ENTER","ON_PICTURE_IN_PICTURE_EXIT","PlaybackSpeedSelectBox","defaultPlaybackSpeeds","addDefaultItems","setPlaybackSpeed","parseFloat","setDefaultValue","playbackSpeed","getPlaybackSpeed","setSpeed","ON_PLAYBACK_SPEED_CHANGED","speed","customItems","sort","forEach","PlaybackTimeLabelMode","playerutils_1","PlaybackTimeLabel","timeLabelMode","CurrentAndTotalTime","hideInLivePlayback","live","liveCssClass","liveEdgeCssClass","minWidth","liveClickHandler","timeShift","updateLiveState","isLive","updateLiveTimeshiftState","unsubscribe","isTimeshifted","getTimeShift","isTimeshiftAvailable","getMaxTimeShift","isPaused","liveStreamDetector","PlayerUtils","LiveStreamDetector","onLiveChanged","detect","playbackTimeHandler","getDuration","Infinity","setTime","width","min-width","ON_TIME_SHIFT","ON_TIME_SHIFTED","timeFormat","Math","abs","FORMAT_HHMMSS","FORMAT_MMSS","playbackSeconds","durationSeconds","currentTime","secondsToTime","totalTime","CurrentTime","TotalTime","setTimeFormat","handleClickEvent","isSeeking","playbackStateHandler","ON_PLAYING","ON_PLAYBACK_FINISHED","ON_CAST_PLAYING","ON_CAST_PAUSED","ON_CAST_PLAYBACK_FINISHED","timeShiftDetector","TimeShiftAvailabilityDetector","onTimeShiftAvailabilityChanged","timeShiftAvailable","CLASS_STOPTOGGLE","onSeek","onSeeked","hugeplaybacktogglebutton_1","PlaybackToggleOverlay","playbackToggleButton","hugereplaybutton_1","RecommendationOverlay","replayButton","clearRecommendations","RecommendationItem","setupRecommendations","recommendations","recommendations_1","itemConfig","isAd","itemElement","href","background-image","thumbnail","bgElement","titleElement","timeElement","duration","SeekBar","playbackPositionPercentage","touchSupported","seekBarEvents","onSeekPreview","vertical","smoothPlaybackPositionUpdateIntervalMs","timelineMarkers","hasLabel","getLabel","configureSeek","setPosition","seekBarBackdrop","playbackPositionHandler","forceUpdate","setPlaybackPosition","setBufferPosition","videoBufferLength","getVideoBufferLength","audioBufferLength","getAudioBufferLength","bufferLength","min","Number","MAX_VALUE","bufferPercentage","SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED","ON_SEGMENT_REQUEST_FINISHED","configureLivePausedTimeshiftUpdater","setSeeking","seek","percentage","subscribeRateLimited","scrubbing","position","hasTimeShift","switchVisibility","refreshPlaybackPosition","ON_PLAYER_RESIZE","onConfigured","setSeekPosition","configureSmoothPlaybackPositionUpdater","configureMarkers","pausedTimeshiftUpdater","currentTimeSeekBar","currentTimePlayer","smoothPlaybackPositionUpdater","updateIntervalMs","currentTimeDelta","startSmoothPlaybackPositionUpdater","stopSmoothPlaybackPositionUpdater","clearMarkers","updateMarkers","setupMarkers","markers","marker","markerPosition","time","markerDuration","events","onUpdated","onRelease","seekBarContainer","seekBar","seekBarBufferLevel","seekBarBufferPosition","seekBarPlaybackPosition","seekBarPlaybackPositionMarker","seekBarSeekPosition","seekBarChapterMarkersContainer","seekBarMarkersContainer","seeking","mouseTouchMoveHandler","preventDefault","stopPropagation","targetPercentage","getOffset","onSeekPreviewEvent","mouseTouchUpHandler","document","snappedChapter","getMarkerAtPosition","onSeekedEvent","isTouchEvent","TouchEvent","onSeekEvent","seekBarWidthPx","markerClasses","cssProperties","markerWidthPx","round","data-marker-time","data-marker-title","getHorizontalOffset","eventPageX","elementOffsetPx","offset","left","widthPx","offsetPx","sanitizeOffset","getVerticalOffset","eventPageY","top","height","changedTouches","pageY","touches","pageX","MouseEvent","warn","percent","totalSize","px","style","transform","-ms-transform","-webkit-transform","scale","CLASS_SEEKING","snappedMarker","seekPositionPercentage","imageloader_1","SeekBarLabel","timeLabel","titleLabel","thumbnailImageLoader","ImageLoader","appliedMarkerCssClasses","maxTimeShift","setTitleText","setThumbnail","getThumb","seconds","thumbnailElement","display","load","thumbnailCountX","w","thumbnailCountY","h","thumbnailIndexX","x","thumbnailIndexY","y","sizeX","sizeY","offsetX","offsetY","aspectRatio","padding-bottom","background-size","background-position","selectElement","val","optionElement","attr","videoqualityselectbox_1","audioqualityselectbox_1","SettingsPanel","settingsPanelEvents","onSettingsStateChanged","hideTimeout","hideHoveredSelectBoxes","reset","settingsStateChangedHandler","onSettingsStateChangedEvent","lastShownItem","getItems","CLASS_LAST","onActiveChanged","setting","selectBox_1","oldDisplay_1","requestAnimationFrame","hasActiveSettings","SettingsPanelItem","settingsPanelItemEvents","handleConfigItemChanged","minItemsToDisplay","VideoQualitySelectBox","hasAutoItem","onActiveChangedEvent","SettingsToggleButton","settingsPanel","autoHideWhenNoActiveSettings","settingsPanelItemsChangedHandler","controlbar_1","SubtitleOverlay","preprocessLabelEventCallback","previewSubtitleActive","previewSubtitle","SubtitleLabel","subtitleManager","ActiveSubtitleManager","ON_CUE_ENTER","row","column","labelToAdd","cueEnter","ON_CUE_EXIT","labelToRemove","cueExit","hasCues","subtitleClearHandler","ON_SUBTITLE_CHANGED","CLASS_CONTROLBAR_VISIBLE","configureCea608Captions","fontSize","fontLetterSpacing","fontSizeCalculationRequired","updateCEA608FontSize","dummyLabel","font-size","line-height","visibility","dummyLabelCharWidth","dummyLabelCharHeight","fontSizeRatio","subtitleOverlayWidth","subtitleOverlayHeight","CEA608_NUM_COLUMNS","CEA608_NUM_ROWS","gridSlotWidth","letter-spacing","CLASS_CEA_608","CEA608_COLUMN_OFFSET","CEA608_ROW_OFFSET","enablePreviewSubtitleLabel","removePreviewSubtitleLabel","activeSubtitleCueMap","activeSubtitleCueCount","calculateId","getCues","activeSubtitleCues","cue","activeSubtitleCue","cueCount","SubtitleSelectBox","selectCurrentSubtitle","currentSubtitle","getSubtitle","updateSubtitles","getAvailableSubtitles","subtitle","setSubtitle","ON_SUBTITLE_ADDED","ON_SUBTITLE_REMOVED","subtitlesettingselectbox_1","BackgroundColorSelectBox","setColorAndOpacity","settingsManager","backgroundColor","isSet","backgroundOpacity","toggleOverlayClass","onChanged","property","SubtitleSettingSelectBox","BackgroundOpacitySelectBox","CharacterEdgeSelectBox","characterEdge","FontColorSelectBox","fontColor","fontOpacity","FontFamilySelectBox","fontFamily","FontOpacitySelectBox","FontSizeSelectBox","SubtitleSettingsButton","subtitleSettingsPanel","subtitlesettingsbutton_1","SubtitleSettingsCloseButton","overlay","currentCssClass","SubtitleSettingsLabel","opener","storageutils_1","SubtitleSettingsManager","_properties","SubtitleSettingsProperty","windowColor","windowOpacity","userSettings","localStorageKey","DummyComponent","instance","propertyName","save","StorageUtils","setObject","getObject","_instance","manager","_manager","_onChanged","_value","onChangedEvent","SubtitleSettingsOpenButton","settingspanel_1","fontcolorselectbox_1","fontopacityselectbox_1","fontfamilyselectbox_1","fontsizeselectbox_1","backgroundcolorselectbox_1","backgroundopacityselectbox_1","windowcolorselectbox_1","windowopacityselectbox_1","characteredgeselectbox_1","subtitlesettingsmanager_1","subtitlesettingsclosebutton_1","subtitlesettingsresetbutton_1","SubtitleSettingsPanel","WindowColorSelectBox","WindowOpacitySelectBox","SubtitleSettingsResetButton","metadatalabel_1","TitleBar","keepHiddenWithoutMetadata","shouldBeShown","hasMetadataText","checkMetadataTextAndUpdateVisibility","toggleButtonEvents","onToggleOn","onToggleOff","defaultConfig","onClass","offClass","isOff","onState","onToggleEvent","onToggleOnEvent","isOn","onToggleOffEvent","toggle","canvasWidth","canvasHeight","interferenceHeight","lastFrameUpdate","frameInterval","useAnimationFrame","canvas","canvasElement","get","canvasContext","getContext","noiseAnimationWindowPos","renderFrame","cancelAnimationFrame","frameUpdateHandlerId","clearTimeout","getTime","scheduleNextRender","currentPixelOffset","noiseImage","createImageData","random","putImageData","bind","configureUIShowHide","configurePlayerStates","container","isFirstTouch","uiHideTimeout","previewHideEventArgs","stateClassNames","state","PlayerState","isNaN","enumName","STATE_PREFIX","removeStates","IDLE","PREPARED","PLAYING","PAUSED","FINISHED","getState","FULLSCREEN","BUFFERING","REMOTE_CONTROL","CONTROLS_HIDDEN","CONTROLS_SHOWN","updateLayoutSizeClasses","substring","getFigure","createElement","flex","selectCurrentVideoQuality","getVideoQuality","getDownloadedVideoData","updateVideoQualities","videoQualities","getAvailableVideoQualities","hasAuto","getStreamType","videoQualities_1","videoQuality","setVideoQuality","ON_VIDEO_QUALITY_CHANGED","ON_VIDEO_DOWNLOAD_QUALITY_CHANGE","volumeslider_1","volumetogglebutton_1","VolumeControlButton","volumeToggleButton","VolumeToggleButton","volumeSlider","VolumeSlider","getVolumeToggleButton","getVolumeSlider","volumeSliderHideTimeout","volumeSliderHovered","seekbar_1","hideIfVolumeControlProhibited","detectVolumeControlAvailability","volumeChangeHandler","isMuted","getVolume","ON_VOLUME_CHANGED","ON_MUTED","ON_UNMUTED","setVolume","issuerName","dummyVideoElement","volume","muteStateHandler","volumeLevelHandler","volumeLevelTens","ceil","unmute","mute","VRToggleButton","isVRConfigured","source","vr","contentType","isVRStereoAvailable","getVRStatus","vrStateHandler","isStereo","vrButtonVisibilityHandler","ON_VR_MODE_CHANGED","ON_VR_STEREO_CHANGED","ON_VR_ERROR","setVRStereo","Watermark","something","attributes","Array","HTMLElement","elements","Document","tagName","attributeName","attributeValue","setAttribute","selector","findChildElements","getElements","handler","findChildElementsOfElement","childElements","querySelectorAll","allChildElements","arguments","setHtml","getHtml","innerHTML","HTMLSelectElement","HTMLInputElement","attribute","setAttr","getAttr","getAttribute","dataAttribute","setData","getData","childElement","_","appendChild","parent","parentNode","removeChild","elementRect","getBoundingClientRect","htmlRect","body","parentElement","offsetWidth","offsetHeight","eventName","eventHandler","split","addEventListener","removeEventListener","className","classList","classNames","add","apply","replace","RegExp","contains","propertyNameOrCollection","setCss","getCss","propertyValueCollection","setCssCollection","getComputedStyle","ruleValueCollection","listeners","listener","EventListenerWrapper","rateMs","RateLimitedEventListenerWrapper","subscribedListener","unsubscribeAll","listenersToRemove","listeners_1","fire","isOnce","listenersToRemove_1","listenerToRemove","once","eventListener","lastFireTime","rateLimitingEventListener","fireSuper","guid","loadedCallback","loaded","callLoadedCallback","state_1","image","uimanager_1","fullscreentogglebutton_1","playbacktimelabel_1","itemselectionlist_1","settingstogglebutton_1","vrtogglebutton_1","watermark_1","audiotrackselectbox_1","caststatusoverlay_1","casttogglebutton_1","errormessageoverlay_1","recommendationoverlay_1","seekbarlabel_1","subtitleoverlay_1","subtitleselectbox_1","titlebar_1","volumecontrolbutton_1","adskipbutton_1","admessagelabel_1","adclickoverlay_1","playbackspeedselectbox_1","bufferingoverlay_1","castuicontainer_1","playbacktoggleoverlay_1","closebutton_1","airplaytogglebutton_1","pictureinpicturetogglebutton_1","subtitlesettingslabel_1","subtitlesettingsopenbutton_1","subtitlesettingspanel_1","browserutils_1","TypeError","version","UIManager","UIInstanceManager","subtitlesettings","isTimeShiftAvailable","hasEnded","timeShiftAvailabilityChangedEvent","timeShiftAvailableNow","liveChangedEvent","liveDetector","liveNow","hasLocalStorage","hasLocalStorageCache","storage","setItem","DOMException","name","localStorage","getItem","JSON","stringify","json","parse","totalSeconds","format","isNegative","hours","floor","minutes","leftPadWithZeros","num","substr","adMessagePlaceholderRegex","formatString","formatNumber","formatStringValidationRegex","leadingZeroesRegex","decimalPlacesRegex","leadingZeroes","leadingZeroesMatches","match","numDecimalPlaces","decimalPlacesMatches","timeString","toFixed","delay","callback","repeat","timeoutHandle","clearInternal","lastScheduleTime","delayAdjust","internalCallback","delta","audioonlyoverlay_1","playerUiOrUiVariants","onUiVariantResolve","playerUi","uiVariants","ui","__assign","managerPlayerWrapper","PlayerWrapper","updateConfig","playerSourceConfig","uiConfig","playerSourceUiConfig","getPlayer","uiContainerElement","uiInstanceManagers","uiVariantsWithoutCondition","uiVariant","condition","InternalUIInstanceManager","autoUiVariantResolve","adStartedEvent","resolveUiVariant","ad","adWithUI","clientType","isAdWithUI","adClientType","context","currentUi","getWrappedPlayer","fireEventInUI","getUiVariants","switchToUiVariant","uiVariantIndex","nextUi","uiVariantChanged","getUI","isConfigured","addUi","defaultContext","documentWidth","clientWidth","switchingContext","nextUiVariant","dom","configureControls","releaseUi","releaseControls","clearEventHandlers","uiInstanceManager","getTimelineMarkers","addTimelineMarker","timelineMarker","removeTimelineMarker","Factory","buildAudioVideoUI","modernSmallScreenUI","modernUI","buildAudioOnlyUI","modernAudioOnlySmallScreenUI","modernAudioOnlyUI","subtitleOverlay","subtitleSettingsOpenButton","controlBar","playerWrapper","event_1","configureControlsTree","configured","configuredComponents","configuredComponents_1","error","constructor","releaseControlsTree","released","isReleased","childComponent","eventHandlers","members","member","methods","properties","members_1","wrapper","methods_1","method","_b","properties_1","propertyDescriptor","getOwnPropertyDescriptor","getPrototypeOf","set","eventType","playerEventData","timestamp","uiSourced","visit","recursiveTreeWalker"],"mappings":"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","file":"wbc-player-ui.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","export namespace ArrayUtils {\n  /**\n   * Removes an item from an array.\n   * @param array the array that may contain the item to remove\n   * @param item the item to remove from the array\n   * @returns {any} the removed item or null if it wasn't part of the array\n   */\n  export function remove<T>(array: T[], item: T): T | null {\n    let index = array.indexOf(item);\n\n    if (index > -1) {\n      return array.splice(index, 1)[0];\n    } else {\n      return null;\n    }\n  }\n}\n","export namespace BrowserUtils {\n\n  // isMobile only needs to be evaluated once (it cannot change during a browser session)\n  // Mobile detection according to Mozilla recommendation: \"In summary, we recommend looking for the string “Mobi”\n  // anywhere in the User Agent to detect a mobile device.\"\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent\n  export const isMobile = navigator && navigator.userAgent && /Mobi/.test(navigator.userAgent);\n\n  export const isChrome = navigator && navigator.userAgent && /Chrome/.test(navigator.userAgent);\n\n  export const isAndroid = navigator && navigator.userAgent && /Android/.test(navigator.userAgent);\n}\n","import {ClickOverlay} from './clickoverlay';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A simple click capture overlay for clickThroughUrls of ads.\n */\nexport class AdClickOverlay extends ClickOverlay {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clickThroughUrl = <string>null;\n    let clickThroughEnabled = !player.getConfig().advertising\n      || !player.getConfig().advertising.hasOwnProperty('clickThroughEnabled')\n      || player.getConfig().advertising.clickThroughEnabled;\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, (event: bitmovin.PlayerAPI.AdStartedEvent) => {\n      clickThroughUrl = event.clickThroughUrl;\n\n      if (clickThroughEnabled) {\n        this.setUrl(clickThroughUrl);\n      } else {\n        // If click-through is disabled, we set the url to null to avoid it open\n        this.setUrl(null);\n      }\n    });\n\n    // Clear click-through URL when ad has finished\n    let adFinishedHandler = () => {\n      this.setUrl(null);\n    };\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adFinishedHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adFinishedHandler);\n\n    this.onClick.subscribe(() => {\n      // Pause the ad when overlay is clicked\n      player.pause('ui-content-click');\n\n      // Notify the player of the clicked ad\n      player.fireEvent(player.EVENT.ON_AD_CLICKED, {\n        clickThroughUrl: clickThroughUrl,\n      });\n    });\n  }\n}","import {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {StringUtils} from '../stringutils';\n\n/**\n * A label that displays a message about a running ad, optionally with a countdown.\n */\nexport class AdMessageLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label-ad-message',\n      text: 'This ad will end in {remainingTime} seconds.',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let text = this.getConfig().text;\n\n    let updateMessageHandler = () => {\n      this.setText(StringUtils.replaceAdMessagePlaceholders(text, null, player));\n    };\n\n    let adStartHandler = (event: bitmovin.PlayerAPI.AdStartedEvent) => {\n      text = event.adMessage || text;\n      updateMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport SkipMessage = bitmovin.PlayerAPI.SkipMessage;\nimport {StringUtils} from '../stringutils';\n\n/**\n * Configuration interface for the {@link AdSkipButton}.\n */\nexport interface AdSkipButtonConfig extends ButtonConfig {\n  skipMessage?: SkipMessage;\n}\n\n/**\n * A button that is displayed during ads and can be used to skip the ad.\n */\nexport class AdSkipButton extends Button<AdSkipButtonConfig> {\n\n  constructor(config: AdSkipButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <AdSkipButtonConfig>{\n      cssClass: 'ui-button-ad-skip',\n      skipMessage: {\n        countdown: 'Skip ad in {remainingTime}',\n        skip: 'Skip ad',\n      },\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <AdSkipButtonConfig>this.getConfig(); // TODO get rid of generic cast\n    let skipMessage = config.skipMessage;\n    let adEvent = <bitmovin.PlayerAPI.AdStartedEvent>null;\n\n    let updateSkipMessageHandler = () => {\n      // Display this button only if ad is skippable\n      if (adEvent.skipOffset) {\n        this.show();\n      } else {\n        this.hide();\n      }\n\n      // Update the skip message on the button\n      if (player.getCurrentTime() < adEvent.skipOffset) {\n        this.setText(\n          StringUtils.replaceAdMessagePlaceholders(config.skipMessage.countdown, adEvent.skipOffset, player));\n      } else {\n        this.setText(config.skipMessage.skip);\n      }\n    };\n\n    let adStartHandler = (event: bitmovin.PlayerAPI.AdStartedEvent) => {\n      adEvent = event;\n      skipMessage = adEvent.skipMessage || skipMessage;\n      updateSkipMessageHandler();\n\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    let adEndHandler = () => {\n      player.removeEventHandler(player.EVENT.ON_TIME_CHANGED, updateSkipMessageHandler);\n      player.removeEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, updateSkipMessageHandler);\n    };\n\n    player.addEventHandler(player.EVENT.ON_AD_STARTED, adStartHandler);\n    player.addEventHandler(player.EVENT.ON_AD_SKIPPED, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_ERROR, adEndHandler);\n    player.addEventHandler(player.EVENT.ON_AD_FINISHED, adEndHandler);\n\n    this.onClick.subscribe(() => {\n      // Try to skip the ad (this only works if it is skippable so we don't need to take extra care of that here)\n      player.skipAd();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple AirPlay.\n */\nexport class AirPlayToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-airplaytogglebutton',\n      text: 'Apple AirPlay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    if (!player.isAirplayAvailable) {\n      // If the player does not support Airplay (player 7.0), we just hide this component and skip configuration\n      this.hide();\n      return;\n    }\n\n    this.onClick.subscribe(() => {\n      if (player.isAirplayAvailable()) {\n        player.showAirplayTargetPicker();\n      } else {\n        if (console) {\n          console.log('AirPlay unavailable');\n        }\n      }\n    });\n\n    let airPlayAvailableHandler = () => {\n      if (player.isAirplayAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_AIRPLAY_AVAILABLE, airPlayAvailableHandler);\n\n    // Startup init\n    airPlayAvailableHandler(); // Hide button if AirPlay is not available\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {MIUIConfig, UIAudioOnlyOverlayConfig, UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for the {@link AudioOnlyOverlay} component.\n */\nexport interface AudioOnlyOverlayConfig extends ContainerConfig {\n}\n\n/**\n * Overlays the player and displays an audio-only indicator.\n */\nexport class AudioOnlyOverlay extends Container<AudioOnlyOverlayConfig> {\n    private indicatorConfig: Component<ComponentConfig>[];\n    private componentConfig: UIAudioOnlyOverlayConfig;\n\n    constructor(config: AudioOnlyOverlayConfig = {}) {\n        super(config);\n\n        this.indicatorConfig = [\n            new Component<ComponentConfig>({tag: 'div', cssClass: 'ui-audioonly-overlay-indicator', hidden: true}),\n        ];\n\n        this.config = this.mergeConfig(config, <AudioOnlyOverlayConfig>{\n            cssClass: 'ui-audioonly-overlay',\n            hidden: false,\n            components: this.indicatorConfig,\n        }, this.config);\n    }\n\n    configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n        super.configure(player, uimanager);\n\n        this.componentConfig = (uimanager.getConfig() as MIUIConfig).audioOnlyOverlayConfig || {};\n        const config = <AudioOnlyOverlayConfig>this.getConfig();\n        const indicator = config.components[0];\n\n        const backgroundImageUrl = this.componentConfig.backgroundImageUrl;\n        const element = this.getDomElement();\n\n        const showBackgroundImage = () => {\n            element.css('backgroundImage', `url(${backgroundImageUrl})`);\n            element.css('backgroundSize', 'contain');\n            element.css('backgroundColor', '#000000');\n            element.css('animation', 'none');\n            element.css('backgroundPosition', 'center');\n        };\n\n        const overlayShowTimeout = new Timeout(400, () => {\n            indicator.show();\n        });\n\n        const showOverlay = () => {\n            overlayShowTimeout.start();\n        };\n\n        const hideOverlay = () => {\n            overlayShowTimeout.clear();\n            indicator.hide();\n        };\n\n        if (backgroundImageUrl) {\n            showBackgroundImage();\n        }\n\n        if (!this.componentConfig.hiddeIndicator) {\n            player.addEventHandler(player.EVENT.ON_PLAY, showOverlay);\n            player.addEventHandler(player.EVENT.ON_PAUSED, hideOverlay);\n        }\n    }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available audio qualities.\n */\nexport class AudioQualitySelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let selectCurrentAudioQuality = () => {\n      if (player.getAudioQuality) {\n        // Since player 7.3.1\n        this.selectItem(player.getAudioQuality().id);\n      } else {\n        // Backwards compatibility for players <= 7.3.0\n        // TODO remove in next major release\n        let data = player.getDownloadedAudioData();\n        this.selectItem(data.isAuto ? 'auto' : data.id);\n      }\n    };\n\n    let updateAudioQualities = () => {\n      let audioQualities = player.getAvailableAudioQualities();\n\n      this.clearItems();\n\n      // Add entry for automatic quality switching (default setting)\n      this.addItem('auto', 'auto');\n\n      // Add audio qualities\n      for (let audioQuality of audioQualities) {\n        this.addItem(audioQuality.id, audioQuality.label);\n      }\n\n      // Select initial quality\n      selectCurrentAudioQuality();\n    };\n\n    this.onItemSelected.subscribe((sender: AudioQualitySelectBox, value: string) => {\n      player.setAudioQuality(value);\n    });\n\n    // Update qualities when audio track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, updateAudioQualities);\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioQualities);\n    // Update qualities when the period within a source changes\n    player.addEventHandler(player.EVENT.ON_PERIOD_SWITCHED, updateAudioQualities);\n    // Update quality selection when quality is changed (from outside)\n    if (player.EVENT.ON_AUDIO_QUALITY_CHANGED) {\n      // Since player 7.3.1\n      player.addEventHandler(player.EVENT.ON_AUDIO_QUALITY_CHANGED, selectCurrentAudioQuality);\n    } else {\n      // Backwards compatibility for players <= 7.3.0\n      // TODO remove in next major release\n      player.addEventHandler(player.EVENT.ON_AUDIO_DOWNLOAD_QUALITY_CHANGE, selectCurrentAudioQuality);\n    }\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between available audio tracks (e.g. different languages).\n */\nexport class AudioTrackSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let selectCurrentAudioTrack = () => {\n      let currentAudioTrack = player.getAudio();\n\n      // HLS streams don't always provide this, so we have to check\n      if (currentAudioTrack) {\n        this.selectItem(currentAudioTrack.id);\n      }\n    };\n\n    let updateAudioTracks = () => {\n      let audioTracks = player.getAvailableAudio();\n\n      this.clearItems();\n\n      // Add audio tracks\n      for (let audioTrack of audioTracks) {\n        this.addItem(audioTrack.id, audioTrack.label);\n      }\n\n      // Select the correct audio track after the tracks have been added\n      // This is also important in case we missed the `ON_AUDIO_CHANGED` event, e.g. when `playback.audioLanguage`\n      // is configured but the event is fired before the UI is created.\n      selectCurrentAudioTrack();\n    };\n\n    this.onItemSelected.subscribe((sender: AudioTrackSelectBox, value: string) => {\n      player.setAudio(value);\n    });\n\n    // Update selection when selected track has changed\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, selectCurrentAudioTrack);\n    // Update tracks when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateAudioTracks);\n    // Update tracks when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateAudioTracks);\n    // Update tracks when the period within a source changes\n    player.addEventHandler(player.EVENT.ON_PERIOD_SWITCHED, updateAudioTracks);\n    // Update tracks when a track is added or removed (since player 7.1.4)\n    if (player.EVENT.ON_AUDIO_ADDED && player.EVENT.ON_AUDIO_REMOVED) {\n      player.addEventHandler(player.EVENT.ON_AUDIO_ADDED, updateAudioTracks);\n      player.addEventHandler(player.EVENT.ON_AUDIO_REMOVED, updateAudioTracks);\n    }\n\n    // Populate tracks at startup\n    updateAudioTracks();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for the {@link BufferingOverlay} component.\n */\nexport interface BufferingOverlayConfig extends ContainerConfig {\n  /**\n   * Delay in milliseconds after which the buffering overlay will be displayed. Useful to bypass short stalls without\n   * displaying the overlay. Set to 0 to display the overlay instantly.\n   * Default: 1000ms (1 second)\n   */\n  showDelayMs?: number;\n}\n\n/**\n * Overlays the player and displays a buffering indicator.\n */\nexport class BufferingOverlay extends Container<BufferingOverlayConfig> {\n\n  private indicators: Component<ComponentConfig>[];\n\n  constructor(config: BufferingOverlayConfig = {}) {\n    super(config);\n\n    this.indicators = [\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n      new Component<ComponentConfig>({ tag: 'div', cssClass: 'ui-buffering-overlay-indicator' }),\n    ];\n\n    this.config = this.mergeConfig(config, <BufferingOverlayConfig>{\n      cssClass: 'ui-buffering-overlay',\n      hidden: true,\n      components: this.indicators,\n      showDelayMs: 1000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <BufferingOverlayConfig>this.getConfig();\n\n    let overlayShowTimeout = new Timeout(config.showDelayMs, () => {\n      this.show();\n    });\n\n    let showOverlay = () => {\n      overlayShowTimeout.start();\n    };\n\n    let hideOverlay = () => {\n      overlayShowTimeout.clear();\n      this.hide();\n    };\n\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, showOverlay);\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, hideOverlay);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, hideOverlay);\n\n    // Show overlay if player is already stalled at init\n    if (player.isStalled()) {\n      this.show();\n    }\n  }\n}\n","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Button} component.\n */\nexport interface ButtonConfig extends ComponentConfig {\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A simple clickable button.\n */\nexport class Button<Config extends ButtonConfig> extends Component<ButtonConfig> {\n\n  private buttonEvents = {\n    onClick: new EventDispatcher<Button<Config>, NoArgs>(),\n  };\n\n  constructor(config: ButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-button',\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    // Create the button element with the text label\n    let buttonElement = new DOM('button', {\n      'type': 'button',\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    }).append(new DOM('span', {\n      'class': this.prefixCss('label'),\n    }).html(this.config.text));\n\n    // Listen for the click event on the button element and trigger the corresponding event on the button component\n    buttonElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return buttonElement;\n  }\n\n  /**\n   * Sets text on the label of the button.\n   * @param text the text to put into the label of the button\n   */\n  setText(text: string): void {\n    this.getDomElement().find('.' + this.prefixCss('label')).html(text);\n  }\n\n  protected onClickEvent() {\n    this.buttonEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is clicked.\n   * @returns {Event<Button<Config>, NoArgs>}\n   */\n  get onClick(): Event<Button<Config>, NoArgs> {\n    return this.buttonEvents.onClick.getEvent();\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport CastWaitingForDeviceEvent = bitmovin.PlayerAPI.CastWaitingForDeviceEvent;\nimport CastStartedEvent = bitmovin.PlayerAPI.CastStartedEvent;\n\n/**\n * Overlays the player and displays the status of a Cast session.\n */\nexport class CastStatusOverlay extends Container<ContainerConfig> {\n\n  private statusLabel: Label<LabelConfig>;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.statusLabel = new Label<LabelConfig>({ cssClass: 'ui-cast-status-label' });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-cast-status-overlay',\n      components: [this.statusLabel],\n      hidden: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE,\n      (event: CastWaitingForDeviceEvent) => {\n        this.show();\n        // Get device name and update status text while connecting\n        let castDeviceName = event.castPayload.deviceName;\n        this.statusLabel.setText(`Connecting to <strong>${castDeviceName}</strong>...`);\n      });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, (event: CastStartedEvent) => {\n      // Session is started or resumed\n      // For cases when a session is resumed, we do not receive the previous events and therefore show the status panel\n      // here too\n      this.show();\n      let castDeviceName = event.deviceName;\n      this.statusLabel.setText(`Playing on <strong>${castDeviceName}</strong>`);\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, (event) => {\n      // Cast session gone, hide the status panel\n      this.hide();\n    });\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles casting to a Cast receiver.\n */\nexport class CastToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-casttogglebutton',\n      text: 'Google Cast',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      if (player.isCastAvailable()) {\n        if (player.isCasting()) {\n          player.castStop();\n        } else {\n          player.castVideo();\n        }\n      } else {\n        if (console) {\n          console.log('Cast unavailable');\n        }\n      }\n    });\n\n    let castAvailableHander = () => {\n      if (player.isCastAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_CAST_AVAILABLE, castAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_CAST_WAITING_FOR_DEVICE, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      // When a session is resumed, there is no ON_CAST_START event, so we also need to toggle here for such cases\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      this.off();\n    });\n\n    // Startup init\n    castAvailableHander(); // Hide button if Cast not available\n    if (player.isCasting()) {\n      this.on();\n    }\n  }\n}","import {UIContainer, UIContainerConfig} from './uicontainer';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * The base container for Cast receivers that contains all of the UI and takes care that the UI is shown on\n * certain playback events.\n */\nexport class CastUIContainer extends UIContainer {\n\n  private castUiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <UIContainerConfig>this.getConfig();\n\n    /*\n     * Show UI on Cast devices at certain playback events\n     *\n     * Since a Cast receiver does not have a direct HCI, we show the UI on certain playback events to give the user\n     * a chance to see on the screen what's going on, e.g. on play/pause or a seek the UI is shown and the user can\n     * see the current time and position on the seek bar.\n     * The UI is shown permanently while playback is paused, otherwise hides automatically after the configured\n     * hide delay time.\n     */\n\n    let isUiShown = false;\n\n    let hideUi = () => {\n      uimanager.onControlsHide.dispatch(this);\n      isUiShown = false;\n    };\n\n    this.castUiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    let showUi = () => {\n      if (!isUiShown) {\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n    };\n\n    let showUiPermanently = () => {\n      showUi();\n      this.castUiHideTimeout.clear();\n    };\n\n    let showUiWithTimeout = () => {\n      showUi();\n      this.castUiHideTimeout.start();\n    };\n\n    let showUiAfterSeek = () => {\n      if (player.isPlaying()) {\n        showUiWithTimeout();\n      } else {\n        showUiPermanently();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PLAY, showUiWithTimeout);\n    player.addEventHandler(player.EVENT.ON_PAUSED, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEK, showUiPermanently);\n    player.addEventHandler(player.EVENT.ON_SEEKED, showUiAfterSeek);\n  }\n\n  release(): void {\n    super.release();\n    this.castUiHideTimeout.clear();\n  }\n}","import {Button, ButtonConfig} from './button';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface ClickOverlayConfig extends ButtonConfig {\n  /**\n   * The url to open when the overlay is clicked. Set to null to disable the click handler.\n   */\n  url?: string;\n}\n\n/**\n * A click overlay that opens an url in a new tab if clicked.\n */\nexport class ClickOverlay extends Button<ClickOverlayConfig> {\n\n  constructor(config: ClickOverlayConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-clickoverlay',\n    }, <ClickOverlayConfig>this.config);\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    this.setUrl((<ClickOverlayConfig>this.config).url);\n    let element = this.getDomElement();\n    element.on('click', () => {\n      if (element.data('url')) {\n        window.open(element.data('url'), '_blank');\n      }\n    });\n  }\n\n  /**\n   * Gets the URL that should be followed when the watermark is clicked.\n   * @returns {string} the watermark URL\n   */\n  getUrl(): string {\n    return this.getDomElement().data('url');\n  }\n\n  setUrl(url: string): void {\n    if (url === undefined || url == null) {\n      url = '';\n    }\n    this.getDomElement().data('url', url);\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {UIInstanceManager} from '../uimanager';\nimport {Component, ComponentConfig} from './component';\n\n/**\n * Configuration interface for the {@link CloseButton}.\n */\nexport interface CloseButtonConfig extends ButtonConfig {\n  /**\n   * The component that should be closed when the button is clicked.\n   */\n  target: Component<ComponentConfig>;\n}\n\n/**\n * A button that closes (hides) a configured component.\n */\nexport class CloseButton extends Button<CloseButtonConfig> {\n\n  constructor(config: CloseButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-closebutton',\n      text: 'Close',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <CloseButtonConfig>this.getConfig();\n\n    this.onClick.subscribe(() => {\n      config.target.hide();\n    });\n  }\n}","import {Guid} from '../guid';\nimport {DOM} from '../dom';\nimport {EventDispatcher, NoArgs, Event} from '../eventdispatcher';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Base configuration interface for a component.\n * Should be extended by components that want to add additional configuration options.\n */\nexport interface ComponentConfig {\n  /**\n   * The HTML tag name of the component.\n   * Default: 'div'\n   */\n  tag?: string;\n  /**\n   * The HTML ID of the component.\n   * Default: automatically generated with pattern 'ui-id-{guid}'.\n   */\n  id?: string;\n\n  /**\n   * A prefix to prepend all CSS classes with.\n   */\n  cssPrefix?: string;\n\n  /**\n   * The CSS classes of the component. This is usually the class from where the component takes its styling.\n   */\n  cssClass?: string; // 'class' is a reserved keyword, so we need to make the name more complicated\n\n  /**\n   * Additional CSS classes of the component.\n   */\n  cssClasses?: string[];\n\n  /**\n   * Specifies if the component should be hidden at startup.\n   * Default: false\n   */\n  hidden?: boolean;\n}\n\nexport interface ComponentHoverChangedEventArgs extends NoArgs {\n  /**\n   * True is the component is hovered, else false.\n   */\n  hovered: boolean;\n}\n\n/**\n * The base class of the UI framework.\n * Each component must extend this class and optionally the config interface.\n */\nexport class Component<Config extends ComponentConfig> {\n\n  /**\n   * The classname that is attached to the element when it is in the hidden state.\n   * @type {string}\n   */\n  private static readonly CLASS_HIDDEN = 'hidden';\n\n  /**\n   * Configuration object of this component.\n   */\n  protected config: Config;\n\n  /**\n   * The component's DOM element.\n   */\n  private element: DOM;\n\n  /**\n   * Flag that keeps track of the hidden state.\n   */\n  private hidden: boolean;\n\n  /**\n   * Flag that keeps track of the hover state.\n   */\n  private hovered: boolean;\n\n  /**\n   * The list of events that this component offers. These events should always be private and only directly\n   * accessed from within the implementing component.\n   *\n   * Because TypeScript does not support private properties with the same name on different class hierarchy levels\n   * (i.e. superclass and subclass cannot contain a private property with the same name), the default naming\n   * convention for the event list of a component that should be followed by subclasses is the concatenation of the\n   * camel-cased class name + 'Events' (e.g. SubClass extends Component => subClassEvents).\n   * See {@link #componentEvents} for an example.\n   *\n   * Event properties should be named in camel case with an 'on' prefix and in the present tense. Async events may\n   * have a start event (when the operation starts) in the present tense, and must have an end event (when the\n   * operation ends) in the past tense (or present tense in special cases (e.g. onStart/onStarted or onPlay/onPlaying).\n   * See {@link #componentEvents#onShow} for an example.\n   *\n   * Each event should be accompanied with a protected method named by the convention eventName + 'Event'\n   * (e.g. onStartEvent), that actually triggers the event by calling {@link EventDispatcher#dispatch dispatch} and\n   * passing a reference to the component as first parameter. Components should always trigger their events with these\n   * methods. Implementing this pattern gives subclasses means to directly listen to the events by overriding the\n   * method (and saving the overhead of passing a handler to the event dispatcher) and more importantly to trigger\n   * these events without having access to the private event list.\n   * See {@link #onShow} for an example.\n   *\n   * To provide external code the possibility to listen to this component's events (subscribe, unsubscribe, etc.),\n   * each event should also be accompanied by a public getter function with the same name as the event's property,\n   * that returns the {@link Event} obtained from the event dispatcher by calling {@link EventDispatcher#getEvent}.\n   * See {@link #onShow} for an example.\n   *\n   * Full example for an event representing an example action in a example component:\n   *\n   * <code>\n   * // Define an example component class with an example event\n   * class ExampleComponent extends Component<ComponentConfig> {\n     *\n     *     private exampleComponentEvents = {\n     *         onExampleAction: new EventDispatcher<ExampleComponent, NoArgs>()\n     *     }\n     *\n     *     // constructor and other stuff...\n     *\n     *     protected onExampleActionEvent() {\n     *        this.exampleComponentEvents.onExampleAction.dispatch(this);\n     *    }\n     *\n     *    get onExampleAction(): Event<ExampleComponent, NoArgs> {\n     *        return this.exampleComponentEvents.onExampleAction.getEvent();\n     *    }\n     * }\n   *\n   * // Create an instance of the component somewhere\n   * var exampleComponentInstance = new ExampleComponent();\n   *\n   * // Subscribe to the example event on the component\n   * exampleComponentInstance.onExampleAction.subscribe(function (sender: ExampleComponent) {\n     *     console.log('onExampleAction of ' + sender + ' has fired!');\n     * });\n   * </code>\n   */\n  private componentEvents = {\n    onShow: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHide: new EventDispatcher<Component<Config>, NoArgs>(),\n    onHoverChanged: new EventDispatcher<Component<Config>, ComponentHoverChangedEventArgs>(),\n  };\n\n  /**\n   * Constructs a component with an optionally supplied config. All subclasses must call the constructor of their\n   * superclass and then merge their configuration into the component's configuration.\n   * @param config the configuration for the component\n   */\n  constructor(config: ComponentConfig = {}) {\n    // Create the configuration for this component\n    this.config = <Config>this.mergeConfig(config, {\n      tag: 'div',\n      id: 'mi-wbc-id-' + Guid.next(),\n      cssPrefix: 'mi-wbc',\n      cssClass: 'ui-component',\n      cssClasses: [],\n      hidden: false,\n    }, {});\n  }\n\n  /**\n   * Initializes the component, e.g. by applying config settings.\n   * This method must not be called from outside the UI framework.\n   *\n   * This method is automatically called by the {@link UIInstanceManager}. If the component is an inner component of\n   * some component, and thus encapsulated abd managed internally and never directly exposed to the UIManager,\n   * this method must be called from the managing component's {@link #initialize} method.\n   */\n  initialize(): void {\n    this.hidden = this.config.hidden;\n\n    // Hide the component at initialization if it is configured to be hidden\n    if (this.isHidden()) {\n      this.hidden = false; // Set flag to false for the following hide() call to work (hide() checks the flag)\n      this.hide();\n    }\n  }\n\n  /**\n   * Configures the component for the supplied Player and UIInstanceManager. This is the place where all the magic\n   * happens, where components typically subscribe and react to events (on their DOM element, the Player, or the\n   * UIInstanceManager), and basically everything that makes them interactive.\n   * This method is called only once, when the UIManager initializes the UI.\n   *\n   * Subclasses usually overwrite this method to add their own functionality.\n   *\n   * @param player the player which this component controls\n   * @param uimanager the UIInstanceManager that manages this component\n   */\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    this.onShow.subscribe(() => {\n      uimanager.onComponentShow.dispatch(this);\n    });\n    this.onHide.subscribe(() => {\n      uimanager.onComponentHide.dispatch(this);\n    });\n\n    // Track the hovered state of the element\n    this.getDomElement().on('mouseenter', () => {\n      this.onHoverChangedEvent(true);\n    });\n    this.getDomElement().on('mouseleave', () => {\n      this.onHoverChangedEvent(false);\n    });\n  }\n\n  /**\n   * Releases all resources and dependencies that the component holds. Player, DOM, and UIManager events are\n   * automatically removed during release and do not explicitly need to be removed here.\n   * This method is called by the UIManager when it releases the UI.\n   *\n   * Subclasses that need to release resources should override this method and call super.release().\n   */\n  release(): void {\n    // Nothing to do here, override where necessary\n  }\n\n  /**\n   * Generate the DOM element for this component.\n   *\n   * Subclasses usually overwrite this method to extend or replace the DOM element with their own design.\n   */\n  protected toDomElement(): DOM {\n    let element = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    });\n\n    return element;\n  }\n\n  /**\n   * Returns the DOM element of this component. Creates the DOM element if it does not yet exist.\n   *\n   * Should not be overwritten by subclasses.\n   *\n   * @returns {DOM}\n   */\n  getDomElement(): DOM {\n    if (!this.element) {\n      this.element = this.toDomElement();\n    }\n\n    return this.element;\n  }\n\n  /**\n   * Merges a configuration with a default configuration and a base configuration from the superclass.\n   *\n   * @param config the configuration settings for the components, as usually passed to the constructor\n   * @param defaults a default configuration for settings that are not passed with the configuration\n   * @param base configuration inherited from a superclass\n   * @returns {Config}\n   */\n  protected mergeConfig<Config>(config: Config, defaults: Config, base: Config): Config {\n    // Extend default config with supplied config\n    let merged = Object.assign({}, base, defaults, config);\n\n    // Return the extended config\n    return merged;\n  }\n\n  /**\n   * Helper method that returns a string of all CSS classes of the component.\n   *\n   * @returns {string}\n   */\n  protected getCssClasses(): string {\n    // Merge all CSS classes into single array\n    let flattenedArray = [this.config.cssClass].concat(this.config.cssClasses);\n    // Prefix classes\n    flattenedArray = flattenedArray.map((css) => {\n      return this.prefixCss(css);\n    });\n    // Join array values into a string\n    let flattenedString = flattenedArray.join(' ');\n    // Return trimmed string to prevent whitespace at the end from the join operation\n    return flattenedString.trim();\n  }\n\n  protected prefixCss(cssClassOrId: string): string {\n    return this.config.cssPrefix + '-' + cssClassOrId;\n  }\n\n  /**\n   * Returns the configuration object of the component.\n   * @returns {Config}\n   */\n  public getConfig(): Config {\n    return this.config;\n  }\n\n  /**\n   * Hides the component if shown.\n   * This method basically transfers the component into the hidden state. Actual hiding is done via CSS.\n   */\n  hide() {\n    if (!this.hidden) {\n      this.hidden = true;\n      this.getDomElement().addClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.onHideEvent();\n    }\n  }\n\n  /**\n   * Shows the component if hidden.\n   */\n  show() {\n    if (this.hidden) {\n      this.getDomElement().removeClass(this.prefixCss(Component.CLASS_HIDDEN));\n      this.hidden = false;\n      this.onShowEvent();\n    }\n  }\n\n  /**\n   * Determines if the component is hidden.\n   * @returns {boolean} true if the component is hidden, else false\n   */\n  isHidden(): boolean {\n    return this.hidden;\n  }\n\n  /**\n   * Determines if the component is shown.\n   * @returns {boolean} true if the component is visible, else false\n   */\n  isShown(): boolean {\n    return !this.isHidden();\n  }\n\n  /**\n   * Toggles the hidden state by hiding the component if it is shown, or showing it if hidden.\n   */\n  toggleHidden() {\n    if (this.isHidden()) {\n      this.show();\n    } else {\n      this.hide();\n    }\n  }\n\n  /**\n   * Determines if the component is currently hovered.\n   * @returns {boolean} true if the component is hovered, else false\n   */\n  isHovered(): boolean {\n    return this.hovered;\n  }\n\n  /**\n   * Fires the onShow event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onShowEvent(): void {\n    this.componentEvents.onShow.dispatch(this);\n  }\n\n  /**\n   * Fires the onHide event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHideEvent(): void {\n    this.componentEvents.onHide.dispatch(this);\n  }\n\n  /**\n   * Fires the onHoverChanged event.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   */\n  protected onHoverChangedEvent(hovered: boolean): void {\n    this.hovered = hovered;\n    this.componentEvents.onHoverChanged.dispatch(this, { hovered: hovered });\n  }\n\n  /**\n   * Gets the event that is fired when the component is showing.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onShow(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onShow.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component is hiding.\n   * See the detailed explanation on event architecture on the {@link #componentEvents events list}.\n   * @returns {Event<Component<Config>, NoArgs>}\n   */\n  get onHide(): Event<Component<Config>, NoArgs> {\n    return this.componentEvents.onHide.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the component's hover-state is changing.\n   * @returns {Event<Component<Config>, ComponentHoverChangedEventArgs>}\n   */\n  get onHoverChanged(): Event<Component<Config>, ComponentHoverChangedEventArgs> {\n    return this.componentEvents.onHoverChanged.getEvent();\n  }\n}","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {ArrayUtils} from '../arrayutils';\n\n/**\n * Configuration interface for a {@link Container}.\n */\nexport interface ContainerConfig extends ComponentConfig {\n  /**\n   * Child components of the container.\n   */\n  components?: Component<ComponentConfig>[];\n}\n\n/**\n * A container component that can contain a collection of child components.\n * Components can be added at construction time through the {@link ContainerConfig#components} setting, or later\n * through the {@link Container#addComponent} method. The UIManager automatically takes care of all components, i.e. it\n * initializes and configures them automatically.\n *\n * In the DOM, the container consists of an outer <div> (that can be configured by the config) and an inner wrapper\n * <div> that contains the components. This double-<div>-structure is often required to achieve many advanced effects\n * in CSS and/or JS, e.g. animations and certain formatting with absolute positioning.\n *\n * DOM example:\n * <code>\n *     <div class='ui-container'>\n *         <div class='container-wrapper'>\n *             ... child components ...\n *         </div>\n *     </div>\n * </code>\n */\nexport class Container<Config extends ContainerConfig> extends Component<ContainerConfig> {\n\n  /**\n   * A reference to the inner element that contains the components of the container.\n   */\n  private innerContainerElement: DOM;\n  private componentsToAdd: Component<ComponentConfig>[];\n  private componentsToRemove: Component<ComponentConfig>[];\n\n  constructor(config: Config) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-container',\n      components: [],\n    }, this.config);\n\n    this.componentsToAdd = [];\n    this.componentsToRemove = [];\n  }\n\n  /**\n   * Adds a child component to the container.\n   * @param component the component to add\n   */\n  addComponent(component: Component<ComponentConfig>) {\n    this.config.components.push(component);\n    this.componentsToAdd.push(component);\n  }\n\n  /**\n   * Removes a child component from the container.\n   * @param component the component to remove\n   * @returns {boolean} true if the component has been removed, false if it is not contained in this container\n   */\n  removeComponent(component: Component<ComponentConfig>): boolean {\n    if (ArrayUtils.remove(this.config.components, component) != null) {\n      this.componentsToRemove.push(component);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * Gets an array of all child components in this container.\n   * @returns {Component<ComponentConfig>[]}\n   */\n  getComponents(): Component<ComponentConfig>[] {\n    return this.config.components;\n  }\n\n  /**\n   * Removes all child components from the container.\n   */\n  removeComponents(): void {\n    for (let component of this.getComponents().slice()) {\n      this.removeComponent(component);\n    }\n  }\n\n  /**\n   * Updates the DOM of the container with the current components.\n   */\n  protected updateComponents(): void {\n    /* We cannot just clear the container to remove all elements and then re-add those that should stay, because\n     * IE looses the innerHTML of unattached elements, leading to empty elements within the container (e.g. missing\n     * subtitle text in SubtitleLabel).\n     * Instead, we keep a list of elements to add and remove, leaving remaining elements alone. By keeping them in\n     * the DOM, their content gets preserved in all browsers.\n     */\n    let component;\n\n    while (component = this.componentsToRemove.shift()) {\n      component.getDomElement().remove();\n    }\n\n    while (component = this.componentsToAdd.shift()) {\n      this.innerContainerElement.append(component.getDomElement());\n    }\n  }\n\n  protected toDomElement(): DOM {\n    // Create the container element (the outer <div>)\n    let containerElement = new DOM(this.config.tag, {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    });\n\n    // Create the inner container element (the inner <div>) that will contain the components\n    let innerContainer = new DOM(this.config.tag, {\n      'class': this.prefixCss('container-wrapper'),\n    });\n    this.innerContainerElement = innerContainer;\n\n    for (let initialComponent of this.config.components) {\n      this.componentsToAdd.push(initialComponent);\n    }\n    this.updateComponents();\n\n    containerElement.append(innerContainer);\n\n    return containerElement;\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {UIUtils} from '../uiutils';\nimport {Spacer} from './spacer';\n\n/**\n * Configuration interface for the {@link ControlBar}.\n */\nexport interface ControlBarConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A container for main player control components, e.g. play toggle button, seek bar, volume control, fullscreen toggle\n * button.\n */\nexport class ControlBar extends Container<ControlBarConfig> {\n\n  constructor(config: ControlBarConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-controlbar',\n      hidden: true,\n    }, <ControlBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    // Counts how many components are hovered and block hiding of the control bar\n    let hoverStackCount = 0;\n\n    // Track hover status of child components\n    UIUtils.traverseTree(this, (component) => {\n      // Do not track hover status of child containers or spacers, only of 'real' controls\n      if (component instanceof Container || component instanceof Spacer) {\n        return;\n      }\n\n      // Subscribe hover event and keep a count of the number of hovered children\n      component.onHoverChanged.subscribe((sender, args) => {\n        if (args.hovered) {\n          hoverStackCount++;\n        } else {\n          hoverStackCount--;\n        }\n      });\n    });\n\n    uimanager.onControlsShow.subscribe(() => {\n      this.show();\n    });\n    uimanager.onPreviewControlsHide.subscribe((sender, args) => {\n      // Cancel the hide event if hovered child components block hiding\n      args.cancel = (hoverStackCount > 0);\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      this.hide();\n    });\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Label, LabelConfig} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport ErrorEvent = bitmovin.PlayerAPI.ErrorEvent;\nimport {TvNoiseCanvas} from './tvnoisecanvas';\nimport PlayerEvent = bitmovin.PlayerAPI.PlayerEvent;\n\nexport interface ErrorMessageTranslator {\n  (error: ErrorEvent): string;\n}\n\nexport interface ErrorMessageMap {\n  [code: number]: string | ErrorMessageTranslator;\n}\n\n/**\n * Configuration interface for the {@link ErrorMessageOverlay}.\n */\nexport interface ErrorMessageOverlayConfig extends ContainerConfig {\n  /**\n   * Allows overwriting of the error messages displayed in the overlay for customization and localization.\n   * This is either a function that receives any {@link ErrorEvent} as parameter and translates error messages,\n   * or a map of error codes that overwrites specific error messages with a plain string or a function that\n   * receives the {@link ErrorEvent} as parameter and returns a customized string.\n   * The translation functions can be used to extract data (e.g. parameters) from the original error message.\n   *\n   * Example 1 (catch-all translation function):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: function(error) {\n   *     switch (error.code) {\n   *       // Overwrite error 3000 'Unknown error'\n   *       case 3000:\n   *         return 'Houston, we have a problem'\n   *\n   *       // Transform error 3001 'Unsupported manifest format' to uppercase\n   *       case 3001:\n   *         return error.message.toUpperCase();\n   *\n   *       // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *       case 3006:\n   *         var statusCode = error.message.substring(46);\n   *         return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *     // Return unmodified error message for all other errors\n   *     return error.message;\n   *   }\n   * };\n   * </code>\n   *\n   * Example 2 (translating specific errors):\n   * <code>\n   * errorMessageOverlayConfig = {\n   *   messages: {\n   *     // Overwrite error 3000 'Unknown error'\n   *     3000: 'Houston, we have a problem',\n   *\n   *     // Transform error 3001 'Unsupported manifest format' to uppercase\n   *     3001: function(error) {\n   *       return error.message.toUpperCase();\n   *     },\n   *\n   *     // Customize error 3006 'Could not load manifest, got HTTP status code XXX'\n   *     3006: function(error) {\n   *       var statusCode = error.message.substring(46);\n   *       return 'Manifest loading failed with HTTP error ' + statusCode;\n   *     }\n   *   }\n   * };\n   * </code>\n   */\n  messages?: ErrorMessageMap | ErrorMessageTranslator;\n}\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class ErrorMessageOverlay extends Container<ErrorMessageOverlayConfig> {\n\n  private errorLabel: Label<LabelConfig>;\n  private tvNoiseBackground: TvNoiseCanvas;\n\n  constructor(config: ErrorMessageOverlayConfig = {}) {\n    super(config);\n\n    this.errorLabel = new Label<LabelConfig>({ cssClass: 'ui-errormessage-label' });\n    this.tvNoiseBackground = new TvNoiseCanvas();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-errormessage-overlay',\n      components: [this.tvNoiseBackground, this.errorLabel],\n      hidden: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <ErrorMessageOverlayConfig>this.getConfig();\n\n    player.addEventHandler(player.EVENT.ON_ERROR, (event: ErrorEvent) => {\n      let message = event.message;\n\n      // Process message translations\n      if (config.messages) {\n        if (typeof config.messages === 'function') {\n          // Translation function for all errors\n          message = config.messages(event);\n        } else if (config.messages[event.code]) {\n          // It's not a translation function, so it must be a map of strings or translation functions\n          let customMessage = config.messages[event.code];\n\n          if (typeof customMessage === 'string') {\n            message = customMessage;\n          } else {\n            // The message is a translation function, so we call it\n            message = customMessage(event);\n          }\n        }\n      }\n\n      this.errorLabel.setText(message);\n      this.tvNoiseBackground.start();\n      this.show();\n    });\n\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, (event: PlayerEvent) => {\n      if (this.isShown()) {\n        this.tvNoiseBackground.stop();\n        this.hide();\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n\n    // Canvas rendering must be explicitly stopped, else it just continues forever and hogs resources\n    this.tvNoiseBackground.stop();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the player between windowed and fullscreen view.\n */\nexport class FullscreenToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-fullscreentogglebutton',\n      text: 'Fullscreen',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let fullscreenStateHandler = () => {\n      if (player.isFullscreen()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, fullscreenStateHandler);\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, fullscreenStateHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    });\n\n    // Startup init\n    fullscreenStateHandler();\n  }\n}","import {ToggleButtonConfig} from './togglebutton';\nimport {PlaybackToggleButton} from './playbacktogglebutton';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.PlayerAPI.PlayerEvent;\nimport WarningEvent = bitmovin.PlayerAPI.WarningEvent;\n\n/**\n * A button that overlays the video and toggles between playback and pause.\n */\nexport class HugePlaybackToggleButton extends PlaybackToggleButton {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugeplaybacktogglebutton',\n      text: 'Play/Pause',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    // Update button state through API events\n    super.configure(player, uimanager, false);\n\n    let togglePlayback = () => {\n      if (player.isPlaying()) {\n        player.pause('ui');\n      } else {\n        player.play('ui');\n      }\n    };\n\n    let toggleFullscreen = () => {\n      if (player.isFullscreen()) {\n        player.exitFullscreen();\n      } else {\n        player.enterFullscreen();\n      }\n    };\n\n    let firstPlay = true;\n    let clickTime = 0;\n    let doubleClickTime = 0;\n\n    /*\n     * YouTube-style toggle button handling\n     *\n     * The goal is to prevent a short pause or playback interval between a click, that toggles playback, and a\n     * double click, that toggles fullscreen. In this naive approach, the first click would e.g. start playback,\n     * the second click would be detected as double click and toggle to fullscreen, and as second normal click stop\n     * playback, which results is a short playback interval with max length of the double click detection\n     * period (usually 500ms).\n     *\n     * To solve this issue, we defer handling of the first click for 200ms, which is almost unnoticeable to the user,\n     * and just toggle playback if no second click (double click) has been registered during this period. If a double\n     * click is registered, we just toggle the fullscreen. In the first 200ms, undesired playback changes thus cannot\n     * happen. If a double click is registered within 500ms, we undo the playback change and switch fullscreen mode.\n     * In the end, this method basically introduces a 200ms observing interval in which playback changes are prevented\n     * if a double click happens.\n     */\n    this.onClick.subscribe(() => {\n      // Directly start playback on first click of the button.\n      // This is a required workaround for mobile browsers where video playback needs to be triggered directly\n      // by the user. A deferred playback start through the timeout below is not considered as user action and\n      // therefore ignored by mobile browsers.\n      if (firstPlay) {\n        // Try to start playback. Then we wait for ON_PLAY and only when it arrives, we disable the firstPlay flag.\n        // If we disable the flag here, onClick was triggered programmatically instead of by a user interaction, and\n        // playback is blocked (e.g. on mobile devices due to the programmatic play() call), we loose the chance to\n        // ever start playback through a user interaction again with this button.\n        togglePlayback();\n        return;\n      }\n\n      let now = Date.now();\n\n      if (now - clickTime < 200) {\n        // We have a double click inside the 200ms interval, just toggle fullscreen mode\n        toggleFullscreen();\n        doubleClickTime = now;\n        return;\n      } else if (now - clickTime < 500) {\n        // We have a double click inside the 500ms interval, undo playback toggle and toggle fullscreen mode\n        toggleFullscreen();\n        togglePlayback();\n        doubleClickTime = now;\n        return;\n      }\n\n      clickTime = now;\n\n      setTimeout(() => {\n        if (Date.now() - doubleClickTime > 200) {\n          // No double click detected, so we toggle playback and wait what happens next\n          togglePlayback();\n        }\n      }, 200);\n    });\n\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      // Playback has really started, we can disable the flag to switch to normal toggle button handling\n      firstPlay = false;\n    });\n\n    player.addEventHandler(player.EVENT.ON_WARNING, (event: WarningEvent) => {\n      // 5008 == Playback could not be started\n      if (event.code === 5008) {\n        // if playback could not be started, reset the first play flag as we need the user interaction to start\n        firstPlay = true;\n      }\n    });\n\n    // Hide button while initializing a Cast session\n    let castInitializationHandler = (event: PlayerEvent) => {\n      if (event.type === player.EVENT.ON_CAST_START) {\n        // Hide button when session is being initialized\n        this.hide();\n      } else {\n        // Show button when session is established or initialization was aborted\n        this.show();\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_CAST_START, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, castInitializationHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, castInitializationHandler);\n\n    const suppressPlayButtonTransitionAnimation = () => {\n      // Disable the current animation\n      this.setTransitionAnimationsEnabled(false);\n\n      // Enable the transition animations for the next state change\n      this.onToggle.subscribeOnce(() => {\n        this.setTransitionAnimationsEnabled(true);\n      });\n    };\n\n    // Hide the play button animation when the UI is loaded (it should only be animated on state changes)\n    suppressPlayButtonTransitionAnimation();\n\n    const isAutoplayEnabled = player.getConfig().playback && Boolean(player.getConfig().playback.autoplay);\n    // We only know if an autoplay attempt is upcoming if the player is not yet ready. It the player is already ready,\n    // the attempt might be upcoming or might have already happened, but we don't have to handle that because we can\n    // simply rely on isPlaying and the play state events.\n    const isAutoplayUpcoming = !player.isReady() && isAutoplayEnabled;\n\n    // Hide the play button when the player is already playing or autoplay is upcoming\n    if (player.isPlaying() || isAutoplayUpcoming) {\n      // Hide the play button (switch to playing state)\n      this.on();\n      // Disable the animation of the playing state switch\n      suppressPlayButtonTransitionAnimation();\n\n      // Show the play button without an animation if a play attempt is blocked\n      player.addEventHandler(player.EVENT.ON_WARNING, (event: WarningEvent) => {\n        if (event.code === 5008) {\n          suppressPlayButtonTransitionAnimation();\n        }\n      });\n    }\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image'),\n    }));\n\n    return buttonElement;\n  }\n\n  /**\n   * Enables or disables the play state transition animations of the play button image. Can be used to suppress\n   * animations.\n   * @param {boolean} enabled true to enable the animations (default), false to disable them\n   */\n  protected setTransitionAnimationsEnabled(enabled: boolean): void {\n    const noTransitionAnimationsClass = this.prefixCss('no-transition-animations');\n\n    if (enabled) {\n      this.getDomElement().removeClass(noTransitionAnimationsClass);\n    } else if (!this.getDomElement().hasClass(noTransitionAnimationsClass)) {\n      this.getDomElement().addClass(noTransitionAnimationsClass);\n    }\n  }\n}","import {ButtonConfig, Button} from './button';\nimport {DOM} from '../dom';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button to play/replay a video.\n */\nexport class HugeReplayButton extends Button<ButtonConfig> {\n\n  constructor(config: ButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-hugereplaybutton',\n      text: 'Replay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      player.play('ui');\n    });\n  }\n\n  protected toDomElement(): DOM {\n    let buttonElement = super.toDomElement();\n\n    // Add child that contains the play button image\n    // Setting the image directly on the button does not work together with scaling animations, because the button\n    // can cover the whole video player are and scaling would extend it beyond. By adding an inner element, confined\n    // to the size if the image, it can scale inside the player without overshooting.\n    buttonElement.append(new DOM('div', {\n      'class': this.prefixCss('image'),\n    }));\n\n    return buttonElement;\n  }\n}","import {ListSelector, ListSelectorConfig} from './listselector';\nimport {DOM} from '../dom';\n\nexport class ItemSelectionList extends ListSelector<ListSelectorConfig> {\n\n  private static readonly CLASS_SELECTED = 'selected';\n\n  private listElement: DOM;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      tag: 'ul',\n      cssClass: 'ui-itemselectionlist',\n    }, this.config);\n  }\n\n  protected isActive(): boolean {\n    return this.items.length > 1;\n  }\n\n  protected toDomElement(): DOM {\n    let listElement = new DOM('ul', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    });\n\n    this.listElement = listElement;\n    this.updateDomItems();\n\n    return listElement;\n  }\n\n  protected updateDomItems(selectedValue: string = null) {\n    // Delete all children\n    this.listElement.empty();\n\n    let selectedListItem: DOM = null;\n\n    const selectItem = (listItem: DOM) => {\n      listItem.addClass(this.prefixCss(ItemSelectionList.CLASS_SELECTED));\n    };\n\n    const deselectItem = (listItem: DOM) => {\n      listItem.removeClass(this.prefixCss(ItemSelectionList.CLASS_SELECTED));\n    };\n\n    for (let item of this.items) {\n      let listItem = new DOM('li', {\n        'type': 'li',\n        'class': this.prefixCss('ui-selectionlistitem'),\n      }).append(new DOM('a', {\n      }).html(item.label));\n\n      if (!selectedListItem) {\n        if (selectedValue == null) { // If there is no pre-selected value, select the first one\n          selectedListItem = listItem;\n        } else if (String(selectedValue) === item.key) { // convert selectedValue to string to catch 'null'/null case\n          selectedListItem = listItem;\n        }\n      }\n\n      // Handle list item selections\n      listItem.on('click', () => {\n        // Deselect the previous item (if there was a selected item)\n        if (selectedListItem) {\n          deselectItem(selectedListItem);\n        }\n\n        // Select the clicked item\n        selectedListItem = listItem;\n        selectItem(listItem);\n\n        // Fire the event\n        this.onItemSelectedEvent(item.key, false);\n      });\n\n      // Select default item\n      if (selectedListItem) {\n        selectItem(selectedListItem);\n      }\n\n      this.listElement.append(listItem);\n    }\n  }\n\n  protected onItemAddedEvent(value: string) {\n    super.onItemAddedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemRemovedEvent(value: string) {\n    super.onItemRemovedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemSelectedEvent(value: string, updateDomItems: boolean = true) {\n    super.onItemSelectedEvent(value);\n    if (updateDomItems) {\n      this.updateDomItems(value);\n    }\n  }\n}\n","import {ComponentConfig, Component} from './component';\nimport {DOM} from '../dom';\nimport {EventDispatcher, Event, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link Label} component.\n */\nexport interface LabelConfig extends ComponentConfig {\n  /**\n   * The text on the label.\n   */\n  text?: string;\n}\n\n/**\n * A simple text label.\n *\n * DOM example:\n * <code>\n *     <span class='ui-label'>...some text...</span>\n * </code>\n */\nexport class Label<Config extends LabelConfig> extends Component<LabelConfig> {\n\n  private text: string;\n\n  private labelEvents = {\n    onClick: new EventDispatcher<Label<Config>, NoArgs>(),\n    onTextChanged: new EventDispatcher<Label<Config>, string>(),\n  };\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-label',\n    }, this.config);\n\n    this.text = this.config.text;\n  }\n\n  protected toDomElement(): DOM {\n    let labelElement = new DOM('span', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    }).html(this.text);\n\n    labelElement.on('click', () => {\n      this.onClickEvent();\n    });\n\n    return labelElement;\n  }\n\n  /**\n   * Set the text on this label.\n   * @param text\n   */\n  setText(text: string) {\n    this.text = text;\n    this.getDomElement().html(text);\n    this.onTextChangedEvent(text);\n  }\n\n  /**\n   * Gets the text on this label.\n   * @return {string} The text on the label\n   */\n  getText(): string {\n    return this.text;\n  }\n\n  /**\n   * Clears the text on this label.\n   */\n  clearText() {\n    this.getDomElement().html('');\n    this.onTextChangedEvent(null);\n  }\n\n  /**\n   * Tests if the label is empty and does not contain any text.\n   * @return {boolean} True if the label is empty, else false\n   */\n  isEmpty(): boolean {\n    return !this.text;\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onClickEvent() {\n    this.labelEvents.onClick.dispatch(this);\n  }\n\n  /**\n   * Fires the {@link #onClick} event.\n   * Can be used by subclasses to listen to this event without subscribing an event listener by overwriting the method\n   * and calling the super method.\n   */\n  protected onTextChangedEvent(text: string) {\n    this.labelEvents.onTextChanged.dispatch(this, text);\n  }\n\n  /**\n   * Gets the event that is fired when the label is clicked.\n   * @returns {Event<Label<LabelConfig>, NoArgs>}\n   */\n  get onClick(): Event<Label<LabelConfig>, NoArgs> {\n    return this.labelEvents.onClick.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the text on the label is changed.\n   * @returns {Event<Label<LabelConfig>, string>}\n   */\n  get onTextChanged(): Event<Label<LabelConfig>, string> {\n    return this.labelEvents.onTextChanged.getEvent();\n  }\n}\n","import {Component, ComponentConfig} from './component';\nimport {EventDispatcher, Event} from '../eventdispatcher';\nimport {ArrayUtils} from '../arrayutils';\n\n/**\n * A map of items (key/value -> label} for a {@link ListSelector} in a {@link ListSelectorConfig}.\n */\nexport interface ListItem {\n  key: string;\n  label: string;\n}\n\n/**\n * Filter function that can be used to filter out list items added through {@link ListSelector.addItem}.\n *\n * This is intended to be used in conjunction with subclasses that populate themselves automatically\n * via the player API, e.g. {@link SubtitleSelectBox}.\n */\nexport interface ListItemFilter {\n  /**\n   * Takes a list item and decides whether it should pass or be discarded.\n   * @param {ListItem} listItem the item to apply the filter to\n   * @returns {boolean} true to let the item pass through the filter, false to discard the item\n   */\n  (listItem: ListItem): boolean;\n}\n\n/**\n * Translator function to translate labels of list items added through {@link ListSelector.addItem}.\n *\n * This is intended to be used in conjunction with subclasses that populate themselves automatically\n * via the player API, e.g. {@link SubtitleSelectBox}.\n */\nexport interface ListItemLabelTranslator {\n  /**\n   * Takes a list item, optionally changes the label, and returns the new label.\n   * @param {ListItem} listItem the item to translate\n   * @returns {string} the translated or original label\n   */\n  (listItem: ListItem): string;\n}\n\n/**\n * Configuration interface for a {@link ListSelector}.\n */\nexport interface ListSelectorConfig extends ComponentConfig {\n  items?: ListItem[];\n  filter?: ListItemFilter;\n  translator?: ListItemLabelTranslator;\n}\n\nexport abstract class ListSelector<Config extends ListSelectorConfig> extends Component<ListSelectorConfig> {\n\n  protected items: ListItem[];\n  protected selectedItem: string;\n\n  private listSelectorEvents = {\n    onItemAdded: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemRemoved: new EventDispatcher<ListSelector<Config>, string>(),\n    onItemSelected: new EventDispatcher<ListSelector<Config>, string>(),\n  };\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      items: [],\n      cssClass: 'ui-listselector',\n    }, this.config);\n\n    this.items = this.config.items;\n  }\n\n  private getItemIndex(key: string): number {\n    for (let index in this.items) {\n      if (key === this.items[index].key) {\n        return parseInt(index);\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Checks if the specified item is part of this selector.\n   * @param key the key of the item to check\n   * @returns {boolean} true if the item is part of this selector, else false\n   */\n  hasItem(key: string): boolean {\n    return this.getItemIndex(key) > -1;\n  }\n\n  /**\n   * Adds an item to this selector by appending it to the end of the list of items. If an item with the specified\n   * key already exists, it is replaced.\n   * @param key the key of the item to add\n   * @param label the (human-readable) label of the item to add\n   */\n  addItem(key: string, label: string) {\n    const listItem = { key: key, label: label };\n\n    // Apply filter function\n    if (this.config.filter && !this.config.filter(listItem)) {\n      return;\n    }\n\n    // Apply translator function\n    if (this.config.translator) {\n      listItem.label = this.config.translator(listItem);\n    }\n\n    this.removeItem(key); // Try to remove key first to get overwrite behavior and avoid duplicate keys\n    this.items.push(listItem);\n    this.onItemAddedEvent(key);\n  }\n\n  /**\n   * Removes an item from this selector.\n   * @param key the key of the item to remove\n   * @returns {boolean} true if removal was successful, false if the item is not part of this selector\n   */\n  removeItem(key: string): boolean {\n    let index = this.getItemIndex(key);\n    if (index > -1) {\n      ArrayUtils.remove(this.items, this.items[index]);\n      this.onItemRemovedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Selects an item from the items in this selector.\n   * @param key the key of the item to select\n   * @returns {boolean} true is the selection was successful, false if the selected item is not part of the selector\n   */\n  selectItem(key: string): boolean {\n    if (key === this.selectedItem) {\n      // itemConfig is already selected, suppress any further action\n      return true;\n    }\n\n    let index = this.getItemIndex(key);\n\n    if (index > -1) {\n      this.selectedItem = key;\n      this.onItemSelectedEvent(key);\n      return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Returns the key of the selected item.\n   * @returns {string} the key of the selected item or null if no item is selected\n   */\n  getSelectedItem(): string | null {\n    return this.selectedItem;\n  }\n\n  /**\n   * Removes all items from this selector.\n   */\n  clearItems() {\n    // local copy for iteration after clear\n    let items = this.items;\n    // clear items\n    this.items = [];\n\n    // clear the selection as the selected item is also removed\n    this.selectedItem = null;\n\n    // fire events\n    for (let item of items) {\n      this.onItemRemovedEvent(item.key);\n    }\n  }\n\n  /**\n   * Returns the number of items in this selector.\n   * @returns {number}\n   */\n  itemCount(): number {\n    return Object.keys(this.items).length;\n  }\n\n  protected onItemAddedEvent(key: string) {\n    this.listSelectorEvents.onItemAdded.dispatch(this, key);\n  }\n\n  protected onItemRemovedEvent(key: string) {\n    this.listSelectorEvents.onItemRemoved.dispatch(this, key);\n  }\n\n  protected onItemSelectedEvent(key: string) {\n    this.listSelectorEvents.onItemSelected.dispatch(this, key);\n  }\n\n  /**\n   * Gets the event that is fired when an item is added to the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemAdded(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemAdded.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is removed from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemRemoved(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemRemoved.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when an item is selected from the list of items.\n   * @returns {Event<ListSelector<Config>, string>}\n   */\n  get onItemSelected(): Event<ListSelector<Config>, string> {\n    return this.listSelectorEvents.onItemSelected.getEvent();\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Enumerates the types of content that the {@link MetadataLabel} can display.\n */\nexport enum MetadataLabelContent {\n  /**\n   * Title of the data source.\n   */\n  Title,\n  /**\n   * Description fo the data source.\n   */\n  Description,\n}\n\n/**\n * Configuration interface for {@link MetadataLabel}.\n */\nexport interface MetadataLabelConfig extends LabelConfig {\n  /**\n   * The type of content that should be displayed in the label.\n   */\n  content: MetadataLabelContent;\n}\n\n/**\n * A label that can be configured to display certain metadata.\n */\nexport class MetadataLabel extends Label<MetadataLabelConfig> {\n\n  constructor(config: MetadataLabelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClasses: ['label-metadata', 'label-metadata-' + MetadataLabelContent[config.content].toLowerCase()],\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <MetadataLabelConfig>this.getConfig();\n    let uiconfig = uimanager.getConfig();\n\n    let init = () => {\n      switch (config.content) {\n        case MetadataLabelContent.Title:\n          this.setText(uiconfig.metadata.title);\n          break;\n        case MetadataLabelContent.Description:\n          this.setText(uiconfig.metadata.description);\n          break;\n      }\n    };\n\n    let unload = () => {\n      this.setText(null);\n    };\n\n    // Init label\n    init();\n    // Reinit label when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, init);\n    // Clear labels when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, unload);\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles Apple macOS picture-in-picture mode.\n */\nexport class PictureInPictureToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-piptogglebutton',\n      text: 'Picture-in-Picture',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    if (!player.isPictureInPictureAvailable) {\n      // If the player does not support PIP (player 7.0), we just hide this component and skip configuration\n      this.hide();\n      return;\n    }\n\n    this.onClick.subscribe(() => {\n      if (player.isPictureInPictureAvailable()) {\n        if (player.isPictureInPicture()) {\n          player.exitPictureInPicture();\n        } else {\n          player.enterPictureInPicture();\n        }\n      } else {\n        if (console) {\n          console.log('PIP unavailable');\n        }\n      }\n    });\n\n    let pipAvailableHander = () => {\n      if (player.isPictureInPictureAvailable()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, pipAvailableHander);\n\n    // Toggle button 'on' state\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_ENTER, () => {\n      this.on();\n    });\n    player.addEventHandler(player.EVENT.ON_PICTURE_IN_PICTURE_EXIT, () => {\n      this.off();\n    });\n\n    // Startup init\n    pipAvailableHander(); // Hide button if PIP not available\n    if (player.isPictureInPicture()) {\n      this.on();\n    }\n  }\n}","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection of different playback speeds.\n */\nexport class PlaybackSpeedSelectBox extends SelectBox {\n  protected defaultPlaybackSpeeds: number[];\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n    this.defaultPlaybackSpeeds = [0.25, 0.5, 1, 1.5, 2];\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addDefaultItems();\n\n    this.onItemSelected.subscribe((sender: PlaybackSpeedSelectBox, value: string) => {\n      player.setPlaybackSpeed(parseFloat(value));\n      this.selectItem(value);\n    });\n\n    const setDefaultValue = (): void => {\n      const playbackSpeed = player.getPlaybackSpeed();\n      this.setSpeed(playbackSpeed);\n    };\n\n    // when the player hits onReady again, adjust the playback speed selection\n    player.addEventHandler(player.EVENT.ON_READY, setDefaultValue);\n\n    if (player.EVENT.ON_PLAYBACK_SPEED_CHANGED) {\n      // Since player 7.8.0\n      player.addEventHandler(player.EVENT.ON_PLAYBACK_SPEED_CHANGED, setDefaultValue);\n    }\n  }\n\n  setSpeed(speed: number): void {\n    if (!this.selectItem(String(speed))) {\n      // a playback speed was set which is not in the list, add it to the list to show it to the user\n      this.clearItems();\n      this.addDefaultItems([speed]);\n      this.selectItem(String(speed));\n    }\n  }\n\n  addDefaultItems(customItems: number[] = []): void {\n    const sortedSpeeds = this.defaultPlaybackSpeeds.concat(customItems).sort();\n\n    sortedSpeeds.forEach(element => {\n      if (element !== 1) {\n        this.addItem(String(element), `${element}x`);\n      } else {\n        this.addItem(String(element), 'Normal');\n      }\n    });\n  }\n\n  clearItems(): void {\n    this.items = [];\n    this.selectedItem = null;\n  }\n}","import {LabelConfig, Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\nimport {PlayerUtils} from '../playerutils';\nimport {StringUtils} from '../stringutils';\n\nexport enum PlaybackTimeLabelMode {\n  CurrentTime,\n  TotalTime,\n  CurrentAndTotalTime,\n}\n\nexport interface PlaybackTimeLabelConfig extends LabelConfig {\n  timeLabelMode?: PlaybackTimeLabelMode;\n  hideInLivePlayback?: boolean;\n}\n\n/**\n * A label that display the current playback time and the total time through {@link PlaybackTimeLabel#setTime setTime}\n * or any string through {@link PlaybackTimeLabel#setText setText}.\n */\nexport class PlaybackTimeLabel extends Label<PlaybackTimeLabelConfig> {\n\n  private timeFormat: string;\n\n  constructor(config: PlaybackTimeLabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <PlaybackTimeLabelConfig>{\n      cssClass: 'ui-playbacktimelabel',\n      timeLabelMode: PlaybackTimeLabelMode.CurrentAndTotalTime,\n      hideInLivePlayback: false,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <PlaybackTimeLabelConfig>this.getConfig();\n    let live = false;\n    let liveCssClass = this.prefixCss('ui-playbacktimelabel-live');\n    let liveEdgeCssClass = this.prefixCss('ui-playbacktimelabel-live-edge');\n    let minWidth = 0;\n\n    let liveClickHandler = () => {\n      player.timeShift(0);\n    };\n\n    let updateLiveState = () => {\n      // Player is playing a live stream when the duration is infinite\n      live = player.isLive();\n\n      // Attach/detach live marker class\n      if (live) {\n        this.getDomElement().addClass(liveCssClass);\n        this.setText('Live');\n        if (config.hideInLivePlayback) {\n          this.hide();\n        }\n        this.onClick.subscribe(liveClickHandler);\n        updateLiveTimeshiftState();\n      } else {\n        this.getDomElement().removeClass(liveCssClass);\n        this.getDomElement().removeClass(liveEdgeCssClass);\n        this.show();\n        this.onClick.unsubscribe(liveClickHandler);\n      }\n    };\n\n    let updateLiveTimeshiftState = () => {\n      if (!live) {\n        return;\n      }\n\n      // The player is only at the live edge iff the stream is not shifted and it is actually playing or playback has\n      // never been started (meaning it isn't paused). A player that is paused is always behind the live edge.\n      // An exception is made for live streams without a timeshift window, because here we \"stop\" playback instead\n      // of pausing it (from a UI perspective), so we keep the live edge indicator on because a play would always\n      // resume at the live edge.\n      const isTimeshifted = player.getTimeShift() < 0;\n      const isTimeshiftAvailable = player.getMaxTimeShift() < 0;\n      if (!isTimeshifted && (!player.isPaused() || !isTimeshiftAvailable)) {\n        this.getDomElement().addClass(liveEdgeCssClass);\n      } else {\n        this.getDomElement().removeClass(liveEdgeCssClass);\n      }\n    };\n\n    let liveStreamDetector = new PlayerUtils.LiveStreamDetector(player);\n    liveStreamDetector.onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      live = args.live;\n      updateLiveState();\n    });\n    liveStreamDetector.detect(); // Initial detection\n\n    let playbackTimeHandler = () => {\n      if (!live && player.getDuration() !== Infinity) {\n        this.setTime(player.getCurrentTime(), player.getDuration());\n      }\n\n      // To avoid 'jumping' in the UI by varying label sizes due to non-monospaced fonts,\n      // we gradually increase the min-width with the content to reach a stable size.\n      let width = this.getDomElement().width();\n      if (width > minWidth) {\n        minWidth = width;\n        this.getDomElement().css({\n          'min-width': minWidth + 'px',\n        });\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackTimeHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackTimeHandler);\n\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_PLAY, updateLiveTimeshiftState);\n    player.addEventHandler(player.EVENT.ON_PAUSED, updateLiveTimeshiftState);\n\n    let init = () => {\n      // Reset min-width when a new source is ready (especially for switching VOD/Live modes where the label content\n      // changes)\n      minWidth = 0;\n      this.getDomElement().css({\n        'min-width': null,\n      });\n\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n\n      // Update time after the format has been set\n      playbackTimeHandler();\n    };\n    player.addEventHandler(player.EVENT.ON_READY, init);\n\n    init();\n  }\n\n  /**\n   * Sets the current playback time and total duration.\n   * @param playbackSeconds the current playback time in seconds\n   * @param durationSeconds the total duration in seconds\n   */\n  setTime(playbackSeconds: number, durationSeconds: number) {\n    let currentTime = StringUtils.secondsToTime(playbackSeconds, this.timeFormat);\n    let totalTime = StringUtils.secondsToTime(durationSeconds, this.timeFormat);\n\n    switch ((<PlaybackTimeLabelConfig>this.config).timeLabelMode) {\n      case PlaybackTimeLabelMode.CurrentTime:\n        this.setText(`${currentTime}`);\n        break;\n      case PlaybackTimeLabelMode.TotalTime:\n        this.setText(`${totalTime}`);\n        break;\n      case PlaybackTimeLabelMode.CurrentAndTotalTime:\n        this.setText(`${currentTime} / ${totalTime}`);\n        break;\n    }\n  }\n\n  /**\n   * Sets the current time format\n   * @param timeFormat the time format\n   */\n  protected setTimeFormat(timeFormat: string): void {\n    this.timeFormat = timeFormat;\n  }\n}\n","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport PlayerEvent = bitmovin.PlayerAPI.PlayerEvent;\nimport {PlayerUtils} from '../playerutils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\nimport WarningEvent = bitmovin.PlayerAPI.WarningEvent;\n\n/**\n * A button that toggles between playback and pause.\n */\nexport class PlaybackToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  private static readonly CLASS_STOPTOGGLE = 'stoptoggle';\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktogglebutton',\n      text: 'Play/Pause',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager, handleClickEvent: boolean = true): void {\n    super.configure(player, uimanager);\n\n    let isSeeking = false;\n\n    // Handler to update button state based on player state\n    let playbackStateHandler = (event: PlayerEvent) => {\n      // If the UI is currently seeking, playback is temporarily stopped but the buttons should\n      // not reflect that and stay as-is (e.g indicate playback while seeking).\n      if (isSeeking) {\n        return;\n      }\n\n      if (player.isPlaying()) {\n        this.on();\n      } else {\n        this.off();\n      }\n    };\n\n    // Call handler upon these events\n    player.addEventHandler(player.EVENT.ON_PLAY, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_PAUSED, playbackStateHandler);\n    if (player.EVENT.ON_PLAYING) {\n      // Since player 7.3. Not really necessary but just in case we ever miss the ON_PLAY event.\n      player.addEventHandler(player.EVENT.ON_PLAYING, playbackStateHandler);\n    }\n    // after unloading + loading a new source, the player might be in a different playing state (from playing into stopped)\n    player.addEventHandler(player.EVENT.ON_SOURCE_LOADED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, playbackStateHandler);\n    // when playback finishes, player turns to paused mode\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, playbackStateHandler);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYBACK_FINISHED, playbackStateHandler);\n\n    // When a playback attempt is rejected with warning 5008, we switch the button state back to off\n    // This is required for blocked autoplay, because there is no ON_PAUSED event in such case\n    player.addEventHandler(player.EVENT.ON_WARNING, (event: WarningEvent) => {\n      if (event.code === 5008) {\n        this.off();\n      }\n    });\n\n    // Detect absence of timeshifting on live streams and add tagging class to convert button icons to play/stop\n    let timeShiftDetector = new PlayerUtils.TimeShiftAvailabilityDetector(player);\n    timeShiftDetector.onTimeShiftAvailabilityChanged.subscribe(\n      (sender, args: TimeShiftAvailabilityChangedArgs) => {\n        if (!args.timeShiftAvailable) {\n          this.getDomElement().addClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        } else {\n          this.getDomElement().removeClass(this.prefixCss(PlaybackToggleButton.CLASS_STOPTOGGLE));\n        }\n      }\n    );\n    timeShiftDetector.detect(); // Initial detection\n\n    if (handleClickEvent) {\n      // Control player by button events\n      // When a button event triggers a player API call, events are fired which in turn call the event handler\n      // above that updated the button state.\n      this.onClick.subscribe(() => {\n        if (player.isPlaying()) {\n          player.pause('ui');\n        } else {\n          player.play('ui');\n        }\n      });\n    }\n\n    // Track UI seeking status\n    uimanager.onSeek.subscribe(() => {\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n    });\n\n    // Startup init\n    playbackStateHandler(null);\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {HugePlaybackToggleButton} from './hugeplaybacktogglebutton';\n\n/**\n * Overlays the player and displays error messages.\n */\nexport class PlaybackToggleOverlay extends Container<ContainerConfig> {\n\n  private playbackToggleButton: HugePlaybackToggleButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.playbackToggleButton = new HugePlaybackToggleButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-playbacktoggle-overlay',\n      components: [this.playbackToggleButton],\n    }, this.config);\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {UIInstanceManager, UIRecommendationConfig} from '../uimanager';\nimport {StringUtils} from '../stringutils';\nimport {HugeReplayButton} from './hugereplaybutton';\n\n/**\n * Overlays the player and displays recommended videos.\n */\nexport class RecommendationOverlay extends Container<ContainerConfig> {\n\n  private replayButton: HugeReplayButton;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.replayButton = new HugeReplayButton();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-overlay',\n      hidden: true,\n      components: [this.replayButton],\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let clearRecommendations = () => {\n      for (let component of this.getComponents().slice()) {\n        if (component instanceof RecommendationItem) {\n          this.removeComponent(component);\n        }\n      }\n      this.updateComponents();\n      this.getDomElement().removeClass(this.prefixCss('recommendations'));\n    };\n\n    let setupRecommendations = () => {\n      clearRecommendations();\n\n      const recommendations = uimanager.getConfig().recommendations;\n\n      if (recommendations.length > 0) {\n        let index = 1;\n        for (let item of recommendations) {\n          this.addComponent(new RecommendationItem({\n            itemConfig: item,\n            cssClasses: ['recommendation-item-' + (index++)],\n          }));\n        }\n        this.updateComponents(); // create container DOM elements\n\n        this.getDomElement().addClass(this.prefixCss('recommendations'));\n      }\n    };\n\n    // Add recommendation when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupRecommendations);\n    // Remove recommendations and hide overlay when source is unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      clearRecommendations();\n      this.hide();\n    });\n    // Display recommendations when playback has finished\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      // Dismiss ON_PLAYBACK_FINISHED events at the end of ads\n      // TODO remove this workaround once issue #1278 is solved\n      if (player.isAd()) {\n        return;\n      }\n\n      this.show();\n    });\n    // Hide recommendations when playback starts, e.g. a restart\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      this.hide();\n    });\n\n    // Init on startup\n    setupRecommendations();\n  }\n}\n\n/**\n * Configuration interface for the {@link RecommendationItem}\n */\ninterface RecommendationItemConfig extends ComponentConfig {\n  itemConfig: UIRecommendationConfig;\n}\n\n/**\n * An item of the {@link RecommendationOverlay}. Used only internally in {@link RecommendationOverlay}.\n */\nclass RecommendationItem extends Component<RecommendationItemConfig> {\n\n  constructor(config: RecommendationItemConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-recommendation-item',\n      itemConfig: null, // this must be passed in from outside\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let config = (<RecommendationItemConfig>this.config).itemConfig; // TODO fix generics and get rid of cast\n\n    let itemElement = new DOM('a', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n      'href': config.url,\n    }).css({ 'background-image': `url(${config.thumbnail})` });\n\n    let bgElement = new DOM('div', {\n      'class': this.prefixCss('background'),\n    });\n    itemElement.append(bgElement);\n\n    let titleElement = new DOM('span', {\n      'class': this.prefixCss('title'),\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innertitle'),\n    }).html(config.title));\n    itemElement.append(titleElement);\n\n    let timeElement = new DOM('span', {\n      'class': this.prefixCss('duration'),\n    }).append(new DOM('span', {\n      'class': this.prefixCss('innerduration'),\n    }).html(config.duration ? StringUtils.secondsToTime(config.duration) : ''));\n    itemElement.append(timeElement);\n\n    return itemElement;\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\nimport {SeekBarLabel} from './seekbarlabel';\nimport {UIInstanceManager, TimelineMarker, SeekPreviewArgs} from '../uimanager';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../playerutils';\nimport TimeShiftAvailabilityChangedArgs = PlayerUtils.TimeShiftAvailabilityChangedArgs;\nimport LiveStreamDetectorEventArgs = PlayerUtils.LiveStreamDetectorEventArgs;\nimport PlayerEvent = bitmovin.PlayerAPI.PlayerEvent;\n\n/**\n * Configuration interface for the {@link SeekBar} component.\n */\nexport interface SeekBarConfig extends ComponentConfig {\n  /**\n   * The label above the seek position.\n   */\n  label?: SeekBarLabel;\n  /**\n   * Bar will be vertical instead of horizontal if set to true.\n   */\n  vertical?: boolean;\n  /**\n   * The interval in milliseconds in which the playback position on the seek bar will be updated. The shorter the\n   * interval, the smoother it looks and the more resource intense it is. The update interval will be kept as steady\n   * as possible to avoid jitter.\n   * Set to -1 to disable smooth updating and update it on player ON_TIME_CHANGED events instead.\n   * Default: 50 (50ms = 20fps).\n   */\n  smoothPlaybackPositionUpdateIntervalMs?: number;\n}\n\n/**\n * Event argument interface for a seek preview event.\n */\nexport interface SeekPreviewEventArgs extends SeekPreviewArgs {\n  /**\n   * Tells if the seek preview event comes from a scrubbing.\n   */\n  scrubbing: boolean;\n}\n\nexport interface SeekBarMarker {\n  marker: TimelineMarker;\n  position: number;\n  duration?: number;\n}\n\n/**\n * A seek bar to seek within the player's media. It displays the current playback position, amount of buffed data, seek\n * target, and keeps status about an ongoing seek.\n *\n * The seek bar displays different 'bars':\n *  - the playback position, i.e. the position in the media at which the player current playback pointer is positioned\n *  - the buffer position, which usually is the playback position plus the time span that is already buffered ahead\n *  - the seek position, used to preview to where in the timeline a seek will jump to\n */\nexport class SeekBar extends Component<SeekBarConfig> {\n\n  public static readonly SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED = -1;\n\n  /**\n   * The CSS class that is added to the DOM element while the seek bar is in 'seeking' state.\n   */\n  private static readonly CLASS_SEEKING = 'seeking';\n\n  private seekBar: DOM;\n  private seekBarPlaybackPosition: DOM;\n  private seekBarPlaybackPositionMarker: DOM;\n  private seekBarBufferPosition: DOM;\n  private seekBarSeekPosition: DOM;\n  private seekBarBackdrop: DOM;\n  private seekBarMarkersContainer: DOM;\n\n  private label: SeekBarLabel;\n\n  private timelineMarkers: SeekBarMarker[];\n\n  /**\n   * Buffer of the the current playback position. The position must be buffered in case the element\n   * needs to be refreshed with {@link #refreshPlaybackPosition}.\n   * @type {number}\n   */\n  private playbackPositionPercentage = 0;\n\n  private smoothPlaybackPositionUpdater: Timeout;\n\n  // https://hacks.mozilla.org/2013/04/detecting-touch-its-the-why-not-the-how/\n  private touchSupported = ('ontouchstart' in window);\n\n  private seekBarEvents = {\n    /**\n     * Fired when a scrubbing seek operation is started.\n     */\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    /**\n     * Fired during a scrubbing seek to indicate that the seek preview (i.e. the video frame) should be updated.\n     */\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewEventArgs>(),\n    /**\n     * Fired when a scrubbing seek has finished or when a direct seek is issued.\n     */\n    onSeeked: new EventDispatcher<SeekBar, number>(),\n  };\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar',\n      vertical: false,\n      smoothPlaybackPositionUpdateIntervalMs: 50,\n    }, this.config);\n\n    this.label = this.config.label;\n    this.timelineMarkers = [];\n  }\n\n  initialize(): void {\n    super.initialize();\n\n    if (this.hasLabel()) {\n      this.getLabel().initialize();\n    }\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager, configureSeek: boolean = true): void {\n    super.configure(player, uimanager);\n\n    // Apply scaling transform to the backdrop bar to have all bars rendered similarly\n    // (the call must be up here to be executed for the volume slider as well)\n    this.setPosition(this.seekBarBackdrop, 100);\n\n    if (!configureSeek) {\n      // The configureSeek flag can be used by subclasses to disable configuration as seek bar. E.g. the volume\n      // slider is reusing this component but adds its own functionality, and does not need the seek functionality.\n      // This is actually a hack, the proper solution would be for both seek bar and volume sliders to extend\n      // a common base slider component and implement their functionality there.\n      return;\n    }\n\n    let isPlaying = false;\n    let isSeeking = false;\n\n    // Update playback and buffer positions\n    let playbackPositionHandler = (event: PlayerEvent = null, forceUpdate: boolean = false) => {\n      if (isSeeking) {\n        // We caught a seek preview seek, do not update the seekbar\n        return;\n      }\n\n      if (player.isLive()) {\n        if (player.getMaxTimeShift() === 0) {\n          // This case must be explicitly handled to avoid division by zero\n          this.setPlaybackPosition(100);\n        }\n        else {\n          let playbackPositionPercentage = 100 - (100 / player.getMaxTimeShift() * player.getTimeShift());\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        // Always show full buffer for live streams\n        this.setBufferPosition(100);\n      }\n      else {\n        let playbackPositionPercentage = 100 / player.getDuration() * player.getCurrentTime();\n\n        let videoBufferLength = player.getVideoBufferLength();\n        let audioBufferLength = player.getAudioBufferLength();\n        // Calculate the buffer length which is the smaller length of the audio and video buffers. If one of these\n        // buffers is not available, we set it's value to MAX_VALUE to make sure that the other real value is taken\n        // as the buffer length.\n        let bufferLength = Math.min(\n          videoBufferLength != null ? videoBufferLength : Number.MAX_VALUE,\n          audioBufferLength != null ? audioBufferLength : Number.MAX_VALUE);\n        // If both buffer lengths are missing, we set the buffer length to zero\n        if (bufferLength === Number.MAX_VALUE) {\n          bufferLength = 0;\n        }\n\n        let bufferPercentage = 100 / player.getDuration() * bufferLength;\n\n        // Update playback position only in paused state or in the initial startup state where player is neither\n        // paused nor playing. Playback updates are handled in the Timeout below.\n        if (this.config.smoothPlaybackPositionUpdateIntervalMs === SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED\n          || forceUpdate || player.isPaused() || (player.isPaused() === player.isPlaying())) {\n          this.setPlaybackPosition(playbackPositionPercentage);\n        }\n\n        this.setBufferPosition(playbackPositionPercentage + bufferPercentage);\n      }\n    };\n\n    // Update seekbar upon these events\n    // init playback position when the player is ready\n    player.addEventHandler(player.EVENT.ON_READY, playbackPositionHandler);\n    // update playback position when it changes\n    player.addEventHandler(player.EVENT.ON_TIME_CHANGED, playbackPositionHandler);\n    // update bufferlevel when buffering is complete\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, playbackPositionHandler);\n    // update playback position when a seek has finished\n    player.addEventHandler(player.EVENT.ON_SEEKED, playbackPositionHandler);\n    // update playback position when a timeshift has finished\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, playbackPositionHandler);\n    // update bufferlevel when a segment has been downloaded\n    player.addEventHandler(player.EVENT.ON_SEGMENT_REQUEST_FINISHED, playbackPositionHandler);\n    // update playback position of Cast playback\n    player.addEventHandler(player.EVENT.ON_CAST_TIME_UPDATED, playbackPositionHandler);\n\n    this.configureLivePausedTimeshiftUpdater(player, uimanager, playbackPositionHandler);\n\n    // Seek handling\n    player.addEventHandler(player.EVENT.ON_SEEK, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      this.setSeeking(false);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, () => {\n      this.setSeeking(true);\n    });\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFTED, () => {\n      this.setSeeking(false);\n    });\n\n    let seek = (percentage: number) => {\n      if (player.isLive()) {\n        player.timeShift(player.getMaxTimeShift() - (player.getMaxTimeShift() * (percentage / 100)), 'ui');\n      } else {\n        player.seek(player.getDuration() * (percentage / 100), 'ui');\n      }\n    };\n    this.onSeek.subscribe((sender) => {\n      isSeeking = true; // track seeking status so we can catch events from seek preview seeks\n\n      // Notify UI manager of started seek\n      uimanager.onSeek.dispatch(sender);\n\n      // Save current playback state\n      isPlaying = player.isPlaying();\n\n      // Pause playback while seeking\n      if (isPlaying) {\n        player.pause('ui');\n      }\n    });\n    this.onSeekPreview.subscribe((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Notify UI manager of seek preview\n      uimanager.onSeekPreview.dispatch(sender, args);\n    });\n    this.onSeekPreview.subscribeRateLimited((sender: SeekBar, args: SeekPreviewEventArgs) => {\n      // Rate-limited scrubbing seek\n      if (args.scrubbing) {\n        seek(args.position);\n      }\n    }, 200);\n    this.onSeeked.subscribe((sender, percentage) => {\n      isSeeking = false;\n\n      // Do the seek\n      seek(percentage);\n\n      // Continue playback after seek if player was playing when seek started\n      if (isPlaying) {\n        player.play('ui');\n      }\n\n      // Notify UI manager of finished seek\n      uimanager.onSeeked.dispatch(sender);\n    });\n\n    if (this.hasLabel()) {\n      // Configure a seekbar label that is internal to the seekbar)\n      this.getLabel().configure(player, uimanager);\n    }\n\n    // Hide seekbar for live sources without timeshift\n    let isLive = false;\n    let hasTimeShift = false;\n    let switchVisibility = (isLive: boolean, hasTimeShift: boolean) => {\n      if (isLive && !hasTimeShift) {\n        this.hide();\n      } else {\n        this.show();\n      }\n      playbackPositionHandler(null, true);\n      this.refreshPlaybackPosition();\n    };\n    let liveStreamDetector = new PlayerUtils.LiveStreamDetector(player);\n    liveStreamDetector.onLiveChanged.subscribe((sender, args: LiveStreamDetectorEventArgs) => {\n      isLive = args.live;\n      switchVisibility(isLive, hasTimeShift);\n    });\n    let timeShiftDetector = new PlayerUtils.TimeShiftAvailabilityDetector(player);\n    timeShiftDetector.onTimeShiftAvailabilityChanged.subscribe((sender, args: TimeShiftAvailabilityChangedArgs) => {\n        hasTimeShift = args.timeShiftAvailable;\n        switchVisibility(isLive, hasTimeShift);\n      }\n    );\n    // Initial detection\n    liveStreamDetector.detect();\n    timeShiftDetector.detect();\n\n    // Refresh the playback position when the player resized or the UI is configured. The playback position marker\n    // is positioned absolutely and must therefore be updated when the size of the seekbar changes.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    // Additionally, when this code is called, the seekbar is not part of the UI yet and therefore does not have a size,\n    // resulting in a wrong initial position of the marker. Refreshing it once the UI is configured solved this issue.\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n    // It can also happen that the value changes once the player is ready, or when a new source is loaded, so we need\n    // to update on ON_READY too\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Initialize seekbar\n    playbackPositionHandler(); // Set the playback position\n    this.setBufferPosition(0);\n    this.setSeekPosition(0);\n    if (this.config.smoothPlaybackPositionUpdateIntervalMs !== SeekBar.SMOOTH_PLAYBACK_POSITION_UPDATE_DISABLED) {\n      this.configureSmoothPlaybackPositionUpdater(player, uimanager);\n    }\n    this.configureMarkers(player, uimanager);\n  }\n\n  /**\n   * Update seekbar while a live stream with DVR window is paused.\n   * The playback position stays still and the position indicator visually moves towards the back.\n   */\n  private configureLivePausedTimeshiftUpdater(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager,\n                                              playbackPositionHandler: () => void): void {\n    // Regularly update the playback position while the timeout is active\n    const pausedTimeshiftUpdater = new Timeout(1000, playbackPositionHandler, true);\n\n    // Start updater when a live stream with timeshift window is paused\n    player.addEventHandler(player.EVENT.ON_PAUSED, () => {\n      if (player.isLive() && player.getMaxTimeShift() < 0) {\n        pausedTimeshiftUpdater.start();\n      }\n    });\n\n    // Stop updater when playback continues (no matter if the updater was started before)\n    player.addEventHandler(player.EVENT.ON_PLAY, () => pausedTimeshiftUpdater.clear());\n  }\n\n  private configureSmoothPlaybackPositionUpdater(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    /*\n     * Playback position update\n     *\n     * We do not update the position directly from the ON_TIME_CHANGED event, because it arrives very jittery and\n     * results in a jittery position indicator since the CSS transition time is statically set.\n     * To work around this issue, we maintain a local playback position that is updated in a stable regular interval\n     * and kept in sync with the player.\n     */\n    let currentTimeSeekBar = 0;\n    let currentTimePlayer = 0;\n    let updateIntervalMs = 50;\n    let currentTimeUpdateDeltaSecs = updateIntervalMs / 1000;\n\n    this.smoothPlaybackPositionUpdater = new Timeout(updateIntervalMs, () => {\n      currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      currentTimePlayer = player.getCurrentTime();\n\n      // Sync currentTime of seekbar to player\n      let currentTimeDelta = currentTimeSeekBar - currentTimePlayer;\n      // If the delta is larger that 2 secs, directly jump the seekbar to the\n      // player time instead of smoothly fast forwarding/rewinding.\n      if (Math.abs(currentTimeDelta) > 2) {\n        currentTimeSeekBar = currentTimePlayer;\n      }\n      // If currentTimeDelta is negative and below the adjustment threshold,\n      // the player is ahead of the seekbar and we 'fast forward' the seekbar\n      else if (currentTimeDelta <= -currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar += currentTimeUpdateDeltaSecs;\n      }\n      // If currentTimeDelta is positive and above the adjustment threshold,\n      // the player is behind the seekbar and we 'rewind' the seekbar\n      else if (currentTimeDelta >= currentTimeUpdateDeltaSecs) {\n        currentTimeSeekBar -= currentTimeUpdateDeltaSecs;\n      }\n\n      let playbackPositionPercentage = 100 / player.getDuration() * currentTimeSeekBar;\n      this.setPlaybackPosition(playbackPositionPercentage);\n    }, true);\n\n    let startSmoothPlaybackPositionUpdater = () => {\n      if (!player.isLive()) {\n        currentTimeSeekBar = player.getCurrentTime();\n        this.smoothPlaybackPositionUpdater.start();\n      }\n    };\n\n    let stopSmoothPlaybackPositionUpdater = () => {\n      this.smoothPlaybackPositionUpdater.clear();\n    };\n\n    player.addEventHandler(player.EVENT.ON_PLAY, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PLAYING, startSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_CAST_PAUSED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, stopSmoothPlaybackPositionUpdater);\n    player.addEventHandler(player.EVENT.ON_SEEKED, () => {\n      currentTimeSeekBar = player.getCurrentTime();\n    });\n\n    if (player.isPlaying()) {\n      startSmoothPlaybackPositionUpdater();\n    }\n  }\n\n  private configureMarkers(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    let clearMarkers = () => {\n      this.timelineMarkers = [];\n      this.updateMarkers();\n    };\n\n    let setupMarkers = () => {\n      clearMarkers();\n\n      const duration = player.getDuration();\n\n      if (duration === Infinity) {\n        // Don't generate timeline markers if we don't yet have a duration\n        // The duration check is for buggy platforms where the duration is not available instantly (Chrome on Android 4.3)\n        return;\n      }\n\n      for (let marker of uimanager.getConfig().metadata.markers) {\n        const markerPosition = 100 / duration * marker.time; // convert absolute time to percentage\n        const markerDuration = 100 / duration * marker.duration;\n        this.timelineMarkers.push({ marker, position: markerPosition, duration: markerDuration });\n      }\n\n      // Populate the timeline with the markers\n      this.updateMarkers();\n    };\n\n    // Add markers when a source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, setupMarkers);\n    // Remove markers when unloaded\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, clearMarkers);\n    // Update markers when the size of the seekbar changes\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => this.updateMarkers());\n    // Update markers when a marker is added or removed\n    uimanager.getConfig().events.onUpdated.subscribe(setupMarkers);\n    uimanager.onRelease.subscribe(() => uimanager.getConfig().events.onUpdated.unsubscribe(setupMarkers));\n\n    // Init markers at startup\n    setupMarkers();\n  }\n\n  release(): void {\n    super.release();\n\n    if (this.smoothPlaybackPositionUpdater) { // object must not necessarily exist, e.g. in volume slider subclass\n      this.smoothPlaybackPositionUpdater.clear();\n    }\n  }\n\n  protected toDomElement(): DOM {\n    if (this.config.vertical) {\n      this.config.cssClasses.push('vertical');\n    }\n\n    let seekBarContainer = new DOM('div', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    });\n\n    let seekBar = new DOM('div', {\n      'class': this.prefixCss('seekbar'),\n    });\n    this.seekBar = seekBar;\n\n    // Indicator that shows the buffer fill level\n    let seekBarBufferLevel = new DOM('div', {\n      'class': this.prefixCss('seekbar-bufferlevel'),\n    });\n    this.seekBarBufferPosition = seekBarBufferLevel;\n\n    // Indicator that shows the current playback position\n    let seekBarPlaybackPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition'),\n    });\n    this.seekBarPlaybackPosition = seekBarPlaybackPosition;\n\n    // A marker of the current playback position, e.g. a dot or line\n    let seekBarPlaybackPositionMarker = new DOM('div', {\n      'class': this.prefixCss('seekbar-playbackposition-marker'),\n    });\n    this.seekBarPlaybackPositionMarker = seekBarPlaybackPositionMarker;\n\n    // Indicator that show where a seek will go to\n    let seekBarSeekPosition = new DOM('div', {\n      'class': this.prefixCss('seekbar-seekposition'),\n    });\n    this.seekBarSeekPosition = seekBarSeekPosition;\n\n    // Indicator that shows the full seekbar\n    let seekBarBackdrop = new DOM('div', {\n      'class': this.prefixCss('seekbar-backdrop'),\n    });\n    this.seekBarBackdrop = seekBarBackdrop;\n\n    let seekBarChapterMarkersContainer = new DOM('div', {\n      'class': this.prefixCss('seekbar-markers'),\n    });\n    this.seekBarMarkersContainer = seekBarChapterMarkersContainer;\n\n    seekBar.append(this.seekBarBackdrop, this.seekBarBufferPosition, this.seekBarSeekPosition,\n      this.seekBarPlaybackPosition, this.seekBarMarkersContainer, this.seekBarPlaybackPositionMarker);\n\n    let seeking = false;\n\n    // Define handler functions so we can attach/remove them later\n    let mouseTouchMoveHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      let targetPercentage = 100 * this.getOffset(e);\n      this.setSeekPosition(targetPercentage);\n      this.setPlaybackPosition(targetPercentage);\n      this.onSeekPreviewEvent(targetPercentage, true);\n    };\n    let mouseTouchUpHandler = (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      // Remove handlers, seek operation is finished\n      new DOM(document).off('touchmove mousemove', mouseTouchMoveHandler);\n      new DOM(document).off('touchend mouseup', mouseTouchUpHandler);\n\n      let targetPercentage = 100 * this.getOffset(e);\n      let snappedChapter = this.getMarkerAtPosition(targetPercentage);\n\n      this.setSeeking(false);\n      seeking = false;\n\n      // Fire seeked event\n      this.onSeekedEvent(snappedChapter ? snappedChapter.position : targetPercentage);\n    };\n\n    // A seek always start with a touchstart or mousedown directly on the seekbar.\n    // To track a mouse seek also outside the seekbar (for touch events this works automatically),\n    // so the user does not need to take care that the mouse always stays on the seekbar, we attach the mousemove\n    // and mouseup handlers to the whole document. A seek is triggered when the user lifts the mouse key.\n    // A seek mouse gesture is thus basically a click with a long time frame between down and up events.\n    seekBar.on('touchstart mousedown', (e: MouseEvent | TouchEvent) => {\n      let isTouchEvent = this.touchSupported && e instanceof TouchEvent;\n\n      // Prevent selection of DOM elements (also prevents mousedown if current event is touchstart)\n      e.preventDefault();\n      // Avoid propagation to VR handler\n      e.stopPropagation();\n\n      this.setSeeking(true); // Set seeking class on DOM element\n      seeking = true; // Set seek tracking flag\n\n      // Fire seeked event\n      this.onSeekEvent();\n\n      // Add handler to track the seek operation over the whole document\n      new DOM(document).on(isTouchEvent ? 'touchmove' : 'mousemove', mouseTouchMoveHandler);\n      new DOM(document).on(isTouchEvent ? 'touchend' : 'mouseup', mouseTouchUpHandler);\n    });\n\n    // Display seek target indicator when mouse hovers or finger slides over seekbar\n    seekBar.on('touchmove mousemove', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      if (seeking) {\n        // During a seek (when mouse is down or touch move active), we need to stop propagation to avoid\n        // the VR viewport reacting to the moves.\n        e.stopPropagation();\n        // Because the stopped propagation inhibits the event on the document, we need to call it from here\n        mouseTouchMoveHandler(e);\n      }\n\n      let position = 100 * this.getOffset(e);\n      this.setSeekPosition(position);\n      this.onSeekPreviewEvent(position, false);\n\n      if (this.hasLabel() && this.getLabel().isHidden()) {\n        this.getLabel().show();\n      }\n    });\n\n    // Hide seek target indicator when mouse or finger leaves seekbar\n    seekBar.on('touchend mouseleave', (e: MouseEvent | TouchEvent) => {\n      e.preventDefault();\n\n      this.setSeekPosition(0);\n\n      if (this.hasLabel()) {\n        this.getLabel().hide();\n      }\n    });\n\n    seekBarContainer.append(seekBar);\n\n    if (this.label) {\n      seekBarContainer.append(this.label.getDomElement());\n    }\n\n    return seekBarContainer;\n  }\n\n  protected updateMarkers(): void {\n    this.seekBarMarkersContainer.empty();\n\n    const seekBarWidthPx = this.seekBar.width();\n\n    for (let marker of this.timelineMarkers) {\n      const markerClasses = ['seekbar-marker'].concat(marker.marker.cssClasses || [])\n        .map(cssClass => this.prefixCss(cssClass));\n\n      const cssProperties: {[propertyName: string]: string} = {\n        'width': marker.position + '%',\n      };\n\n      if (marker.duration > 0) {\n        const markerWidthPx = Math.round(seekBarWidthPx / 100 * marker.duration);\n        cssProperties['border-right-width'] = markerWidthPx + 'px';\n        cssProperties['margin-left'] = '0';\n      }\n\n      this.seekBarMarkersContainer.append(new DOM('div', {\n        'class': markerClasses.join(' '),\n        'data-marker-time': String(marker.marker.time),\n        'data-marker-title': String(marker.marker.title),\n      }).css(cssProperties));\n    }\n  }\n\n  protected getMarkerAtPosition(percentage: number): SeekBarMarker | null {\n    const snappingRange = 1;\n\n    if (this.timelineMarkers.length > 0) {\n      for (let marker of this.timelineMarkers) {\n        // Handle interval markers\n        if (marker.duration > 0\n          && percentage >= marker.position - snappingRange\n          && percentage <= marker.position + marker.duration + snappingRange) {\n          return marker;\n        }\n        // Handle position markers\n        else if (percentage >= marker.position - snappingRange\n          && percentage <= marker.position + snappingRange) {\n          return marker;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets the horizontal offset of a mouse/touch event point from the left edge of the seek bar.\n   * @param eventPageX the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the left edge and 1 is the right edge\n   */\n  private getHorizontalOffset(eventPageX: number): number {\n    let elementOffsetPx = this.seekBar.offset().left;\n    let widthPx = this.seekBar.width();\n    let offsetPx = eventPageX - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the vertical offset of a mouse/touch event point from the bottom edge of the seek bar.\n   * @param eventPageY the pageX coordinate of an event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1], where 0 is the bottom edge and 1 is the top edge\n   */\n  private getVerticalOffset(eventPageY: number): number {\n    let elementOffsetPx = this.seekBar.offset().top;\n    let widthPx = this.seekBar.height();\n    let offsetPx = eventPageY - elementOffsetPx;\n    let offset = 1 / widthPx * offsetPx;\n\n    return 1 - this.sanitizeOffset(offset);\n  }\n\n  /**\n   * Gets the mouse or touch event offset for the current configuration (horizontal or vertical).\n   * @param e the event to calculate the offset from\n   * @returns {number} a number in the range of [0, 1]\n   * @see #getHorizontalOffset\n   * @see #getVerticalOffset\n   */\n  private getOffset(e: MouseEvent | TouchEvent): number {\n    if (this.touchSupported && e instanceof TouchEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.type === 'touchend' ? e.changedTouches[0].pageY : e.touches[0].pageY);\n      } else {\n        return this.getHorizontalOffset(e.type === 'touchend' ? e.changedTouches[0].pageX : e.touches[0].pageX);\n      }\n    }\n    else if (e instanceof MouseEvent) {\n      if (this.config.vertical) {\n        return this.getVerticalOffset(e.pageY);\n      } else {\n        return this.getHorizontalOffset(e.pageX);\n      }\n    }\n    else {\n      if (console) {\n        console.warn('invalid event');\n      }\n      return 0;\n    }\n  }\n\n  /**\n   * Sanitizes the mouse offset to the range of [0, 1].\n   *\n   * When tracking the mouse outside the seek bar, the offset can be outside the desired range and this method\n   * limits it to the desired range. E.g. a mouse event left of the left edge of a seek bar yields an offset below\n   * zero, but to display the seek target on the seek bar, we need to limit it to zero.\n   *\n   * @param offset the offset to sanitize\n   * @returns {number} the sanitized offset.\n   */\n  private sanitizeOffset(offset: number) {\n    // Since we track mouse moves over the whole document, the target can be outside the seek range,\n    // and we need to limit it to the [0, 1] range.\n    if (offset < 0) {\n      offset = 0;\n    } else if (offset > 1) {\n      offset = 1;\n    }\n\n    return offset;\n  }\n\n  /**\n   * Sets the position of the playback position indicator.\n   * @param percent a number between 0 and 100 as returned by the player\n   */\n  setPlaybackPosition(percent: number) {\n    this.playbackPositionPercentage = percent;\n\n    // Set position of the bar\n    this.setPosition(this.seekBarPlaybackPosition, percent);\n\n    // Set position of the marker\n    let totalSize = (this.config.vertical ? (this.seekBar.height() - this.seekBarPlaybackPositionMarker.height()) : this.seekBar.width());\n    let px = (totalSize) / 100 * percent;\n    if (this.config.vertical) {\n      px = this.seekBar.height() - px - this.seekBarPlaybackPositionMarker.height();\n    }\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      // -webkit-transform required for Android 4.4 WebView\n      {\n        'transform': 'translateY(' + px + 'px)',\n        '-ms-transform': 'translateY(' + px + 'px)',\n        '-webkit-transform': 'translateY(' + px + 'px)',\n      } :\n      {\n        'transform': 'translateX(' + px + 'px)',\n        '-ms-transform': 'translateX(' + px + 'px)',\n        '-webkit-transform': 'translateX(' + px + 'px)',\n      };\n    this.seekBarPlaybackPositionMarker.css(style);\n  }\n\n  /**\n   * Refreshes the playback position. Can be used by subclasses to refresh the position when\n   * the size of the component changes.\n   */\n  protected refreshPlaybackPosition() {\n    this.setPlaybackPosition(this.playbackPositionPercentage);\n  }\n\n  /**\n   * Sets the position until which media is buffered.\n   * @param percent a number between 0 and 100\n   */\n  setBufferPosition(percent: number) {\n    this.setPosition(this.seekBarBufferPosition, percent);\n  }\n\n  /**\n   * Sets the position where a seek, if executed, would jump to.\n   * @param percent a number between 0 and 100\n   */\n  setSeekPosition(percent: number) {\n    this.setPosition(this.seekBarSeekPosition, percent);\n  }\n\n  /**\n   * Set the actual position (width or height) of a DOM element that represent a bar in the seek bar.\n   * @param element the element to set the position for\n   * @param percent a number between 0 and 100\n   */\n  private setPosition(element: DOM, percent: number) {\n    let scale = percent / 100;\n\n    // When the scale is exactly 1 or very near 1 (and the browser internally rounds it to 1), browsers seem to render\n    // the elements differently and the height gets slightly off, leading to mismatching heights when e.g. the buffer\n    // level bar has a width of 1 and the playback position bar has a width < 1. A jittering buffer level around 1\n    // leads to an even worse flickering effect.\n    // Various changes in CSS styling and DOM hierarchy did not solve the issue so the workaround is to avoid a scale\n    // of exactly 1.\n    if (scale >= 0.99999 && scale <= 1.00001) {\n      scale = 0.99999;\n    }\n\n    let style = this.config.vertical ?\n      // -ms-transform required for IE9\n      // -webkit-transform required for Android 4.4 WebView\n      {\n        'transform': 'scaleY(' + scale + ')',\n        '-ms-transform': 'scaleY(' + scale + ')',\n        '-webkit-transform': 'scaleY(' + scale + ')',\n      } :\n      {\n        'transform': 'scaleX(' + scale + ')',\n        '-ms-transform': 'scaleX(' + scale + ')',\n        '-webkit-transform': 'scaleX(' + scale + ')',\n      };\n    element.css(style);\n  }\n\n  /**\n   * Puts the seek bar into or out of seeking state by adding/removing a class to the DOM element. This can be used\n   * to adjust the styling while seeking.\n   *\n   * @param seeking should be true when entering seek state, false when exiting the seek state\n   */\n  setSeeking(seeking: boolean) {\n    if (seeking) {\n      this.getDomElement().addClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    } else {\n      this.getDomElement().removeClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n    }\n  }\n\n  /**\n   * Checks if the seek bar is currently in the seek state.\n   * @returns {boolean} true if in seek state, else false\n   */\n  isSeeking(): boolean {\n    return this.getDomElement().hasClass(this.prefixCss(SeekBar.CLASS_SEEKING));\n  }\n\n  /**\n   * Checks if the seek bar has a {@link SeekBarLabel}.\n   * @returns {boolean} true if the seek bar has a label, else false\n   */\n  hasLabel(): boolean {\n    return this.label != null;\n  }\n\n  /**\n   * Gets the label of this seek bar.\n   * @returns {SeekBarLabel} the label if this seek bar has a label, else null\n   */\n  getLabel(): SeekBarLabel | null {\n    return this.label;\n  }\n\n  protected onSeekEvent() {\n    this.seekBarEvents.onSeek.dispatch(this);\n  }\n\n  protected onSeekPreviewEvent(percentage: number, scrubbing: boolean) {\n    let snappedMarker = this.getMarkerAtPosition(percentage);\n\n    let seekPositionPercentage = percentage;\n\n    if (snappedMarker) {\n      if (snappedMarker.duration > 0) {\n        if (percentage < snappedMarker.position) {\n          // Snap the position to the start of the interval if the seek is within the left snap margin\n          // We know that we are within a snap margin when we are outside the marker interval but still\n          // have a snappedMarker\n          seekPositionPercentage = snappedMarker.position;\n        } else if (percentage > snappedMarker.position + snappedMarker.duration) {\n          // Snap the position to the end of the interval if the seek is within the right snap margin\n          seekPositionPercentage = snappedMarker.position + snappedMarker.duration;\n        }\n      } else {\n        // Position markers always snap to their marker position\n        seekPositionPercentage = snappedMarker.position;\n      }\n    }\n\n    if (this.label) {\n      this.label.getDomElement().css({\n        'left': seekPositionPercentage + '%',\n      });\n    }\n\n    this.seekBarEvents.onSeekPreview.dispatch(this, {\n      scrubbing: scrubbing,\n      position: seekPositionPercentage,\n      marker: snappedMarker,\n    });\n  }\n\n  protected onSeekedEvent(percentage: number) {\n    this.seekBarEvents.onSeeked.dispatch(this, percentage);\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek operation is started.\n   * @returns {Event<SeekBar, NoArgs>}\n   */\n  get onSeek(): Event<SeekBar, NoArgs> {\n    return this.seekBarEvents.onSeek.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired during a scrubbing seek (to indicate that the seek preview, i.e. the video frame,\n   * should be updated), or during a normal seek preview when the seek bar is hovered (and the seek target,\n   * i.e. the seek bar label, should be updated).\n   * @returns {Event<SeekBar, SeekPreviewEventArgs>}\n   */\n  get onSeekPreview(): Event<SeekBar, SeekPreviewEventArgs> {\n    return this.seekBarEvents.onSeekPreview.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when a scrubbing seek has finished or when a direct seek is issued.\n   * @returns {Event<SeekBar, number>}\n   */\n  get onSeeked(): Event<SeekBar, number> {\n    return this.seekBarEvents.onSeeked.getEvent();\n  }\n\n\n  protected onShowEvent(): void {\n    super.onShowEvent();\n\n    // Refresh the position of the playback position when the seek bar becomes visible. To correctly set the position,\n    // the DOM element must be fully initialized an have its size calculated, because the position is set as an absolute\n    // value calculated from the size. This required size is not known when it is hidden.\n    // For such cases, we refresh the position here in onShow because here it is guaranteed that the component knows\n    // its size and can set the position correctly.\n    this.refreshPlaybackPosition();\n  }\n}\n","import {Container, ContainerConfig} from './container';\nimport {Label, LabelConfig} from './label';\nimport {Component, ComponentConfig} from './component';\nimport {UIInstanceManager, SeekPreviewArgs} from '../uimanager';\nimport {StringUtils} from '../stringutils';\nimport {ImageLoader} from '../imageloader';\n\n/**\n * Configuration interface for a {@link SeekBarLabel}.\n */\nexport interface SeekBarLabelConfig extends ContainerConfig {\n  // nothing yet\n}\n\n/**\n * A label for a {@link SeekBar} that can display the seek target time, a thumbnail, and title (e.g. chapter title).\n */\nexport class SeekBarLabel extends Container<SeekBarLabelConfig> {\n\n  private timeLabel: Label<LabelConfig>;\n  private titleLabel: Label<LabelConfig>;\n  private thumbnail: Component<ComponentConfig>;\n\n  private thumbnailImageLoader: ImageLoader;\n\n  private timeFormat: string;\n\n  constructor(config: SeekBarLabelConfig = {}) {\n    super(config);\n\n    this.timeLabel = new Label({ cssClasses: ['seekbar-label-time'] });\n    this.titleLabel = new Label({ cssClasses: ['seekbar-label-title'] });\n    this.thumbnail = new Component({ cssClasses: ['seekbar-thumbnail'] });\n    this.thumbnailImageLoader = new ImageLoader();\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-seekbar-label',\n      components: [new Container({\n        components: [\n          this.thumbnail,\n          new Container({\n            components: [this.titleLabel, this.timeLabel],\n            cssClass: 'seekbar-label-metadata',\n          })],\n        cssClass: 'seekbar-label-inner',\n      })],\n      hidden: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let appliedMarkerCssClasses: string[] = [];\n\n    uimanager.onSeekPreview.subscribeRateLimited((sender, args: SeekPreviewArgs) => {\n      if (player.isLive()) {\n        let maxTimeShift = player.getMaxTimeShift();\n        let time = maxTimeShift - maxTimeShift * (args.position / 100);\n        this.setTime(time);\n      } else {\n        if (args.marker) {\n          this.setTitleText(args.marker.marker.title);\n        } else {\n          this.setTitleText(null);\n        }\n        let time = player.getDuration() * (args.position / 100);\n        this.setTime(time);\n        this.setThumbnail(player.getThumb(time));\n      }\n\n      // Remove CSS classes from previous marker\n      if (appliedMarkerCssClasses.length > 0) {\n        this.getDomElement().removeClass(appliedMarkerCssClasses.join(' '));\n        appliedMarkerCssClasses = [];\n      }\n\n      // Add CSS classes of current marker\n      if (args.marker) {\n        const cssClasses = (args.marker.marker.cssClasses || []).map(cssClass => this.prefixCss(cssClass));\n        this.getDomElement().addClass(cssClasses.join(' '));\n        appliedMarkerCssClasses = cssClasses;\n      }\n    }, 100);\n\n    let init = () => {\n      // Set time format depending on source duration\n      this.timeFormat = Math.abs(player.isLive() ? player.getMaxTimeShift() : player.getDuration()) >= 3600 ?\n        StringUtils.FORMAT_HHMMSS : StringUtils.FORMAT_MMSS;\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, init);\n    init();\n  }\n\n  /**\n   * Sets arbitrary text on the label.\n   * @param text the text to show on the label\n   */\n  setText(text: string) {\n    this.timeLabel.setText(text);\n  }\n\n  /**\n   * Sets a time to be displayed on the label.\n   * @param seconds the time in seconds to display on the label\n   */\n  setTime(seconds: number) {\n    this.setText(StringUtils.secondsToTime(seconds, this.timeFormat));\n  }\n\n  /**\n   * Sets the text on the title label.\n   * @param text the text to show on the label\n   */\n  setTitleText(text: string) {\n    this.titleLabel.setText(text);\n  }\n\n  /**\n   * Sets or removes a thumbnail on the label.\n   * @param thumbnail the thumbnail to display on the label or null to remove a displayed thumbnail\n   */\n  setThumbnail(thumbnail: bitmovin.PlayerAPI.Thumbnail = null) {\n    let thumbnailElement = this.thumbnail.getDomElement();\n\n    if (thumbnail == null) {\n      thumbnailElement.css({\n        'background-image': null,\n        'display': null,\n        'width': null,\n        'height': null,\n      });\n    }\n    else {\n      // We use the thumbnail image loader to make sure the thumbnail is loaded and it's size is known before be can\n      // calculate the CSS properties and set them on the element.\n      this.thumbnailImageLoader.load(thumbnail.url, (url, width, height) => {\n        let thumbnailCountX = width / thumbnail.w;\n        let thumbnailCountY = height / thumbnail.h;\n\n        let thumbnailIndexX = thumbnail.x / thumbnail.w;\n        let thumbnailIndexY = thumbnail.y / thumbnail.h;\n\n        let sizeX = 100 * thumbnailCountX;\n        let sizeY = 100 * thumbnailCountY;\n\n        let offsetX = 100 * thumbnailIndexX;\n        let offsetY = 100 * thumbnailIndexY;\n\n        let aspectRatio = 1 / thumbnail.w * thumbnail.h;\n\n        // The thumbnail size is set by setting the CSS 'width' and 'padding-bottom' properties. 'padding-bottom' is\n        // used because it is relative to the width and can be used to set the aspect ratio of the thumbnail.\n        // A default value for width is set in the stylesheet and can be overwritten from there or anywhere else.\n        thumbnailElement.css({\n          'display': 'inherit',\n          'background-image': `url(${thumbnail.url})`,\n          'padding-bottom': `${100 * aspectRatio}%`,\n          'background-size': `${sizeX}% ${sizeY}%`,\n          'background-position': `-${offsetX}% -${offsetY}%`,\n        });\n      });\n    }\n  }\n}","import {ListSelector, ListSelectorConfig} from './listselector';\nimport {DOM} from '../dom';\n\n/**\n * A simple select box providing the possibility to select a single item out of a list of available items.\n *\n * DOM example:\n * <code>\n *     <select class='ui-selectbox'>\n *         <option value='key'>label</option>\n *         ...\n *     </select>\n * </code>\n */\nexport class SelectBox extends ListSelector<ListSelectorConfig> {\n\n  private selectElement: DOM;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-selectbox',\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let selectElement = new DOM('select', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    });\n\n    this.selectElement = selectElement;\n    this.updateDomItems();\n\n    selectElement.on('change', () => {\n      let value = selectElement.val();\n      this.onItemSelectedEvent(value, false);\n    });\n\n    return selectElement;\n  }\n\n  protected updateDomItems(selectedValue: string = null) {\n    // Delete all children\n    this.selectElement.empty();\n\n    // Add updated children\n    for (let item of this.items) {\n      let optionElement = new DOM('option', {\n        'value': item.key,\n      }).html(item.label);\n\n      if (item.key === String(selectedValue)) { // convert selectedValue to string to catch 'null'/null case\n        optionElement.attr('selected', 'selected');\n      }\n\n      this.selectElement.append(optionElement);\n    }\n  }\n\n  protected onItemAddedEvent(value: string) {\n    super.onItemAddedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemRemovedEvent(value: string) {\n    super.onItemRemovedEvent(value);\n    this.updateDomItems(this.selectedItem);\n  }\n\n  protected onItemSelectedEvent(value: string, updateDomItems: boolean = true) {\n    super.onItemSelectedEvent(value);\n    if (updateDomItems) {\n      this.updateDomItems(value);\n    }\n  }\n}\n","import {ContainerConfig, Container} from './container';\nimport {ComponentConfig, Component} from './component';\nimport {SelectBox} from './selectbox';\nimport {Label} from './label';\nimport {UIInstanceManager} from '../uimanager';\nimport {VideoQualitySelectBox} from './videoqualityselectbox';\nimport {AudioQualitySelectBox} from './audioqualityselectbox';\nimport {Timeout} from '../timeout';\nimport {Event, EventDispatcher, NoArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link SettingsPanel}.\n */\nexport interface SettingsPanelConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the settings panel will be hidden when there is no user interaction.\n   * Set to -1 to disable automatic hiding.\n   * Default: 3 seconds (3000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * A panel containing a list of {@link SettingsPanelItem items} that represent labelled settings.\n */\nexport class SettingsPanel extends Container<SettingsPanelConfig> {\n\n  private static readonly CLASS_LAST = 'last';\n\n  private settingsPanelEvents = {\n    onSettingsStateChanged: new EventDispatcher<SettingsPanel, NoArgs>(),\n  };\n\n  private hideTimeout: Timeout;\n\n  constructor(config: SettingsPanelConfig) {\n    super(config);\n\n    this.config = this.mergeConfig<SettingsPanelConfig>(config, {\n      cssClass: 'ui-settings-panel',\n      hideDelay: 3000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsPanelConfig>this.getConfig(); // TODO fix generics type inference\n\n    if (config.hideDelay > -1) {\n      this.hideTimeout = new Timeout(config.hideDelay, () => {\n        this.hide();\n        this.hideHoveredSelectBoxes();\n      });\n\n      this.onShow.subscribe(() => {\n        // Activate timeout when shown\n        this.hideTimeout.start();\n      });\n      this.getDomElement().on('mouseenter', () => {\n        // On mouse enter clear the timeout\n        this.hideTimeout.clear();\n      });\n      this.getDomElement().on('mouseleave', () => {\n        // On mouse leave activate the timeout\n        this.hideTimeout.reset();\n      });\n      this.onHide.subscribe(() => {\n        // Clear timeout when hidden from outside\n        this.hideTimeout.clear();\n      });\n    }\n\n    // Fire event when the state of a settings-item has changed\n    let settingsStateChangedHandler = () => {\n      this.onSettingsStateChangedEvent();\n\n      // Attach marker class to last visible item\n      let lastShownItem = null;\n      for (let component of this.getItems()) {\n        component.getDomElement().removeClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n        if (component.isShown()) {\n          lastShownItem = component;\n        }\n      }\n      if (lastShownItem) {\n        lastShownItem.getDomElement().addClass(this.prefixCss(SettingsPanel.CLASS_LAST));\n      }\n    };\n    for (let component of this.getItems()) {\n      component.onActiveChanged.subscribe(settingsStateChangedHandler);\n    }\n  }\n\n  /**\n   * Hack for IE + Firefox\n   * when the settings panel fades out while an item of a select box is still hovered, the select box will not fade out\n   * while the settings panel does. This would leave a floating select box, which is just weird\n   */\n  private hideHoveredSelectBoxes() {\n    this.getItems().forEach((item: SettingsPanelItem) => {\n      if (item.isActive() && (item as any).setting instanceof SelectBox) {\n        const selectBox = (item as any).setting as SelectBox;\n        const oldDisplay = selectBox.getDomElement().css('display');\n        // updating the display to none marks the select-box as inactive, so it will be hidden with the rest\n        // we just have to make sure to reset this as soon as possible\n        selectBox.getDomElement().css('display', 'none');\n        if (window.requestAnimationFrame) {\n          requestAnimationFrame(() => { selectBox.getDomElement().css('display', oldDisplay); });\n        } else {\n          // IE9 has no requestAnimationFrame, set the value directly. It has no optimization about ignoring DOM-changes\n          // between animationFrames\n          selectBox.getDomElement().css('display', oldDisplay);\n        }\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n    if (this.hideTimeout) {\n      this.hideTimeout.clear();\n    }\n  }\n\n  /**\n   * Checks if there are active settings within this settings panel. An active setting is a setting that is visible\n   * and enabled, which the user can interact with.\n   * @returns {boolean} true if there are active settings, false if the panel is functionally empty to a user\n   */\n  hasActiveSettings(): boolean {\n    for (let component of this.getItems()) {\n      if (component.isActive()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private getItems(): SettingsPanelItem[] {\n    return <SettingsPanelItem[]>this.config.components.filter(component => component instanceof SettingsPanelItem);\n  }\n\n  protected onSettingsStateChangedEvent() {\n    this.settingsPanelEvents.onSettingsStateChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when one or more {@link SettingsPanelItem items} have changed state.\n   * @returns {Event<SettingsPanel, NoArgs>}\n   */\n  get onSettingsStateChanged(): Event<SettingsPanel, NoArgs> {\n    return this.settingsPanelEvents.onSettingsStateChanged.getEvent();\n  }\n}\n\n/**\n * An item for a {@link SettingsPanel},\n * Containing an optionnal {@link Label} and a component that configures a setting.\n * If the components is a {@link SelectBox} it will handle the logic of displaying it or not\n */\nexport class SettingsPanelItem extends Container<ContainerConfig> {\n\n  private label: Component<ComponentConfig>;\n  private setting: Component<ComponentConfig>;\n\n  private settingsPanelItemEvents = {\n    onActiveChanged: new EventDispatcher<SettingsPanelItem, NoArgs>(),\n  };\n\n  constructor(label: string | Component<ComponentConfig>, setting: Component<ComponentConfig>, config: ContainerConfig = {}) {\n    super(config);\n\n    this.setting = setting;\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settings-panel-item',\n    }, this.config);\n\n    if (label !== null) {\n      if (label instanceof Component) {\n        this.label = label;\n      } else {\n        this.label = new Label({ text: label });\n      }\n      this.addComponent(this.label);\n    }\n\n    this.addComponent(this.setting);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    if (this.setting instanceof SelectBox) {\n      let handleConfigItemChanged = () => {\n        if (! (this.setting instanceof SelectBox)) {\n          return;\n        }\n        // The minimum number of items that must be available for the setting to be displayed\n        // By default, at least two items must be available, else a selection is not possible\n        let minItemsToDisplay = 2;\n        // Audio/video quality select boxes contain an additional 'auto' mode, which in combination with a single\n        // available quality also does not make sense\n        if ((this.setting instanceof VideoQualitySelectBox && this.setting.hasAutoItem())\n          || this.setting instanceof AudioQualitySelectBox) {\n          minItemsToDisplay = 3;\n        }\n\n        // Hide the setting if no meaningful choice is available\n        if (this.setting.itemCount() < minItemsToDisplay) {\n          this.hide();\n        } else {\n          this.show();\n        }\n\n        // Visibility might have changed and therefore the active state might have changed so we fire the event\n        // TODO fire only when state has really changed (e.g. check if visibility has really changed)\n        this.onActiveChangedEvent();\n      };\n\n      this.setting.onItemAdded.subscribe(handleConfigItemChanged);\n      this.setting.onItemRemoved.subscribe(handleConfigItemChanged);\n\n      // Initialize hidden state\n      handleConfigItemChanged();\n    }\n  }\n\n  /**\n   * Checks if this settings panel item is active, i.e. visible and enabled and a user can interact with it.\n   * @returns {boolean} true if the panel is active, else false\n   */\n  isActive(): boolean {\n    return this.isShown();\n  }\n\n  protected onActiveChangedEvent() {\n    this.settingsPanelItemEvents.onActiveChanged.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the 'active' state of this item changes.\n   * @see #isActive\n   * @returns {Event<SettingsPanelItem, NoArgs>}\n   */\n  get onActiveChanged(): Event<SettingsPanelItem, NoArgs> {\n    return this.settingsPanelItemEvents.onActiveChanged.getEvent();\n  }\n}\n","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {SettingsPanel} from './settingspanel';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link SettingsToggleButton}.\n */\nexport interface SettingsToggleButtonConfig extends ToggleButtonConfig {\n  /**\n   * The settings panel whose visibility the button should toggle.\n   */\n  settingsPanel: SettingsPanel;\n\n  /**\n   * Decides if the button should be automatically hidden when the settings panel does not contain any active settings.\n   * Default: true\n   */\n  autoHideWhenNoActiveSettings?: boolean;\n}\n\n/**\n * A button that toggles visibility of a settings panel.\n */\nexport class SettingsToggleButton extends ToggleButton<SettingsToggleButtonConfig> {\n\n  constructor(config: SettingsToggleButtonConfig) {\n    super(config);\n\n    if (!config.settingsPanel) {\n      throw new Error('Required SettingsPanel is missing');\n    }\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-settingstogglebutton',\n      text: 'Settings',\n      settingsPanel: null,\n      autoHideWhenNoActiveSettings: true,\n    }, <SettingsToggleButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <SettingsToggleButtonConfig>this.getConfig(); // TODO fix generics type inference\n    let settingsPanel = config.settingsPanel;\n\n    this.onClick.subscribe(() => {\n      settingsPanel.toggleHidden();\n    });\n    settingsPanel.onShow.subscribe(() => {\n      // Set toggle status to on when the settings panel shows\n      this.on();\n    });\n    settingsPanel.onHide.subscribe(() => {\n      // Set toggle status to off when the settings panel hides\n      this.off();\n    });\n\n    // Handle automatic hiding of the button if there are no settings for the user to interact with\n    if (config.autoHideWhenNoActiveSettings) {\n      // Setup handler to show/hide button when the settings change\n      let settingsPanelItemsChangedHandler = () => {\n        if (settingsPanel.hasActiveSettings()) {\n          if (this.isHidden()) {\n            this.show();\n          }\n        } else {\n          if (this.isShown()) {\n            this.hide();\n          }\n        }\n      };\n      // Wire the handler to the event\n      settingsPanel.onSettingsStateChanged.subscribe(settingsPanelItemsChangedHandler);\n      // Call handler for first init at startup\n      settingsPanelItemsChangedHandler();\n    }\n  }\n}","import {Component, ComponentConfig} from './component';\n\n/**\n * A dummy component that just reserves some space and does nothing else.\n */\nexport class Spacer extends Component<ComponentConfig> {\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-spacer',\n    }, this.config);\n  }\n\n\n  protected onShowEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHideEvent(): void {\n    // disable event firing by overwriting and not calling super\n  }\n\n  protected onHoverChangedEvent(hovered: boolean): void {\n    // disable event firing by overwriting and not calling super\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport SubtitleCueEvent = bitmovin.PlayerAPI.SubtitleCueEvent;\nimport {Label, LabelConfig} from './label';\nimport {ComponentConfig, Component} from './component';\nimport {ControlBar} from './controlbar';\nimport { EventDispatcher } from '../eventdispatcher';\n\n/**\n * Overlays the player to display subtitles.\n */\nexport class SubtitleOverlay extends Container<ContainerConfig> {\n\n  private subtitleManager: ActiveSubtitleManager;\n  private previewSubtitleActive: boolean;\n  private previewSubtitle: SubtitleLabel;\n\n  private preprocessLabelEventCallback = new EventDispatcher<SubtitleCueEvent, SubtitleLabel>();\n\n  private static readonly CLASS_CONTROLBAR_VISIBLE = 'controlbar-visible';\n  private static readonly CLASS_CEA_608 = 'cea608';\n  // The number of rows in a cea608 grid\n  private static readonly CEA608_NUM_ROWS = 15;\n  // The number of columns in a cea608 grid\n  private static readonly CEA608_NUM_COLUMNS = 32;\n  // The offset in percent for one row (which is also the height of a row)\n  private static readonly CEA608_ROW_OFFSET = 100 / SubtitleOverlay.CEA608_NUM_ROWS;\n  // The offset in percent for one column (which is also the width of a column)\n  private static readonly CEA608_COLUMN_OFFSET = 100 / SubtitleOverlay.CEA608_NUM_COLUMNS;\n\n  constructor(config: ContainerConfig = {}) {\n    super(config);\n\n    this.previewSubtitleActive = false;\n    this.previewSubtitle = new SubtitleLabel({ text: 'example subtitle' });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-overlay',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let subtitleManager = new ActiveSubtitleManager();\n    this.subtitleManager = subtitleManager;\n\n    player.addEventHandler(player.EVENT.ON_CUE_ENTER, (event: SubtitleCueEvent) => {\n      // Sanitize cue data (must be done before the cue ID is generated in subtitleManager.cueEnter)\n      if (event.position) {\n        // Sometimes the positions are undefined, we assume them to be zero\n        event.position.row = event.position.row || 0;\n        event.position.column = event.position.column || 0;\n      }\n\n      let labelToAdd = subtitleManager.cueEnter(event);\n\n      this.preprocessLabelEventCallback.dispatch(event, labelToAdd);\n\n      if (this.previewSubtitleActive) {\n        this.removeComponent(this.previewSubtitle);\n      }\n      this.addComponent(labelToAdd);\n      this.updateComponents();\n\n      this.show();\n    });\n    player.addEventHandler(player.EVENT.ON_CUE_EXIT, (event: SubtitleCueEvent) => {\n      let labelToRemove = subtitleManager.cueExit(event);\n\n      if (labelToRemove) {\n        this.removeComponent(labelToRemove);\n        this.updateComponents();\n      }\n\n      if (!subtitleManager.hasCues) {\n        if (!this.previewSubtitleActive) {\n          this.hide();\n        } else {\n          this.addComponent(this.previewSubtitle);\n          this.updateComponents();\n        }\n      }\n    });\n\n    let subtitleClearHandler = () => {\n      this.hide();\n      subtitleManager.clear();\n      this.removeComponents();\n      this.updateComponents();\n    };\n\n    player.addEventHandler(player.EVENT.ON_AUDIO_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SEEK, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_TIME_SHIFT, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, subtitleClearHandler);\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, subtitleClearHandler);\n\n    uimanager.onComponentShow.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().addClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n    uimanager.onComponentHide.subscribe((component: Component<ComponentConfig>) => {\n      if (component instanceof ControlBar) {\n        this.getDomElement().removeClass(this.prefixCss(SubtitleOverlay.CLASS_CONTROLBAR_VISIBLE));\n      }\n    });\n\n    this.configureCea608Captions(player, uimanager);\n    // Init\n    subtitleClearHandler();\n  }\n\n  configureCea608Captions(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    // The calculated font size\n    let fontSize = 0;\n    // The required letter spacing spread the text characters evenly across the grid\n    let fontLetterSpacing = 0;\n    // Flag telling if a font size calculation is required of if the current values are valid\n    let fontSizeCalculationRequired = true;\n    // Flag telling if the CEA-608 mode is enabled\n    let enabled = false;\n\n    const updateCEA608FontSize = () => {\n      const dummyLabel = new SubtitleLabel({ text: 'X' });\n      dummyLabel.getDomElement().css({\n        // By using a large font size we do not need to use multiple letters and can get still an\n        // accurate measurement even though the returned size is an integer value\n        'font-size': '200px',\n        'line-height': '200px',\n        'visibility': 'hidden',\n      });\n      this.addComponent(dummyLabel);\n      this.updateComponents();\n      this.show();\n\n      const dummyLabelCharWidth = dummyLabel.getDomElement().width();\n      const dummyLabelCharHeight = dummyLabel.getDomElement().height();\n      const fontSizeRatio = dummyLabelCharWidth / dummyLabelCharHeight;\n\n      this.removeComponent(dummyLabel);\n      this.updateComponents();\n      if (!this.subtitleManager.hasCues) {\n        this.hide();\n      }\n\n      // We subtract 1px here to avoid line breaks at the right border of the subtitle overlay that can happen\n      // when texts contain whitespaces. It's probably some kind of pixel rounding issue in the browser's\n      // layouting, but the actual reason could not be determined. Aiming for a target width - 1px would work in\n      // most browsers, but Safari has a \"quantized\" font size rendering with huge steps in between so we need\n      // to subtract some more pixels to avoid line breaks there as well.\n      const subtitleOverlayWidth = this.getDomElement().width() - 10;\n      const subtitleOverlayHeight = this.getDomElement().height();\n\n      // The size ratio of the letter grid\n      const fontGridSizeRatio = (dummyLabelCharWidth * SubtitleOverlay.CEA608_NUM_COLUMNS) /\n        (dummyLabelCharHeight * SubtitleOverlay.CEA608_NUM_ROWS);\n      // The size ratio of the available space for the grid\n      const subtitleOverlaySizeRatio = subtitleOverlayWidth / subtitleOverlayHeight;\n\n      if (subtitleOverlaySizeRatio > fontGridSizeRatio) {\n        // When the available space is wider than the text grid, the font size is simply\n        // determined by the height of the available space.\n        fontSize = subtitleOverlayHeight / SubtitleOverlay.CEA608_NUM_ROWS;\n\n        // Calculate the additional letter spacing required to evenly spread the text across the grid's width\n        const gridSlotWidth = subtitleOverlayWidth / SubtitleOverlay.CEA608_NUM_COLUMNS;\n        const fontCharWidth = fontSize * fontSizeRatio;\n        fontLetterSpacing = gridSlotWidth - fontCharWidth;\n      } else {\n        // When the available space is not wide enough, texts would vertically overlap if we take\n        // the height as a base for the font size, so we need to limit the height. We do that\n        // by determining the font size by the width of the available space.\n        fontSize = subtitleOverlayWidth / SubtitleOverlay.CEA608_NUM_COLUMNS / fontSizeRatio;\n        fontLetterSpacing = 0;\n      }\n\n      // Update font-size of all active subtitle labels\n      for (let label of this.getComponents()) {\n        if (label instanceof SubtitleLabel) {\n          label.getDomElement().css({\n            'font-size': `${fontSize}px`,\n            'letter-spacing': `${fontLetterSpacing}px`,\n          });\n        }\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      if (enabled) {\n        updateCEA608FontSize();\n      } else {\n        fontSizeCalculationRequired = true;\n      }\n    });\n\n    this.preprocessLabelEventCallback.subscribe((event: SubtitleCueEvent, label: SubtitleLabel) => {\n      const isCEA608 = event.position != null;\n      if (!isCEA608) {\n        // Skip all non-CEA608 cues\n        return;\n      }\n\n      if (!enabled) {\n        enabled = true;\n        this.getDomElement().addClass(this.prefixCss(SubtitleOverlay.CLASS_CEA_608));\n\n        // We conditionally update the font size by this flag here to avoid updating every time a subtitle\n        // is added into an empty overlay. Because we reset the overlay when all subtitles are gone, this\n        // would trigger an unnecessary update every time, but it's only required under certain conditions,\n        // e.g. after the player size has changed.\n        if (fontSizeCalculationRequired) {\n          updateCEA608FontSize();\n          fontSizeCalculationRequired = false;\n        }\n      }\n\n      label.getDomElement().css({\n        'left': `${event.position.column * SubtitleOverlay.CEA608_COLUMN_OFFSET}%`,\n        'top': `${event.position.row * SubtitleOverlay.CEA608_ROW_OFFSET}%`,\n        'font-size': `${fontSize}px`,\n        'letter-spacing': `${fontLetterSpacing}px`,\n      });\n    });\n\n    const reset = () => {\n      this.getDomElement().removeClass(this.prefixCss(SubtitleOverlay.CLASS_CEA_608));\n      enabled = false;\n    };\n\n    player.addEventHandler(player.EVENT.ON_CUE_EXIT, () => {\n      if (!this.subtitleManager.hasCues) {\n        // Disable CEA-608 mode when all subtitles are gone (to allow correct formatting and\n        // display of other types of subtitles, e.g. the formatting preview subtitle)\n        reset();\n      }\n    });\n\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, reset);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, reset);\n  }\n\n  enablePreviewSubtitleLabel(): void {\n    this.previewSubtitleActive = true;\n    if (!this.subtitleManager.hasCues) {\n      this.addComponent(this.previewSubtitle);\n      this.updateComponents();\n      this.show();\n    }\n  }\n\n  removePreviewSubtitleLabel(): void {\n    this.previewSubtitleActive = false;\n    this.removeComponent(this.previewSubtitle);\n    this.updateComponents();\n  }\n}\n\ninterface ActiveSubtitleCue {\n  event: SubtitleCueEvent;\n  label: SubtitleLabel;\n}\n\ninterface ActiveSubtitleCueMap {\n  [id: string]: ActiveSubtitleCue[];\n}\n\nclass SubtitleLabel extends Label<LabelConfig> {\n\n  constructor(config: LabelConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitle-label',\n    }, this.config);\n  }\n}\n\nclass ActiveSubtitleManager {\n\n  private activeSubtitleCueMap: ActiveSubtitleCueMap;\n  private activeSubtitleCueCount: number;\n\n  constructor() {\n    this.activeSubtitleCueMap = {};\n    this.activeSubtitleCueCount = 0;\n  }\n\n  /**\n   * Calculates a unique ID for a subtitle cue, which is needed to associate an ON_CUE_ENTER with its ON_CUE_EXIT\n   * event so we can remove the correct subtitle in ON_CUE_EXIT when multiple subtitles are active at the same time.\n   * The start time plus the text should make a unique identifier, and in the only case where a collision\n   * can happen, two similar texts will be displayed at a similar time and a similar position (or without position).\n   * The start time should always be known, because it is required to schedule the ON_CUE_ENTER event. The end time\n   * must not necessarily be known and therefore cannot be used for the ID.\n   * @param event\n   * @return {string}\n   */\n  private static calculateId(event: SubtitleCueEvent): string {\n    let id = event.start + '-' + event.text;\n\n    if (event.position) {\n      id += '-' + event.position.row + '-' + event.position.column;\n    }\n\n    return id;\n  }\n\n  /**\n   * Adds a subtitle cue to the manager and returns the label that should be added to the subtitle overlay.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  cueEnter(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n\n    let label = new SubtitleLabel({\n      // Prefer the HTML subtitle text if set, else use the plain text\n      text: event.html || event.text,\n    });\n\n    // Create array for id if it does not exist\n    this.activeSubtitleCueMap[id] = this.activeSubtitleCueMap[id] || [];\n\n    // Add cue\n    this.activeSubtitleCueMap[id].push({ event, label });\n    this.activeSubtitleCueCount++;\n\n    return label;\n  }\n\n  /**\n   * Returns the label associated with an already added cue.\n   * @param event\n   * @return {SubtitleLabel}\n   */\n  getCues(event: SubtitleCueEvent): SubtitleLabel[] {\n    let id = ActiveSubtitleManager.calculateId(event);\n    let activeSubtitleCues = this.activeSubtitleCueMap[id];\n    if (activeSubtitleCues && activeSubtitleCues.length > 0) {\n      return activeSubtitleCues.map((cue) => cue.label);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Removes the subtitle cue from the manager and returns the label that should be removed from the subtitle overlay,\n   * or null if there is no associated label existing (e.g. because all labels have been {@link #clear cleared}.\n   * @param event\n   * @return {SubtitleLabel|null}\n   */\n  cueExit(event: SubtitleCueEvent): SubtitleLabel {\n    let id = ActiveSubtitleManager.calculateId(event);\n    let activeSubtitleCues = this.activeSubtitleCueMap[id];\n\n    if (activeSubtitleCues && activeSubtitleCues.length > 0) {\n      // Remove cue\n      /* We apply the FIFO approach here and remove the oldest cue from the associated id. When there are multiple cues\n       * with the same id, there is no way to know which one of the cues is to be deleted, so we just hope that FIFO\n       * works fine. Theoretically it can happen that two cues with colliding ids are removed at different times, in\n       * the wrong order. This rare case has yet to be observed. If it ever gets an issue, we can take the unstable\n       * cue end time (which can change between ON_CUE_ENTER and ON_CUE_EXIT IN ON_CUE_UPDATE) and use it as an\n       * additional hint to try and remove the correct one of the colliding cues.\n       */\n      let activeSubtitleCue = activeSubtitleCues.shift();\n      this.activeSubtitleCueCount--;\n\n      return activeSubtitleCue.label;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Returns the number of active subtitle cues.\n   * @return {number}\n   */\n  get cueCount(): number {\n    // We explicitly count the cues to save an Array.reduce on every cueCount call (which can happen frequently)\n    return this.activeSubtitleCueCount;\n  }\n\n  /**\n   * Returns true if there are active subtitle cues, else false.\n   * @return {boolean}\n   */\n  get hasCues(): boolean {\n    return this.cueCount > 0;\n  }\n\n  /**\n   * Removes all subtitle cues from the manager.\n   */\n  clear(): void {\n    this.activeSubtitleCueMap = {};\n    this.activeSubtitleCueCount = 0;\n  }\n}\n","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between available subtitle and caption tracks.\n */\nexport class SubtitleSelectBox extends SelectBox {\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let selectCurrentSubtitle = () => {\n      let currentSubtitle = player.getSubtitle();\n\n      if (currentSubtitle) {\n        this.selectItem(currentSubtitle.id);\n      }\n    };\n\n    let updateSubtitles = () => {\n      this.clearItems();\n\n      for (let subtitle of player.getAvailableSubtitles()) {\n        this.addItem(subtitle.id, subtitle.label);\n      }\n\n      // Select the correct subtitle after the subtitles have been added\n      selectCurrentSubtitle();\n    };\n\n    this.onItemSelected.subscribe((sender: SubtitleSelectBox, value: string) => {\n      player.setSubtitle(value === 'null' ? null : value);\n    });\n\n    // React to API events\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_ADDED, updateSubtitles);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_CHANGED, selectCurrentSubtitle);\n    player.addEventHandler(player.EVENT.ON_SUBTITLE_REMOVED, updateSubtitles);\n    // Update subtitles when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateSubtitles);\n    // Update subtitles when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateSubtitles);\n    // Update subtitles when the period within a source changes\n    player.addEventHandler(player.EVENT.ON_PERIOD_SWITCHED, updateSubtitles);\n\n    // Populate subtitles at startup\n    updateSubtitles();\n  }\n}","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different background colors.\n */\nexport class BackgroundColorSelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('white', 'white');\n    this.addItem('black', 'black');\n    this.addItem('red', 'red');\n    this.addItem('green', 'green');\n    this.addItem('blue', 'blue');\n    this.addItem('cyan', 'cyan');\n    this.addItem('yellow', 'yellow');\n    this.addItem('magenta', 'magenta');\n\n    let setColorAndOpacity = () => {\n      if (this.settingsManager.backgroundColor.isSet() && this.settingsManager.backgroundOpacity.isSet()) {\n        this.toggleOverlayClass(\n          'bgcolor-' + this.settingsManager.backgroundColor.value + this.settingsManager.backgroundOpacity.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.backgroundColor.value = key;\n    });\n\n    this.settingsManager.backgroundColor.onChanged.subscribe((sender, property) => {\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.backgroundColor.isSet()) {\n        // ... clear the opacity when the color is not set\n        this.settingsManager.backgroundOpacity.clear();\n      } else if (!this.settingsManager.backgroundOpacity.isSet()) {\n        // ... set an opacity when the color is set\n        this.settingsManager.backgroundOpacity.value = '100';\n      }\n      this.selectItem(property.value);\n      setColorAndOpacity();\n    });\n\n    this.settingsManager.backgroundOpacity.onChanged.subscribe(() => {\n      setColorAndOpacity();\n    });\n\n    // Load initial value\n    if (this.settingsManager.backgroundColor.isSet()) {\n      this.selectItem(this.settingsManager.backgroundColor.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different background opacity.\n */\nexport class BackgroundOpacitySelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('100', '100%');\n    this.addItem('75', '75%');\n    this.addItem('50', '50%');\n    this.addItem('25', '25%');\n    this.addItem('0', '0%');\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.backgroundOpacity.value = key;\n\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.backgroundOpacity.isSet()) {\n        // ... clear the color when the opacity is not set\n        this.settingsManager.backgroundColor.clear();\n      } else if (!this.settingsManager.backgroundColor.isSet()) {\n        // ... set a color when the opacity is set\n        this.settingsManager.backgroundColor.value = 'black';\n      }\n    });\n\n    // Update selected item when value is set from somewhere else\n    this.settingsManager.backgroundOpacity.onChanged.subscribe((sender, property) => {\n      this.selectItem(property.value);\n    });\n\n    // Load initial value\n    if (this.settingsManager.backgroundOpacity.isSet()) {\n      this.selectItem(this.settingsManager.backgroundOpacity.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different character edge.\n */\nexport class CharacterEdgeSelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('raised', 'raised');\n    this.addItem('depressed', 'depressed');\n    this.addItem('uniform', 'uniform');\n    this.addItem('dropshadowed', 'drop shadowed');\n\n    this.settingsManager.characterEdge.onChanged.subscribe((sender, property) => {\n      if (property.isSet()) {\n        this.toggleOverlayClass('characteredge-' + property.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n\n      // Select the item in case the property was set from outside\n      this.selectItem(property.value);\n    });\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.characterEdge.value = key;\n    });\n\n    // Load initial value\n    if (this.settingsManager.characterEdge.isSet()) {\n      this.selectItem(this.settingsManager.characterEdge.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different font colors.\n */\nexport class FontColorSelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('white', 'white');\n    this.addItem('black', 'black');\n    this.addItem('red', 'red');\n    this.addItem('green', 'green');\n    this.addItem('blue', 'blue');\n    this.addItem('cyan', 'cyan');\n    this.addItem('yellow', 'yellow');\n    this.addItem('magenta', 'magenta');\n\n    let setColorAndOpacity = () => {\n      if (this.settingsManager.fontColor.isSet() && this.settingsManager.fontOpacity.isSet()) {\n        this.toggleOverlayClass(\n          'fontcolor-' + this.settingsManager.fontColor.value + this.settingsManager.fontOpacity.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.fontColor.value = key;\n    });\n\n    this.settingsManager.fontColor.onChanged.subscribe((sender, property) => {\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.fontColor.isSet()) {\n        // ... clear the opacity when the color is not set\n        this.settingsManager.fontOpacity.clear();\n      } else if (!this.settingsManager.fontOpacity.isSet()) {\n        // ... set an opacity when the color is set\n        this.settingsManager.fontOpacity.value = '100';\n      }\n      this.selectItem(property.value);\n      setColorAndOpacity();\n    });\n\n    this.settingsManager.fontOpacity.onChanged.subscribe(() => {\n      setColorAndOpacity();\n    });\n\n    // Load initial value\n    if (this.settingsManager.fontColor.isSet()) {\n      this.selectItem(this.settingsManager.fontColor.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different font family.\n */\nexport class FontFamilySelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('monospacedserif', 'monospaced serif');\n    this.addItem('proportionalserif', 'proportional serif');\n    this.addItem('monospacedsansserif', 'monospaced sans serif');\n    this.addItem('proportionalsansserif', 'proportional sans serif');\n    this.addItem('casual', 'casual');\n    this.addItem('cursive', 'cursive');\n    this.addItem('smallcapital', 'small capital');\n\n    this.settingsManager.fontFamily.onChanged.subscribe((sender, property) => {\n      if (property.isSet()) {\n        this.toggleOverlayClass('fontfamily-' + property.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n\n      // Select the item in case the property was set from outside\n      this.selectItem(property.value);\n    });\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.fontFamily.value = key;\n    });\n\n    // Load initial value\n    if (this.settingsManager.fontFamily.isSet()) {\n      this.selectItem(this.settingsManager.fontFamily.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different font colors.\n */\nexport class FontOpacitySelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('100', '100%');\n    this.addItem('75', '75%');\n    this.addItem('50', '50%');\n    this.addItem('25', '25%');\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.fontOpacity.value = key;\n\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.fontOpacity.isSet()) {\n        // ... clear the color when the opacity is not set\n        this.settingsManager.fontColor.clear();\n      } else if (!this.settingsManager.fontColor.isSet()) {\n        // ... set a color when the opacity is set\n        this.settingsManager.fontColor.value = 'white';\n      }\n    });\n\n    // Update selected item when value is set from somewhere else\n    this.settingsManager.fontOpacity.onChanged.subscribe((sender, property) => {\n      this.selectItem(property.value);\n    });\n\n    // Load initial value\n    if (this.settingsManager.fontOpacity.isSet()) {\n      this.selectItem(this.settingsManager.fontOpacity.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different font colors.\n */\nexport class FontSizeSelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('50', '50%');\n    this.addItem('75', '75%');\n    this.addItem('100', '100%');\n    this.addItem('150', '150%');\n    this.addItem('200', '200%');\n    this.addItem('300', '300%');\n    this.addItem('400', '400%');\n\n    this.settingsManager.fontSize.onChanged.subscribe((sender, property) => {\n      if (property.isSet()) {\n        this.toggleOverlayClass('fontsize-' + property.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n\n      // Select the item in case the property was set from outside\n      this.selectItem(property.value);\n    });\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.fontSize.value = key;\n    });\n\n    // Load initial value\n    if (this.settingsManager.fontSize.isSet()) {\n      this.selectItem(this.settingsManager.fontSize.value);\n    }\n  }\n}\n","import {Button, ButtonConfig} from '../button';\nimport {SettingsPanel} from '../settingspanel';\nimport {SubtitleSettingsPanel} from './subtitlesettingspanel';\n\nexport interface SubtitleSettingsButtonConfig extends ButtonConfig {\n  subtitleSettingsPanel: SubtitleSettingsPanel;\n  settingsPanel: SettingsPanel;\n}\n\nexport class SubtitleSettingsButton extends Button<ButtonConfig> {\n\n  protected subtitleSettingsPanel: SubtitleSettingsPanel;\n  protected settingsPanel: SettingsPanel;\n\n  constructor(config: SubtitleSettingsButtonConfig) {\n    super(config);\n\n    this.subtitleSettingsPanel = config.subtitleSettingsPanel;\n    this.settingsPanel = config.settingsPanel;\n  }\n}\n","import {SubtitleSettingsButton} from './subtitlesettingsbutton';\nimport {SubtitleSettingsButtonConfig} from './subtitlesettingsbutton';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A button that toggles the option menu for subtitles\n */\nexport class SubtitleSettingsCloseButton extends SubtitleSettingsButton {\n\n  constructor(config: SubtitleSettingsButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitlesettingsclosebutton',\n      text: 'Back',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      this.subtitleSettingsPanel.hide();\n      this.settingsPanel.show();\n    });\n  }\n}\n","import {SubtitleOverlay} from '../subtitleoverlay';\nimport {ListSelectorConfig} from '../listselector';\nimport {SelectBox} from '../selectbox';\nimport {SubtitleSettingsManager} from './subtitlesettingsmanager';\n\nexport interface SubtitleSettingSelectBoxConfig extends ListSelectorConfig {\n  overlay: SubtitleOverlay;\n  settingsManager: SubtitleSettingsManager;\n}\n\n/**\n * Base class for all subtitles settings select box\n **/\nexport class SubtitleSettingSelectBox extends SelectBox {\n\n  protected settingsManager: SubtitleSettingsManager;\n  protected overlay: SubtitleOverlay;\n  private currentCssClass: string;\n\n  constructor(config: SubtitleSettingSelectBoxConfig) {\n    super(config);\n\n    this.settingsManager = config.settingsManager;\n    this.overlay = config.overlay;\n  }\n\n  /**\n   * Removes a previously set class and adds the passed in class.\n   * @param cssClass The new class to replace the previous class with or null to just remove the previous class\n   */\n  protected toggleOverlayClass(cssClass: string): void {\n    // Remove previous class if existing\n    if (this.currentCssClass) {\n      this.overlay.getDomElement().removeClass(this.currentCssClass);\n      this.currentCssClass = null;\n    }\n\n    // Add new class if specified. If the new class is null, we don't add anything.\n    if (cssClass) {\n      this.currentCssClass = this.prefixCss(cssClass);\n      this.overlay.getDomElement().addClass(this.currentCssClass);\n    }\n  }\n}\n","import {LabelConfig} from '../label';\nimport {Container, ContainerConfig} from '../container';\nimport {SubtitleSettingsOpenButton} from './subtitlesettingsopenbutton';\nimport {DOM} from '../../dom';\n\nexport interface SubtitleSettingsLabelConfig extends LabelConfig {\n  opener: SubtitleSettingsOpenButton;\n}\n\nexport class SubtitleSettingsLabel extends Container<ContainerConfig> {\n\n  private opener: SubtitleSettingsOpenButton;\n\n  private text: string;\n\n  constructor(config: SubtitleSettingsLabelConfig) {\n    super(config);\n\n    this.opener = config.opener;\n    this.text = config.text;\n\n    this.config = this.mergeConfig(<ContainerConfig>config, {\n      cssClass: 'ui-label',\n      components: [\n        this.opener,\n      ],\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    let labelElement = new DOM('span', {\n      'id': this.config.id,\n      'class': this.getCssClasses(),\n    }).append(\n      new DOM('span', {}).html(this.text),\n      this.opener.getDomElement()\n    );\n\n    return labelElement;\n  }\n}\n","import {StorageUtils} from '../../storageutils';\nimport {Component, ComponentConfig} from '../component';\nimport {EventDispatcher, Event} from '../../eventdispatcher';\n\ninterface SubtitleSettings {\n  fontColor?: string;\n  fontOpacity?: string;\n  fontFamily?: string;\n  fontSize?: string;\n  characterEdge?: string;\n  backgroundColor?: string;\n  backgroundOpacity?: string;\n  windowColor?: string;\n  windowOpacity?: string;\n}\n\ninterface Properties {\n  [name: string]: SubtitleSettingsProperty<string>;\n}\n\nexport class SubtitleSettingsManager {\n\n  private userSettings: SubtitleSettings;\n  private localStorageKey: string;\n\n  private _properties: Properties = {\n    fontColor: new SubtitleSettingsProperty<string>(this),\n    fontOpacity: new SubtitleSettingsProperty<string>(this),\n    fontFamily: new SubtitleSettingsProperty<string>(this),\n    fontSize: new SubtitleSettingsProperty<string>(this),\n    characterEdge: new SubtitleSettingsProperty<string>(this),\n    backgroundColor: new SubtitleSettingsProperty<string>(this),\n    backgroundOpacity: new SubtitleSettingsProperty<string>(this),\n    windowColor: new SubtitleSettingsProperty<string>(this),\n    windowOpacity: new SubtitleSettingsProperty<string>(this),\n  };\n\n  constructor() {\n    this.userSettings = {};\n    this.localStorageKey = DummyComponent.instance().prefixCss('subtitlesettings');\n\n    for (let propertyName in this._properties) {\n      this._properties[propertyName].onChanged.subscribe((sender, property) => {\n        if (property.isSet()) {\n          (<any>this.userSettings)[propertyName] = property.value;\n        } else {\n          // Delete the property from the settings object if unset to avoid serialization of null values\n          delete (<any>this.userSettings)[propertyName];\n        }\n\n        // Save the settings object when a property has changed\n        this.save();\n      });\n    }\n\n    this.load();\n  }\n\n  public reset(): void {\n    for (let propertyName in this._properties) {\n      this._properties[propertyName].clear();\n    }\n  }\n\n  public get fontColor(): SubtitleSettingsProperty<string> {\n    return this._properties.fontColor;\n  }\n\n  public get fontOpacity(): SubtitleSettingsProperty<string> {\n    return this._properties.fontOpacity;\n  }\n\n  public get fontFamily(): SubtitleSettingsProperty<string> {\n    return this._properties.fontFamily;\n  }\n\n  public get fontSize(): SubtitleSettingsProperty<string> {\n    return this._properties.fontSize;\n  }\n\n  public get characterEdge(): SubtitleSettingsProperty<string> {\n    return this._properties.characterEdge;\n  }\n\n  public get backgroundColor(): SubtitleSettingsProperty<string> {\n    return this._properties.backgroundColor;\n  }\n\n  public get backgroundOpacity(): SubtitleSettingsProperty<string> {\n    return this._properties.backgroundOpacity;\n  }\n\n  public get windowColor(): SubtitleSettingsProperty<string> {\n    return this._properties.windowColor;\n  }\n\n  public get windowOpacity(): SubtitleSettingsProperty<string> {\n    return this._properties.windowOpacity;\n  }\n\n  /**\n   * Saves the settings to local storage.\n   */\n  public save(): void {\n    StorageUtils.setObject(this.localStorageKey, this.userSettings);\n  }\n\n  /**\n   * Loads the settings from local storage\n   */\n  public load(): void {\n    this.userSettings = StorageUtils.getObject<SubtitleSettings>(this.localStorageKey) || {};\n\n    // Apply the loaded settings\n    for (let property in this.userSettings) {\n      this._properties[property].value = (<any>this.userSettings)[property];\n    }\n  }\n}\n\n/**\n * A dummy component whose sole purpose is to expose the {@link #prefixCss} method to the\n * {@link SubtitleSettingsManager}.\n */\nclass DummyComponent extends Component<ComponentConfig> {\n\n  private static _instance: DummyComponent;\n\n  public static instance(): DummyComponent {\n    if (!DummyComponent._instance) {\n      DummyComponent._instance = new DummyComponent();\n    }\n\n    return DummyComponent._instance;\n  }\n\n  public prefixCss(cssClassOrId: string): string {\n    return super.prefixCss(cssClassOrId);\n  }\n}\n\nexport class SubtitleSettingsProperty<T> {\n\n  private _manager: SubtitleSettingsManager;\n  private _onChanged: EventDispatcher<SubtitleSettingsManager, SubtitleSettingsProperty<T>>;\n  private _value: T;\n\n  constructor(manager: SubtitleSettingsManager) {\n    this._manager = manager;\n    this._onChanged = new EventDispatcher<SubtitleSettingsManager, SubtitleSettingsProperty<T>>();\n  }\n\n  public isSet(): boolean {\n    return this._value != null;\n  }\n\n  public clear(): void {\n    this._value = null;\n    this.onChangedEvent(null);\n  }\n\n  public get value(): T {\n    return this._value;\n  }\n\n  public set value(value: T) {\n    if (typeof value === 'string' && value === 'null') {\n      value = null;\n    }\n\n    this._value = value;\n    this.onChangedEvent(value);\n  }\n\n  protected onChangedEvent(value: T) {\n    this._onChanged.dispatch(this._manager, this);\n  }\n\n  public get onChanged(): Event<SubtitleSettingsManager, SubtitleSettingsProperty<T>> {\n    return this._onChanged.getEvent();\n  }\n}","import {SubtitleSettingsButton} from './subtitlesettingsbutton';\nimport {SubtitleSettingsButtonConfig} from './subtitlesettingsbutton';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A button that toggles the option menu for subtitles\n */\nexport class SubtitleSettingsOpenButton extends SubtitleSettingsButton {\n\n  constructor(config: SubtitleSettingsButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitlesettingsopenbutton',\n      text: 'Subtitles settings',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      this.subtitleSettingsPanel.show();\n      this.settingsPanel.hide();\n    });\n  }\n}\n\n","import {SettingsPanel, SettingsPanelConfig, SettingsPanelItem} from '../settingspanel';\nimport {FontColorSelectBox} from './fontcolorselectbox';\nimport {FontOpacitySelectBox} from './fontopacityselectbox';\nimport {FontFamilySelectBox} from './fontfamilyselectbox';\nimport {FontSizeSelectBox} from './fontsizeselectbox';\nimport {BackgroundColorSelectBox} from './backgroundcolorselectbox';\nimport {BackgroundOpacitySelectBox} from './backgroundopacityselectbox';\nimport {WindowColorSelectBox} from './windowcolorselectbox';\nimport {WindowOpacitySelectBox} from './windowopacityselectbox';\nimport {CharacterEdgeSelectBox} from './characteredgeselectbox';\nimport {SubtitleOverlay} from '../subtitleoverlay';\nimport {Component, ComponentConfig} from '../component';\nimport {UIInstanceManager} from '../../uimanager';\nimport {SubtitleSettingsManager} from './subtitlesettingsmanager';\nimport {SubtitleSettingsCloseButton} from './subtitlesettingsclosebutton';\nimport {SubtitleSettingsResetButton} from './subtitlesettingsresetbutton';\n\nexport interface SubtitleSettingsPanelConfig extends SettingsPanelConfig {\n  overlay: SubtitleOverlay;\n  settingsPanel: SettingsPanel;\n}\n\n/**\n * SubtitleSettingsPanel is a settings panel specific to subtitles settings\n **/\nexport class SubtitleSettingsPanel extends SettingsPanel {\n\n  private overlay: SubtitleOverlay;\n\n  constructor(config: SubtitleSettingsPanelConfig) {\n    super(config);\n\n    this.overlay = config.overlay;\n\n    let manager = new SubtitleSettingsManager();\n\n    this.config = this.mergeConfig(config, {\n      components: <Component<ComponentConfig>[]>[\n        new SettingsPanelItem('Font size', new FontSizeSelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Font family', new FontFamilySelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Font color', new FontColorSelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Font opacity', new FontOpacitySelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Character edge', new CharacterEdgeSelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Background color', new BackgroundColorSelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Background opacity', new BackgroundOpacitySelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Window color', new WindowColorSelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem('Window opacity', new WindowOpacitySelectBox({\n          overlay: this.overlay, settingsManager: manager,\n        })),\n        new SettingsPanelItem(new SubtitleSettingsCloseButton({\n          subtitleSettingsPanel: this, settingsPanel: config.settingsPanel,\n        }), new SubtitleSettingsResetButton({\n          settingsManager: manager,\n        })),\n      ],\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onShow.subscribe(() => {\n      this.overlay.enablePreviewSubtitleLabel();\n    });\n\n    this.onHide.subscribe(() => {\n      this.overlay.removePreviewSubtitleLabel();\n    });\n  }\n}\n","import {UIInstanceManager} from '../../uimanager';\nimport {SubtitleSettingsManager} from './subtitlesettingsmanager';\nimport {Button, ButtonConfig} from '../button';\n\nexport interface SubtitleSettingsResetButtonConfig extends ButtonConfig {\n  settingsManager: SubtitleSettingsManager;\n}\n\n/**\n * A button that resets all subtitle settings to their defaults.\n */\nexport class SubtitleSettingsResetButton extends Button<ButtonConfig> {\n\n  constructor(config: SubtitleSettingsResetButtonConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-subtitlesettingsresetbutton',\n      text: 'Reset',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.onClick.subscribe(() => {\n      (<SubtitleSettingsResetButtonConfig>this.config).settingsManager.reset();\n    });\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different background colors.\n */\nexport class WindowColorSelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('white', 'white');\n    this.addItem('black', 'black');\n    this.addItem('red', 'red');\n    this.addItem('green', 'green');\n    this.addItem('blue', 'blue');\n    this.addItem('cyan', 'cyan');\n    this.addItem('yellow', 'yellow');\n    this.addItem('magenta', 'magenta');\n\n    let setColorAndOpacity = () => {\n      if (this.settingsManager.windowColor.isSet() && this.settingsManager.windowOpacity.isSet()) {\n        this.toggleOverlayClass(\n          'windowcolor-' + this.settingsManager.windowColor.value + this.settingsManager.windowOpacity.value);\n      } else {\n        this.toggleOverlayClass(null);\n      }\n    };\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.windowColor.value = key;\n    });\n\n    this.settingsManager.windowColor.onChanged.subscribe((sender, property) => {\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.windowColor.isSet()) {\n        // ... clear the opacity when the color is not set\n        this.settingsManager.windowOpacity.clear();\n      } else if (!this.settingsManager.windowOpacity.isSet()) {\n        // ... set an opacity when the color is set\n        this.settingsManager.windowOpacity.value = '100';\n      }\n      this.selectItem(property.value);\n      setColorAndOpacity();\n    });\n\n    this.settingsManager.windowOpacity.onChanged.subscribe(() => {\n      setColorAndOpacity();\n    });\n\n    // Load initial value\n    if (this.settingsManager.windowColor.isSet()) {\n      this.selectItem(this.settingsManager.windowColor.value);\n    }\n  }\n}\n","import {SubtitleSettingSelectBox} from './subtitlesettingselectbox';\nimport {UIInstanceManager} from '../../uimanager';\n\n/**\n * A select box providing a selection of different background opacity.\n */\nexport class WindowOpacitySelectBox extends SubtitleSettingSelectBox {\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.addItem(null, 'default');\n    this.addItem('100', '100%');\n    this.addItem('75', '75%');\n    this.addItem('50', '50%');\n    this.addItem('25', '25%');\n    this.addItem('0', '0%');\n\n    this.onItemSelected.subscribe((sender, key: string) => {\n      this.settingsManager.windowOpacity.value = key;\n\n      // Color and opacity go together, so we need to...\n      if (!this.settingsManager.windowOpacity.isSet()) {\n        // ... clear the color when the opacity is not set\n        this.settingsManager.windowColor.clear();\n      } else if (!this.settingsManager.windowColor.isSet()) {\n        // ... set a color when the opacity is set\n        this.settingsManager.windowColor.value = 'black';\n      }\n    });\n\n    // Update selected item when value is set from somewhere else\n    this.settingsManager.windowOpacity.onChanged.subscribe((sender, property) => {\n      this.selectItem(property.value);\n    });\n\n    // Load initial value\n    if (this.settingsManager.windowOpacity.isSet()) {\n      this.selectItem(this.settingsManager.windowOpacity.value);\n    }\n  }\n}\n","import {Container, ContainerConfig} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {MetadataLabel, MetadataLabelContent} from './metadatalabel';\n\n/**\n * Configuration interface for a {@link TitleBar}.\n */\nexport interface TitleBarConfig extends ContainerConfig {\n  /**\n   * Specifies if the title bar should stay hidden when no metadata label contains any text. Does not make a lot\n   * of sense if the title bar contains other components than just MetadataLabels (like in the default configuration).\n   * Default: false\n   */\n  keepHiddenWithoutMetadata?: boolean;\n}\n\n/**\n * Displays a title bar containing a label with the title of the video.\n */\nexport class TitleBar extends Container<TitleBarConfig> {\n\n  constructor(config: TitleBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-titlebar',\n      hidden: true,\n      components: [\n        new MetadataLabel({ content: MetadataLabelContent.Title }),\n        new MetadataLabel({ content: MetadataLabelContent.Description }),\n      ],\n      keepHiddenWithoutMetadata: false,\n    }, <TitleBarConfig>this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let config = <TitleBarConfig>this.getConfig();\n    let shouldBeShown = !this.isHidden();\n    let hasMetadataText = true; // Flag to track if any metadata label contains text\n\n    let checkMetadataTextAndUpdateVisibility = () => {\n      hasMetadataText = false;\n\n      // Iterate through metadata labels and check if at least one of them contains text\n      for (let component of this.getComponents()) {\n        if (component instanceof MetadataLabel) {\n          if (!component.isEmpty()) {\n            hasMetadataText = true;\n            break;\n          }\n        }\n      }\n\n      if (this.isShown()) {\n        // Hide a visible titlebar if it does not contain any text and the hidden flag is set\n        if (config.keepHiddenWithoutMetadata && !hasMetadataText) {\n          this.hide();\n        }\n      } else if (shouldBeShown) {\n        // Show a hidden titlebar if it should actually be shown\n        this.show();\n      }\n    };\n\n    // Listen to text change events to update the hasMetadataText flag when the metadata dynamically changes\n    for (let component of this.getComponents()) {\n      if (component instanceof MetadataLabel) {\n        component.onTextChanged.subscribe(checkMetadataTextAndUpdateVisibility);\n      }\n    }\n\n    uimanager.onControlsShow.subscribe(() => {\n      shouldBeShown = true;\n      if (!(config.keepHiddenWithoutMetadata && !hasMetadataText)) {\n        this.show();\n      }\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      shouldBeShown = false;\n      this.hide();\n    });\n\n    // init\n    checkMetadataTextAndUpdateVisibility();\n  }\n}","import {Button, ButtonConfig} from './button';\nimport {NoArgs, EventDispatcher, Event} from '../eventdispatcher';\nimport { UIInstanceManager } from '../uimanager';\n\n/**\n * Configuration interface for a toggle button component.\n */\nexport interface ToggleButtonConfig extends ButtonConfig {\n  /**\n   * The CSS class that marks the on-state of the button.\n   */\n  onClass?: string;\n  /**\n   * The CSS class that marks the off-state of the button.\n   */\n  offClass?: string;\n  /**\n   * The text on the button.\n   */\n  text?: string;\n}\n\n/**\n * A button that can be toggled between 'on' and 'off' states.\n */\nexport class ToggleButton<Config extends ToggleButtonConfig> extends Button<ToggleButtonConfig> {\n\n  private onState: boolean;\n\n  private toggleButtonEvents = {\n    onToggle: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOn: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n    onToggleOff: new EventDispatcher<ToggleButton<Config>, NoArgs>(),\n  };\n\n  constructor(config: ToggleButtonConfig) {\n    super(config);\n\n    const defaultConfig: ToggleButtonConfig = {\n      cssClass: 'ui-togglebutton',\n      onClass: 'on',\n      offClass: 'off',\n    };\n\n    this.config = this.mergeConfig(config, defaultConfig, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    const config = this.getConfig() as ToggleButtonConfig;\n    this.getDomElement().addClass(this.prefixCss(config.offClass));\n  }\n\n  /**\n   * Toggles the button to the 'on' state.\n   */\n  on() {\n    if (this.isOff()) {\n      const config = this.getConfig() as ToggleButtonConfig;\n\n      this.onState = true;\n      this.getDomElement().removeClass(this.prefixCss(config.offClass));\n      this.getDomElement().addClass(this.prefixCss(config.onClass));\n\n      this.onToggleEvent();\n      this.onToggleOnEvent();\n    }\n  }\n\n  /**\n   * Toggles the button to the 'off' state.\n   */\n  off() {\n    if (this.isOn()) {\n      const config = this.getConfig() as ToggleButtonConfig;\n\n      this.onState = false;\n      this.getDomElement().removeClass(this.prefixCss(config.onClass));\n      this.getDomElement().addClass(this.prefixCss(config.offClass));\n\n      this.onToggleEvent();\n      this.onToggleOffEvent();\n    }\n  }\n\n  /**\n   * Toggle the button 'on' if it is 'off', or 'off' if it is 'on'.\n   */\n  toggle() {\n    if (this.isOn()) {\n      this.off();\n    } else {\n      this.on();\n    }\n  }\n\n  /**\n   * Checks if the toggle button is in the 'on' state.\n   * @returns {boolean} true if button is 'on', false if 'off'\n   */\n  isOn(): boolean {\n    return this.onState;\n  }\n\n  /**\n   * Checks if the toggle button is in the 'off' state.\n   * @returns {boolean} true if button is 'off', false if 'on'\n   */\n  isOff(): boolean {\n    return !this.isOn();\n  }\n\n  protected onClickEvent() {\n    super.onClickEvent();\n\n    // Fire the toggle event together with the click event\n    // (they are technically the same, only the semantics are different)\n    this.onToggleEvent();\n  }\n\n  protected onToggleEvent() {\n    this.toggleButtonEvents.onToggle.dispatch(this);\n  }\n\n  protected onToggleOnEvent() {\n    this.toggleButtonEvents.onToggleOn.dispatch(this);\n  }\n\n  protected onToggleOffEvent() {\n    this.toggleButtonEvents.onToggleOff.dispatch(this);\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggle(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggle.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'on'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOn(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOn.getEvent();\n  }\n\n  /**\n   * Gets the event that is fired when the button is toggled 'off'.\n   * @returns {Event<ToggleButton<Config>, NoArgs>}\n   */\n  get onToggleOff(): Event<ToggleButton<Config>, NoArgs> {\n    return this.toggleButtonEvents.onToggleOff.getEvent();\n  }\n}","import {Component, ComponentConfig} from './component';\nimport {DOM} from '../dom';\n\n/**\n * Animated analog TV static noise.\n */\nexport class TvNoiseCanvas extends Component<ComponentConfig> {\n\n  private canvas: DOM;\n\n  private canvasElement: HTMLCanvasElement;\n  private canvasContext: CanvasRenderingContext2D;\n  private canvasWidth = 160;\n  private canvasHeight = 90;\n  private interferenceHeight = 50;\n  private lastFrameUpdate: number = 0;\n  private frameInterval: number = 60;\n  private useAnimationFrame: boolean = !!window.requestAnimationFrame;\n  private noiseAnimationWindowPos: number;\n  private frameUpdateHandlerId: number;\n\n  constructor(config: ComponentConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-tvnoisecanvas',\n    }, this.config);\n  }\n\n  protected toDomElement(): DOM {\n    return this.canvas = new DOM('canvas', { 'class': this.getCssClasses() });\n  }\n\n  start(): void {\n    this.canvasElement = <HTMLCanvasElement>this.canvas.get(0);\n    this.canvasContext = this.canvasElement.getContext('2d');\n    this.noiseAnimationWindowPos = -this.canvasHeight;\n    this.lastFrameUpdate = 0;\n\n    this.canvasElement.width = this.canvasWidth;\n    this.canvasElement.height = this.canvasHeight;\n\n    this.renderFrame();\n  }\n\n  stop(): void {\n    if (this.useAnimationFrame) {\n      cancelAnimationFrame(this.frameUpdateHandlerId);\n    } else {\n      clearTimeout(this.frameUpdateHandlerId);\n    }\n  }\n\n  private renderFrame(): void {\n    // This code has been copied from the player controls.js and simplified\n\n    if (this.lastFrameUpdate + this.frameInterval > new Date().getTime()) {\n      // It's too early to render the next frame\n      this.scheduleNextRender();\n      return;\n    }\n\n    let currentPixelOffset;\n    let canvasWidth = this.canvasWidth;\n    let canvasHeight = this.canvasHeight;\n\n    // Create texture\n    let noiseImage = this.canvasContext.createImageData(canvasWidth, canvasHeight);\n\n    // Fill texture with noise\n    for (let y = 0; y < canvasHeight; y++) {\n      for (let x = 0; x < canvasWidth; x++) {\n        currentPixelOffset = (canvasWidth * y * 4) + x * 4;\n        noiseImage.data[currentPixelOffset] = Math.random() * 255;\n        if (y < this.noiseAnimationWindowPos || y > this.noiseAnimationWindowPos + this.interferenceHeight) {\n          noiseImage.data[currentPixelOffset] *= 0.85;\n        }\n        noiseImage.data[currentPixelOffset + 1] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 2] = noiseImage.data[currentPixelOffset];\n        noiseImage.data[currentPixelOffset + 3] = 50;\n      }\n    }\n\n    // Put texture onto canvas\n    this.canvasContext.putImageData(noiseImage, 0, 0);\n\n    this.lastFrameUpdate = new Date().getTime();\n    this.noiseAnimationWindowPos += 7;\n    if (this.noiseAnimationWindowPos > canvasHeight) {\n      this.noiseAnimationWindowPos = -canvasHeight;\n    }\n\n    this.scheduleNextRender();\n  }\n\n  private scheduleNextRender(): void {\n    if (this.useAnimationFrame) {\n      this.frameUpdateHandlerId = window.requestAnimationFrame(this.renderFrame.bind(this));\n    } else {\n      this.frameUpdateHandlerId = setTimeout(this.renderFrame.bind(this), this.frameInterval);\n    }\n  }\n}","import {ContainerConfig, Container} from './container';\nimport {UIInstanceManager} from '../uimanager';\nimport {DOM} from '../dom';\nimport {Timeout} from '../timeout';\nimport {PlayerUtils} from '../playerutils';\nimport PlayerResizeEvent = bitmovin.PlayerAPI.PlayerResizeEvent;\nimport {CancelEventArgs} from '../eventdispatcher';\n\n/**\n * Configuration interface for a {@link UIContainer}.\n */\nexport interface UIContainerConfig extends ContainerConfig {\n  /**\n   * The delay in milliseconds after which the control bar will be hidden when there is no user interaction.\n   * Set to -1 for the UI to be always shown.\n   * Default: 5 seconds (5000)\n   */\n  hideDelay?: number;\n}\n\n/**\n * The base container that contains all of the UI. The UIContainer is passed to the {@link UIManager} to build and\n * setup the UI.\n */\nexport class UIContainer extends Container<UIContainerConfig> {\n\n  private static readonly STATE_PREFIX = 'player-state-';\n\n  private static readonly FULLSCREEN = 'fullscreen';\n  private static readonly BUFFERING = 'buffering';\n  private static readonly REMOTE_CONTROL = 'remote-control';\n  private static readonly CONTROLS_SHOWN = 'controls-shown';\n  private static readonly CONTROLS_HIDDEN = 'controls-hidden';\n\n  private uiHideTimeout: Timeout;\n\n  constructor(config: UIContainerConfig) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <UIContainerConfig>{\n      cssClass: 'ui-uicontainer',\n      hideDelay: 5000,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    this.configureUIShowHide(player, uimanager);\n    this.configurePlayerStates(player, uimanager);\n  }\n\n  private configureUIShowHide(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n    let config = <UIContainerConfig>this.getConfig();\n\n    if (config.hideDelay === -1) {\n      uimanager.onConfigured.subscribe(() => uimanager.onControlsShow.dispatch(this));\n      return;\n    }\n\n    let isUiShown = false;\n    let isSeeking = false;\n    let isFirstTouch = true;\n\n    let showUi = () => {\n      if (!isUiShown) {\n        // Let subscribers know that they should reveal themselves\n        uimanager.onControlsShow.dispatch(this);\n        isUiShown = true;\n      }\n      // Don't trigger timeout while seeking (it will be triggered once the seek is finished) or casting\n      if (!isSeeking && !player.isCasting()) {\n        this.uiHideTimeout.start();\n      }\n    };\n\n    let hideUi = () => {\n      // Hide the UI only if it is shown, and if not casting\n      if (isUiShown && !player.isCasting()) {\n        // Issue a preview event to check if we are good to hide the controls\n        let previewHideEventArgs = <CancelEventArgs>{};\n        uimanager.onPreviewControlsHide.dispatch(this, previewHideEventArgs);\n\n        if (!previewHideEventArgs.cancel) {\n          // If the preview wasn't canceled, let subscribers know that they should now hide themselves\n          uimanager.onControlsHide.dispatch(this);\n          isUiShown = false;\n        } else {\n          // If the hide preview was canceled, continue to show UI\n          showUi();\n        }\n      }\n    };\n\n    // Timeout to defer UI hiding by the configured delay time\n    this.uiHideTimeout = new Timeout(config.hideDelay, hideUi);\n\n    // On touch displays, the first touch reveals the UI\n    container.on('touchend', (e) => {\n      if (!isUiShown) {\n        // Only if the UI is hidden, we prevent other actions (except for the first touch) and reveal the UI instead.\n        // The first touch is not prevented to let other listeners receive the event and trigger an initial action, e.g.\n        // the huge playback button can directly start playback instead of requiring a double tap which 1. reveals\n        // the UI and 2. starts playback.\n        if (isFirstTouch) {\n          isFirstTouch = false;\n        } else {\n          e.preventDefault();\n        }\n        showUi();\n      }\n    });\n    // When the mouse enters, we show the UI\n    container.on('mouseenter', () => {\n      showUi();\n    });\n    // When the mouse moves within, we show the UI\n    container.on('mousemove', () => {\n      showUi();\n    });\n    // When the mouse leaves, we can prepare to hide the UI, except a seek is going on\n    container.on('mouseleave', () => {\n      // When a seek is going on, the seek scrub pointer may exit the UI area while still seeking, and we do not hide\n      // the UI in such cases\n      if (!isSeeking) {\n        this.uiHideTimeout.start();\n      }\n    });\n\n    uimanager.onSeek.subscribe(() => {\n      this.uiHideTimeout.clear(); // Don't hide UI while a seek is in progress\n      isSeeking = true;\n    });\n    uimanager.onSeeked.subscribe(() => {\n      isSeeking = false;\n      this.uiHideTimeout.start(); // Re-enable UI hide timeout after a seek\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      showUi(); // Show UI when a Cast session has started (UI will then stay permanently on during the session)\n    });\n  }\n\n  private configurePlayerStates(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    let container = this.getDomElement();\n\n    // Convert player states into CSS class names\n    let stateClassNames = <any>[];\n    for (let state in PlayerUtils.PlayerState) {\n      if (isNaN(Number(state))) {\n        let enumName = PlayerUtils.PlayerState[<any>PlayerUtils.PlayerState[state]];\n        stateClassNames[PlayerUtils.PlayerState[state]] =\n          this.prefixCss(UIContainer.STATE_PREFIX + enumName.toLowerCase());\n      }\n    }\n\n    let removeStates = () => {\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n      container.removeClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    };\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PREPARED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAY, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PLAYING]);\n    });\n    player.addEventHandler(player.EVENT.ON_PAUSED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.PAUSED]);\n    });\n    player.addEventHandler(player.EVENT.ON_PLAYBACK_FINISHED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.FINISHED]);\n    });\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, () => {\n      removeStates();\n      container.addClass(stateClassNames[PlayerUtils.PlayerState.IDLE]);\n    });\n    // Init in current player state\n    container.addClass(stateClassNames[PlayerUtils.getState(player)]);\n\n    // Fullscreen marker class\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_ENTER, () => {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    player.addEventHandler(player.EVENT.ON_FULLSCREEN_EXIT, () => {\n      container.removeClass(this.prefixCss(UIContainer.FULLSCREEN));\n    });\n    // Init fullscreen state\n    if (player.isFullscreen()) {\n      container.addClass(this.prefixCss(UIContainer.FULLSCREEN));\n    }\n\n    // Buffering marker class\n    player.addEventHandler(player.EVENT.ON_STALL_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    player.addEventHandler(player.EVENT.ON_STALL_ENDED, () => {\n      container.removeClass(this.prefixCss(UIContainer.BUFFERING));\n    });\n    // Init buffering state\n    if (player.isStalled()) {\n      container.addClass(this.prefixCss(UIContainer.BUFFERING));\n    }\n\n    // RemoteControl marker class\n    player.addEventHandler(player.EVENT.ON_CAST_STARTED, () => {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    player.addEventHandler(player.EVENT.ON_CAST_STOPPED, () => {\n      container.removeClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    });\n    // Init RemoteControl state\n    if (player.isCasting()) {\n      container.addClass(this.prefixCss(UIContainer.REMOTE_CONTROL));\n    }\n\n    // Controls visibility marker class\n    uimanager.onControlsShow.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n    });\n    uimanager.onControlsHide.subscribe(() => {\n      container.removeClass(this.prefixCss(UIContainer.CONTROLS_SHOWN));\n      container.addClass(this.prefixCss(UIContainer.CONTROLS_HIDDEN));\n    });\n\n    // Layout size classes\n    let updateLayoutSizeClasses = (width: number, height: number) => {\n      container.removeClass(this.prefixCss('layout-max-width-400'));\n      container.removeClass(this.prefixCss('layout-max-width-600'));\n      container.removeClass(this.prefixCss('layout-max-width-800'));\n      container.removeClass(this.prefixCss('layout-max-width-1200'));\n\n      if (width <= 400) {\n        container.addClass(this.prefixCss('layout-max-width-400'));\n      } else if (width <= 600) {\n        container.addClass(this.prefixCss('layout-max-width-600'));\n      } else if (width <= 800) {\n        container.addClass(this.prefixCss('layout-max-width-800'));\n      } else if (width <= 1200) {\n        container.addClass(this.prefixCss('layout-max-width-1200'));\n      }\n    };\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, (e: PlayerResizeEvent) => {\n      // Convert strings (with \"px\" suffix) to ints\n      let width = Math.round(Number(e.width.substring(0, e.width.length - 2)));\n      let height = Math.round(Number(e.height.substring(0, e.height.length - 2)));\n\n      updateLayoutSizeClasses(width, height);\n    });\n    // Init layout state\n    updateLayoutSizeClasses(new DOM(player.getFigure()).width(), new DOM(player.getFigure()).height());\n  }\n\n  release(): void {\n    super.release();\n    this.uiHideTimeout.clear();\n  }\n\n  protected toDomElement(): DOM {\n    let container = super.toDomElement();\n\n    // Detect flexbox support (not supported in IE9)\n    if (document && typeof document.createElement('p').style.flex !== 'undefined') {\n      container.addClass(this.prefixCss('flexbox'));\n    } else {\n      container.addClass(this.prefixCss('no-flexbox'));\n    }\n\n    return container;\n  }\n}\n","import {SelectBox} from './selectbox';\nimport {ListSelectorConfig} from './listselector';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A select box providing a selection between 'auto' and the available video qualities.\n */\nexport class VideoQualitySelectBox extends SelectBox {\n\n  private hasAuto: boolean;\n\n  constructor(config: ListSelectorConfig = {}) {\n    super(config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let selectCurrentVideoQuality = () => {\n      if (player.getVideoQuality) {\n        // Since player 7.3.1\n        this.selectItem(player.getVideoQuality().id);\n      } else {\n        // Backwards compatibility for players <= 7.3.0\n        // TODO remove in next major release\n        let data = player.getDownloadedVideoData();\n        this.selectItem(data.isAuto ? 'auto' : data.id);\n      }\n    };\n\n    let updateVideoQualities = () => {\n      let videoQualities = player.getAvailableVideoQualities();\n\n      this.clearItems();\n\n      // Progressive streams do not support automatic quality selection\n      this.hasAuto = player.getStreamType() !== 'progressive';\n\n      if (this.hasAuto) {\n        // Add entry for automatic quality switching (default setting)\n        this.addItem('auto', 'auto');\n      }\n\n      // Add video qualities\n      for (let videoQuality of videoQualities) {\n        this.addItem(videoQuality.id, videoQuality.label);\n      }\n\n      // Select initial quality\n      selectCurrentVideoQuality();\n    };\n\n    this.onItemSelected.subscribe((sender: VideoQualitySelectBox, value: string) => {\n      player.setVideoQuality(value);\n    });\n\n    // Update qualities when source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, updateVideoQualities);\n    // Update qualities when a new source is loaded\n    player.addEventHandler(player.EVENT.ON_READY, updateVideoQualities);\n    // Update qualities when the period within a source changes\n    player.addEventHandler(player.EVENT.ON_PERIOD_SWITCHED, updateVideoQualities);\n    // Update quality selection when quality is changed (from outside)\n    if (player.EVENT.ON_VIDEO_QUALITY_CHANGED) {\n      // Since player 7.3.1\n      player.addEventHandler(player.EVENT.ON_VIDEO_QUALITY_CHANGED, selectCurrentVideoQuality);\n    } else {\n      // Backwards compatibility for players <= 7.3.0\n      // TODO remove in next major release\n      player.addEventHandler(player.EVENT.ON_VIDEO_DOWNLOAD_QUALITY_CHANGE, selectCurrentVideoQuality);\n    }\n  }\n\n  /**\n   * Returns true if the select box contains an 'auto' item for automatic quality selection mode.\n   * @return {boolean}\n   */\n  hasAutoItem(): boolean {\n    return this.hasAuto;\n  }\n}","import {Container, ContainerConfig} from './container';\nimport {VolumeSlider} from './volumeslider';\nimport {VolumeToggleButton} from './volumetogglebutton';\nimport {UIInstanceManager} from '../uimanager';\nimport {Timeout} from '../timeout';\n\n/**\n * Configuration interface for a {@link VolumeControlButton}.\n */\nexport interface VolumeControlButtonConfig extends ContainerConfig {\n  /**\n   * The delay after which the volume slider will be hidden when there is no user interaction.\n   * Care must be taken that the delay is long enough so users can reach the slider from the toggle button, e.g. by\n   * mouse movement. If the delay is too short, the sliders disappears before the mouse pointer has reached it and\n   * the user is not able to use it.\n   * Default: 500ms\n   */\n  hideDelay?: number;\n  /**\n   * Specifies if the volume slider should be vertically or horizontally aligned.\n   * Default: true\n   */\n  vertical?: boolean;\n}\n\n/**\n * A composite volume control that consists of and internally manages a volume control button that can be used\n * for muting, and a (depending on the CSS style, e.g. slide-out) volume control bar.\n */\nexport class VolumeControlButton extends Container<VolumeControlButtonConfig> {\n\n  private volumeToggleButton: VolumeToggleButton;\n  private volumeSlider: VolumeSlider;\n\n  private volumeSliderHideTimeout: Timeout;\n\n  constructor(config: VolumeControlButtonConfig = {}) {\n    super(config);\n\n    this.volumeToggleButton = new VolumeToggleButton();\n    this.volumeSlider = new VolumeSlider({\n      vertical: config.vertical != null ? config.vertical : true,\n      hidden: true,\n    });\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-volumecontrolbutton',\n      components: [this.volumeToggleButton, this.volumeSlider],\n      hideDelay: 500,\n    }, <VolumeControlButtonConfig>this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let volumeToggleButton = this.getVolumeToggleButton();\n    let volumeSlider = this.getVolumeSlider();\n\n    this.volumeSliderHideTimeout = new Timeout((<VolumeControlButtonConfig>this.getConfig()).hideDelay, () => {\n      volumeSlider.hide();\n    });\n\n    /*\n     * Volume Slider visibility handling\n     *\n     * The volume slider shall be visible while the user hovers the mute toggle button, while the user hovers the\n     * volume slider, and while the user slides the volume slider. If none of these situations are true, the slider\n     * shall disappear.\n     */\n    let volumeSliderHovered = false;\n    volumeToggleButton.getDomElement().on('mouseenter', () => {\n      // Show volume slider when mouse enters the button area\n      if (volumeSlider.isHidden()) {\n        volumeSlider.show();\n      }\n      // Avoid hiding of the slider when button is hovered\n      this.volumeSliderHideTimeout.clear();\n    });\n    volumeToggleButton.getDomElement().on('mouseleave', () => {\n      // Hide slider delayed when button is left\n      this.volumeSliderHideTimeout.reset();\n    });\n    volumeSlider.getDomElement().on('mouseenter', () => {\n      // When the slider is entered, cancel the hide timeout activated by leaving the button\n      this.volumeSliderHideTimeout.clear();\n      volumeSliderHovered = true;\n    });\n    volumeSlider.getDomElement().on('mouseleave', () => {\n      // When mouse leaves the slider, only hide it if there is no slide operation in progress\n      if (volumeSlider.isSeeking()) {\n        this.volumeSliderHideTimeout.clear();\n      } else {\n        this.volumeSliderHideTimeout.reset();\n      }\n      volumeSliderHovered = false;\n    });\n    volumeSlider.onSeeked.subscribe(() => {\n      // When a slide operation is done and the slider not hovered (mouse outside slider), hide slider delayed\n      if (!volumeSliderHovered) {\n        this.volumeSliderHideTimeout.reset();\n      }\n    });\n  }\n\n  release(): void {\n    super.release();\n    this.volumeSliderHideTimeout.clear();\n  }\n\n  /**\n   * Provides access to the internally managed volume toggle button.\n   * @returns {VolumeToggleButton}\n   */\n  getVolumeToggleButton(): VolumeToggleButton {\n    return this.volumeToggleButton;\n  }\n\n  /**\n   * Provides access to the internally managed volume silder.\n   * @returns {VolumeSlider}\n   */\n  getVolumeSlider(): VolumeSlider {\n    return this.volumeSlider;\n  }\n}","import {SeekBar, SeekBarConfig} from './seekbar';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * Configuration interface for the {@link VolumeSlider} component.\n */\nexport interface VolumeSliderConfig extends SeekBarConfig {\n  /**\n   * Specifies if the volume slider should be automatically hidden when volume control is prohibited by the\n   * browser or platform. This currently only applies to iOS.\n   * Default: true\n   */\n  hideIfVolumeControlProhibited: boolean;\n}\n\n/**\n * A simple volume slider component to adjust the player's volume setting.\n */\nexport class VolumeSlider extends SeekBar {\n\n  private static readonly issuerName = 'ui';\n\n  constructor(config: SeekBarConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, <VolumeSliderConfig>{\n      cssClass: 'ui-volumeslider',\n      hideIfVolumeControlProhibited: true,\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager, false);\n\n    let config = <VolumeSliderConfig>this.getConfig();\n\n    if (config.hideIfVolumeControlProhibited && !this.detectVolumeControlAvailability()) {\n      this.hide();\n\n      // We can just return from here, because the user will never interact with the control and any configured\n      // functionality would only eat resources for no reason.\n      return;\n    }\n\n    let volumeChangeHandler = () => {\n      if (player.isMuted()) {\n        this.setPlaybackPosition(0);\n      } else {\n        this.setPlaybackPosition(player.getVolume());\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_READY, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_MUTED, volumeChangeHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, volumeChangeHandler);\n\n    this.onSeekPreview.subscribeRateLimited((sender, args) => {\n      if (args.scrubbing) {\n        player.setVolume(args.position, VolumeSlider.issuerName);\n      }\n    }, 50);\n    this.onSeeked.subscribe((sender, percentage) => {\n      player.setVolume(percentage, VolumeSlider.issuerName);\n    });\n\n    // Update the volume slider marker when the player resized, a source is loaded and player is ready,\n    // or the UI is configured. Check the seekbar for a detailed description.\n    player.addEventHandler(player.EVENT.ON_PLAYER_RESIZE, () => {\n      this.refreshPlaybackPosition();\n    });\n    player.addEventHandler(player.EVENT.ON_READY, () => {\n      this.refreshPlaybackPosition();\n    });\n    uimanager.onConfigured.subscribe(() => {\n      this.refreshPlaybackPosition();\n    });\n\n    // Init volume bar\n    volumeChangeHandler();\n  }\n\n  private detectVolumeControlAvailability(): boolean {\n    /*\n     * \"On iOS devices, the audio level is always under the user’s physical control. The volume property is not\n     * settable in JavaScript. Reading the volume property always returns 1.\"\n     * https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/Using_HTML5_Audio_Video/Device-SpecificConsiderations/Device-SpecificConsiderations.html\n     */\n    // as muted autoplay gets paused as soon as we unmute it, we may not touch the volume of the actual player so we\n    // probe a dummy audio element\n    const dummyVideoElement = document.createElement('video');\n    // try setting the volume to 0.7 and if it's still 1 we are on a volume control restricted device\n    dummyVideoElement.volume = 0.7;\n    return dummyVideoElement.volume !== 1;\n  }\n}\n","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles audio muting.\n */\nexport class VolumeToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    const defaultConfig: ToggleButtonConfig = {\n      cssClass: 'ui-volumetogglebutton',\n      text: 'Volume/Mute',\n      onClass: 'muted',\n      offClass: 'unmuted',\n    };\n\n    this.config = this.mergeConfig(config, defaultConfig, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let muteStateHandler = () => {\n      if (player.isMuted()) {\n        this.on();\n\n        // When the volume is unmuted and the volume level is veeeery low, we increase it to 10%. This especially helps\n        // in the case when the volume is first turned down to 0 and then the player is muted; when the player gets\n        // unmuted it would switch to volume level 0 which would seem like unmuting did not work, and increasing the\n        // level a bit helps to overcome this issue.\n        if (player.getVolume() < 10) {\n          player.setVolume(10);\n        }\n      } else {\n        this.off();\n      }\n    };\n\n    let volumeLevelHandler = () => {\n      const volumeLevelTens = Math.ceil(player.getVolume() / 10);\n      this.getDomElement().data(this.prefixCss('volume-level-tens'), String(volumeLevelTens));\n\n      // When the volume is turned down to zero, switch into the mute state of the button. This avoids the usability\n      // issue where the volume is turned down to zero, the button shows the muted icon but is not really unmuted, and\n      // the next button press would switch it into the mute state, visually staying the same which would seem like\n      // an expected unmute did not work.\n      if (volumeLevelTens === 0) {\n        this.off();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_MUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_UNMUTED, muteStateHandler);\n    player.addEventHandler(player.EVENT.ON_VOLUME_CHANGED, volumeLevelHandler);\n\n    this.onClick.subscribe(() => {\n      if (player.isMuted()) {\n        player.unmute('ui-volumetogglebutton');\n      } else {\n        player.mute('ui-volumetogglebutton');\n      }\n    });\n\n    // Startup init\n    muteStateHandler();\n    volumeLevelHandler();\n  }\n}","import {ToggleButton, ToggleButtonConfig} from './togglebutton';\nimport {UIInstanceManager} from '../uimanager';\n\n/**\n * A button that toggles the video view between normal/mono and VR/stereo.\n */\nexport class VRToggleButton extends ToggleButton<ToggleButtonConfig> {\n\n  constructor(config: ToggleButtonConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-vrtogglebutton',\n      text: 'VR',\n    }, this.config);\n  }\n\n  configure(player: bitmovin.PlayerAPI, uimanager: UIInstanceManager): void {\n    super.configure(player, uimanager);\n\n    let isVRConfigured = () => {\n      // VR availability cannot be checked through getVRStatus() because it is asynchronously populated and not\n      // available at UI initialization. As an alternative, we check the VR settings in the config.\n      // TODO use getVRStatus() through isVRStereoAvailable() once the player has been rewritten and the status is\n      // available in ON_READY\n      let config = player.getConfig();\n      return config.source && config.source.vr && config.source.vr.contentType !== 'none';\n    };\n\n    let isVRStereoAvailable = () => {\n      return player.getVRStatus().contentType !== 'none';\n    };\n\n    let vrStateHandler = () => {\n      if (isVRConfigured() && isVRStereoAvailable()) {\n        this.show(); // show button in case it is hidden\n\n        if (player.getVRStatus().isStereo) {\n          this.on();\n        } else {\n          this.off();\n        }\n      } else {\n        this.hide(); // hide button if no stereo mode available\n      }\n    };\n\n    let vrButtonVisibilityHandler = () => {\n      if (isVRConfigured()) {\n        this.show();\n      } else {\n        this.hide();\n      }\n    };\n\n    player.addEventHandler(player.EVENT.ON_VR_MODE_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_STEREO_CHANGED, vrStateHandler);\n    player.addEventHandler(player.EVENT.ON_VR_ERROR, vrStateHandler);\n    // Hide button when VR source goes away\n    player.addEventHandler(player.EVENT.ON_SOURCE_UNLOADED, vrButtonVisibilityHandler);\n    // Show button when a new source is loaded and it's VR\n    player.addEventHandler(player.EVENT.ON_READY, vrButtonVisibilityHandler);\n\n    this.onClick.subscribe(() => {\n      if (!isVRStereoAvailable()) {\n        if (console) {\n          console.log('No VR content');\n        }\n      } else {\n        if (player.getVRStatus().isStereo) {\n          player.setVRStereo(false);\n        } else {\n          player.setVRStereo(true);\n        }\n      }\n    });\n\n    // Set startup visibility\n    vrButtonVisibilityHandler();\n  }\n}","import {ClickOverlay, ClickOverlayConfig} from './clickoverlay';\n\n/**\n * Configuration interface for a {@link ClickOverlay}.\n */\nexport interface WatermarkConfig extends ClickOverlayConfig {\n  // nothing yet\n}\n\n/**\n * A watermark overlay with a clickable logo.\n */\nexport class Watermark extends ClickOverlay {\n\n  constructor(config: WatermarkConfig = {}) {\n    super(config);\n\n    this.config = this.mergeConfig(config, {\n      cssClass: 'ui-watermark',\n      url: 'http://bitmovin.com',\n    }, <WatermarkConfig>this.config);\n  }\n}","export interface Offset {\n  left: number;\n  top: number;\n}\n\n/**\n * Simple DOM manipulation and DOM element event handling modeled after jQuery (as replacement for jQuery).\n *\n * Like jQuery, DOM operates on single elements and lists of elements. For example: creating an element returns a DOM\n * instance with a single element, selecting elements returns a DOM instance with zero, one, or many elements. Similar\n * to jQuery, setters usually affect all elements, while getters operate on only the first element.\n * Also similar to jQuery, most methods (except getters) return the DOM instance facilitating easy chaining of method\n * calls.\n *\n * Built with the help of: http://youmightnotneedjquery.com/\n */\nexport class DOM {\n\n  private document: Document;\n\n  /**\n   * The list of elements that the instance wraps. Take care that not all methods can operate on the whole list,\n   * getters usually just work on the first element.\n   */\n  private elements: HTMLElement[];\n\n  /**\n   * Creates a DOM element.\n   * @param tagName the tag name of the DOM element\n   * @param attributes a list of attributes of the element\n   */\n  constructor(tagName: string, attributes: {[name: string]: string});\n  /**\n   * Selects all elements from the DOM that match the specified selector.\n   * @param selector the selector to match DOM elements with\n   */\n  constructor(selector: string);\n  /**\n   * Wraps a plain HTMLElement with a DOM instance.\n   * @param element the HTMLElement to wrap with DOM\n   */\n  constructor(element: HTMLElement);\n  /**\n   * Wraps a list of plain HTMLElements with a DOM instance.\n   * @param elements the HTMLElements to wrap with DOM\n   */\n  constructor(elements: HTMLElement[]);\n  /**\n   * Wraps the document with a DOM instance. Useful to attach event listeners to the document.\n   * @param document the document to wrap\n   */\n  constructor(document: Document);\n  constructor(something: string | HTMLElement | HTMLElement[] | Document, attributes?: {[name: string]: string}) {\n    this.document = document; // Set the global document to the local document field\n\n    if (something instanceof Array) {\n      if (something.length > 0 && something[0] instanceof HTMLElement) {\n        let elements = something;\n        this.elements = elements;\n      }\n    }\n    else if (something instanceof HTMLElement) {\n      let element = something;\n      this.elements = [element];\n    }\n    else if (something instanceof Document) {\n      // When a document is passed in, we do not do anything with it, but by setting this.elements to null\n      // we give the event handling method a means to detect if the events should be registered on the document\n      // instead of elements.\n      this.elements = null;\n    }\n    else if (attributes) {\n      let tagName = something;\n      let element = document.createElement(tagName);\n\n      for (let attributeName in attributes) {\n        let attributeValue = attributes[attributeName];\n        element.setAttribute(attributeName, attributeValue);\n      }\n\n      this.elements = [element];\n    }\n    else {\n      let selector = something;\n      this.elements = this.findChildElements(selector);\n    }\n  }\n\n  /**\n   * Gets the number of elements that this DOM instance currently holds.\n   * @returns {number} the number of elements\n   */\n  get length(): number {\n    return this.elements ? this.elements.length : 0;\n  }\n\n  /**\n   * Gets the HTML elements that this DOM instance currently holds.\n   * @returns {HTMLElement[]} the raw HTML elements\n   * @deprecated use {@link #get()} instead\n   */\n  getElements(): HTMLElement[] {\n    return this.get();\n  }\n\n  /**\n   * Gets the HTML elements that this DOM instance currently holds.\n   * @returns {HTMLElement[]} the raw HTML elements\n   */\n  get(): HTMLElement[];\n  /**\n   * Gets an HTML element from the list elements that this DOM instance currently holds.\n   * @param index The zero-based index into the element list. Can be negative to return an element from the end,\n   *    e.g. -1 returns the last element.\n   */\n  get(index: number): HTMLElement;\n  get(index?: number): HTMLElement | HTMLElement[] {\n    if (index === undefined) {\n      return this.elements;\n    } else if (!this.elements || index >= this.elements.length || index < -this.elements.length) {\n      return undefined;\n    } else if (index < 0) {\n      return this.elements[this.elements.length - index];\n    } else {\n      return this.elements[index];\n    }\n  }\n\n  /**\n   * A shortcut method for iterating all elements. Shorts this.elements.forEach(...) to this.forEach(...).\n   * @param handler the handler to execute an operation on an element\n   */\n  private forEach(handler: (element: HTMLElement) => void): void {\n    if (!this.elements) {\n      return;\n    }\n    this.elements.forEach((element) => {\n      handler(element);\n    });\n  }\n\n  private findChildElementsOfElement(element: HTMLElement | Document, selector: string): HTMLElement[] {\n    let childElements = element.querySelectorAll(selector);\n\n    // Convert NodeList to Array\n    // https://toddmotto.com/a-comprehensive-dive-into-nodelists-arrays-converting-nodelists-and-understanding-the-dom/\n    return [].slice.call(childElements);\n  }\n\n  private findChildElements(selector: string): HTMLElement[] {\n    let allChildElements = <HTMLElement[]>[];\n\n    if (this.elements) {\n      this.forEach((element) => {\n        allChildElements = allChildElements.concat(this.findChildElementsOfElement(element, selector));\n      });\n    }\n    else {\n      return this.findChildElementsOfElement(document, selector);\n    }\n\n    return allChildElements;\n  }\n\n  /**\n   * Finds all child elements of all elements matching the supplied selector.\n   * @param selector the selector to match with child elements\n   * @returns {DOM} a new DOM instance representing all matched children\n   */\n  find(selector: string): DOM {\n    let allChildElements = this.findChildElements(selector);\n    return new DOM(allChildElements);\n  }\n\n  /**\n   * Returns a string of the inner HTML content of the first element.\n   */\n  html(): string;\n  /**\n   * Sets the inner HTML content of all elements.\n   * @param content a string of plain text or HTML markup\n   */\n  html(content: string): DOM;\n  html(content?: string): string | DOM {\n    if (arguments.length > 0) {\n      return this.setHtml(content);\n    }\n    else {\n      return this.getHtml();\n    }\n  }\n\n  private getHtml(): string | null {\n    return this.elements[0].innerHTML;\n  }\n\n  private setHtml(content: string): DOM {\n    if (content === undefined || content == null) {\n      // Set to empty string to avoid innerHTML getting set to 'undefined' (all browsers) or 'null' (IE9)\n      content = '';\n    }\n\n    this.forEach((element) => {\n      element.innerHTML = content;\n    });\n\n    return this;\n  }\n\n  /**\n   * Clears the inner HTML of all elements (deletes all children).\n   * @returns {DOM}\n   */\n  empty(): DOM {\n    this.forEach((element) => {\n      element.innerHTML = '';\n    });\n    return this;\n  }\n\n  /**\n   * Returns the current value of the first form element, e.g. the selected value of a select box or the text if an\n   * input field.\n   * @returns {string} the value of a form element\n   */\n  val(): string {\n    let element = this.elements[0];\n\n    if (element instanceof HTMLSelectElement || element instanceof HTMLInputElement) {\n      return element.value;\n    }\n    else {\n      // TODO add support for missing form elements\n      throw new Error(`val() not supported for ${typeof element}`);\n    }\n  }\n\n  /**\n   * Returns the value of an attribute on the first element.\n   * @param attribute\n   */\n  attr(attribute: string): string | null;\n  /**\n   * Sets an attribute on all elements.\n   * @param attribute the name of the attribute\n   * @param value the value of the attribute\n   */\n  attr(attribute: string, value: string): DOM;\n  attr(attribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setAttr(attribute, value);\n    }\n    else {\n      return this.getAttr(attribute);\n    }\n  }\n\n  private getAttr(attribute: string): string | null {\n    return this.elements[0].getAttribute(attribute);\n  }\n\n  private setAttr(attribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute(attribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Returns the value of a data element on the first element.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   */\n  data(dataAttribute: string): string | null;\n  /**\n   * Sets a data attribute on all elements.\n   * @param dataAttribute the name of the data attribute without the 'data-' prefix\n   * @param value the value of the data attribute\n   */\n  data(dataAttribute: string, value: string): DOM;\n  data(dataAttribute: string, value?: string): string | null | DOM {\n    if (arguments.length > 1) {\n      return this.setData(dataAttribute, value);\n    }\n    else {\n      return this.getData(dataAttribute);\n    }\n  }\n\n  private getData(dataAttribute: string): string | null {\n    return this.elements[0].getAttribute('data-' + dataAttribute);\n  }\n\n  private setData(dataAttribute: string, value: string): DOM {\n    this.forEach((element) => {\n      element.setAttribute('data-' + dataAttribute, value);\n    });\n    return this;\n  }\n\n  /**\n   * Appends one or more DOM elements as children to all elements.\n   * @param childElements the chrild elements to append\n   * @returns {DOM}\n   */\n  append(...childElements: DOM[]): DOM {\n    this.forEach((element) => {\n      childElements.forEach((childElement) => {\n        childElement.elements.forEach((_, index) => {\n          element.appendChild(childElement.elements[index]);\n        });\n      });\n    });\n    return this;\n  }\n\n  /**\n   * Removes all elements from the DOM.\n   */\n  remove(): void {\n    this.forEach((element) => {\n      let parent = element.parentNode;\n      if (parent) {\n        parent.removeChild(element);\n      }\n    });\n  }\n\n  /**\n   * Returns the offset of the first element from the document's top left corner.\n   * @returns {Offset}\n   */\n  offset(): Offset {\n    let element = this.elements[0];\n    let elementRect = element.getBoundingClientRect();\n    let htmlRect = document.body.parentElement.getBoundingClientRect();\n\n    // Virtual viewport scroll handling (e.g. pinch zoomed viewports in mobile browsers or desktop Chrome/Edge)\n    // 'normal' zooms and virtual viewport zooms (aka layout viewport) result in different\n    // element.getBoundingClientRect() results:\n    //  - with normal scrolls, the clientRect decreases with an increase in scroll(Top|Left)/page(X|Y)Offset\n    //  - with pinch zoom scrolls, the clientRect stays the same while scroll/pageOffset changes\n    // This means, that the combination of clientRect + scroll/pageOffset does not work to calculate the offset\n    // from the document's upper left origin when pinch zoom is used.\n    // To work around this issue, we do not use scroll/pageOffset but get the clientRect of the html element and\n    // subtract it from the element's rect, which always results in the offset from the document origin.\n    // NOTE: the current way of offset calculation was implemented specifically to track event positions on the\n    // seek bar, and it might break compatibility with jQuery's offset() method. If this ever turns out to be a\n    // problem, this method should be reverted to the old version and the offset calculation moved to the seek bar.\n\n    return {\n      top: elementRect.top - htmlRect.top,\n      left: elementRect.left - htmlRect.left,\n    };\n  }\n\n  /**\n   * Returns the width of the first element.\n   * @returns {number} the width of the first element\n   */\n  width(): number {\n    // TODO check if this is the same as jQuery's width() (probably not)\n    return this.elements[0].offsetWidth;\n  }\n\n  /**\n   * Returns the height of the first element.\n   * @returns {number} the height of the first element\n   */\n  height(): number {\n    // TODO check if this is the same as jQuery's height() (probably not)\n    return this.elements[0].offsetHeight;\n  }\n\n  /**\n   * Attaches an event handler to one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to listen to\n   * @param eventHandler the event handler to call when the event fires\n   * @returns {DOM}\n   */\n  on(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.addEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.addEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removes an event handler from one or more events on all elements.\n   * @param eventName the event name (or multiple names separated by space) to remove the handler from\n   * @param eventHandler the event handler to remove\n   * @returns {DOM}\n   */\n  off(eventName: string, eventHandler: EventListenerOrEventListenerObject): DOM {\n    let events = eventName.split(' ');\n\n    events.forEach((event) => {\n      if (this.elements == null) {\n        this.document.removeEventListener(event, eventHandler);\n      }\n      else {\n        this.forEach((element) => {\n          element.removeEventListener(event, eventHandler);\n        });\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Adds the specified class(es) to all elements.\n   * @param className the class(es) to add, multiple classes separated by space\n   * @returns {DOM}\n   */\n  addClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        const classNames = className.split(' ')\n          .filter(className => className.length > 0);\n\n        if (classNames.length > 0) {\n          element.classList.add(...classNames);\n        }\n      }\n      else {\n        element.className += ' ' + className;\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Removed the specified class(es) from all elements.\n   * @param className the class(es) to remove, multiple classes separated by space\n   * @returns {DOM}\n   */\n  removeClass(className: string): DOM {\n    this.forEach((element) => {\n      if (element.classList) {\n        const classNames = className.split(' ')\n          .filter(className => className.length > 0);\n\n        if (classNames.length > 0) {\n          element.classList.remove(...classNames);\n        }\n      }\n      else {\n        element.className = element.className.replace(\n          new RegExp('(^|\\\\b)' + className.split(' ').join('|') + '(\\\\b|$)', 'gi'), ' ');\n      }\n    });\n\n    return this;\n  }\n\n  /**\n   * Checks if any of the elements has the specified class.\n   * @param className the class name to check\n   * @returns {boolean} true if one of the elements has the class attached, else if no element has it attached\n   */\n  hasClass(className: string): boolean {\n    let hasClass = false;\n\n    this.forEach((element) => {\n      if (element.classList) {\n        if (element.classList.contains(className)) {\n          // Since we are inside a handler, we can't just 'return true'. Instead, we save it to a variable\n          // and return it at the end of the function body.\n          hasClass = true;\n        }\n      }\n      else {\n        if (new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className)) {\n          // See comment above\n          hasClass = true;\n        }\n      }\n    });\n\n    return hasClass;\n  }\n\n  /**\n   * Returns the value of a CSS property of the first element.\n   * @param propertyName the name of the CSS property to retrieve the value of\n   */\n  css(propertyName: string): string | null;\n  /**\n   * Sets the value of a CSS property on all elements.\n   * @param propertyName the name of the CSS property to set the value for\n   * @param value the value to set for the given CSS property\n   */\n  css(propertyName: string, value: string): DOM;\n  /**\n   * Sets a collection of CSS properties and their values on all elements.\n   * @param propertyValueCollection an object containing pairs of property names and their values\n   */\n  css(propertyValueCollection: {[propertyName: string]: string}): DOM;\n  css(propertyNameOrCollection: string | {[propertyName: string]: string}, value?: string): string | null | DOM {\n    if (typeof propertyNameOrCollection === 'string') {\n      let propertyName = propertyNameOrCollection;\n\n      if (arguments.length === 2) {\n        return this.setCss(propertyName, value);\n      }\n      else {\n        return this.getCss(propertyName);\n      }\n    }\n    else {\n      let propertyValueCollection = propertyNameOrCollection;\n      return this.setCssCollection(propertyValueCollection);\n    }\n  }\n\n  private getCss(propertyName: string): string | null {\n    return getComputedStyle(this.elements[0])[<any>propertyName];\n  }\n\n  private setCss(propertyName: string, value: string): DOM {\n    this.forEach((element) => {\n      // <any> cast to resolve TS7015: http://stackoverflow.com/a/36627114/370252\n      element.style[<any>propertyName] = value;\n    });\n    return this;\n  }\n\n  private setCssCollection(ruleValueCollection: {[ruleName: string]: string}): DOM {\n    this.forEach((element) => {\n      // http://stackoverflow.com/a/34490573/370252\n      Object.assign(element.style, ruleValueCollection);\n    });\n\n    return this;\n  }\n}\n","import {ArrayUtils} from './arrayutils';\n/**\n * Function interface for event listeners on the {@link EventDispatcher}.\n */\nexport interface EventListener<Sender, Args> {\n  (sender: Sender, args: Args): void;\n}\n\n/**\n * Empty type for creating {@link EventDispatcher event dispatchers} that do not carry any arguments.\n */\nexport interface NoArgs {\n}\n\n/**\n * Event args for an event that can be canceled.\n */\nexport interface CancelEventArgs extends NoArgs {\n  /**\n   * Gets or sets a flag whether the event should be canceled.\n   */\n  cancel?: boolean;\n}\n\n/**\n * Public interface that represents an event. Can be used to subscribe to and unsubscribe from events.\n */\nexport interface Event<Sender, Args> {\n  /**\n   * Subscribes an event listener to this event dispatcher.\n   * @param listener the listener to add\n   */\n  subscribe(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that is only called once.\n   * @param listener the listener to add\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>): void;\n\n  /**\n   * Subscribes an event listener to this event dispatcher that will be called at a limited rate with a minimum\n   * interval of the specified milliseconds.\n   * @param listener the listener to add\n   * @param rateMs the rate in milliseconds to which calling of the listeners should be limited\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number): void;\n\n  /**\n   * Unsubscribes a subscribed event listener from this dispatcher.\n   * @param listener the listener to remove\n   * @returns {boolean} true if the listener was successfully unsubscribed, false if it isn't subscribed on this\n   *   dispatcher\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean;\n}\n\n/**\n * Event dispatcher to subscribe and trigger events. Each event should have its own dispatcher.\n */\nexport class EventDispatcher<Sender, Args> implements Event<Sender, Args> {\n\n  private listeners: EventListenerWrapper<Sender, Args>[] = [];\n\n  constructor() {\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribe(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeOnce(listener: EventListener<Sender, Args>) {\n    this.listeners.push(new EventListenerWrapper(listener, true));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  subscribeRateLimited(listener: EventListener<Sender, Args>, rateMs: number) {\n    this.listeners.push(new RateLimitedEventListenerWrapper(listener, rateMs));\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  unsubscribe(listener: EventListener<Sender, Args>): boolean {\n    // Iterate through listeners, compare with parameter, and remove if found\n    // NOTE: In case we ever remove all matching listeners instead of just the first, we need to reverse-iterate here\n    for (let i = 0; i < this.listeners.length; i++) {\n      let subscribedListener = this.listeners[i];\n      if (subscribedListener.listener === listener) {\n        ArrayUtils.remove(this.listeners, subscribedListener);\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Removes all listeners from this dispatcher.\n   */\n  unsubscribeAll(): void {\n    this.listeners = [];\n  }\n\n  /**\n   * Dispatches an event to all subscribed listeners.\n   * @param sender the source of the event\n   * @param args the arguments for the event\n   */\n  dispatch(sender: Sender, args: Args = null) {\n    let listenersToRemove = [];\n\n    // Call every listener\n    // We iterate over a copy of the array of listeners to avoid the case where events are not fired on listeners when\n    // listeners are unsubscribed from within the event handlers during a dispatch (because the indices change and\n    // listeners are shifted within the array).\n    // This means that listener x+1 will still be called if unsubscribed from within the handler of listener x, as well\n    // as listener y+1 will not be called when subscribed from within the handler of listener y.\n    // Array.slice(0) is the fastest array copy method according to: https://stackoverflow.com/a/21514254/370252\n    const listeners = this.listeners.slice(0);\n    for (let listener of listeners) {\n      listener.fire(sender, args);\n\n      if (listener.isOnce()) {\n        listenersToRemove.push(listener);\n      }\n    }\n\n    // Remove one-time listener\n    for (let listenerToRemove of listenersToRemove) {\n      ArrayUtils.remove(this.listeners, listenerToRemove);\n    }\n  }\n\n  /**\n   * Returns the event that this dispatcher manages and on which listeners can subscribe and unsubscribe event handlers.\n   * @returns {Event}\n   */\n  getEvent(): Event<Sender, Args> {\n    // For now, just cast the event dispatcher to the event interface. At some point in the future when the\n    // codebase grows, it might make sense to split the dispatcher into separate dispatcher and event classes.\n    return <Event<Sender, Args>>this;\n  }\n}\n\n/**\n * A basic event listener wrapper to manage listeners within the {@link EventDispatcher}. This is a 'private' class\n * for internal dispatcher use and it is therefore not exported.\n */\nclass EventListenerWrapper<Sender, Args> {\n\n  private eventListener: EventListener<Sender, Args>;\n  private once: boolean;\n\n  constructor(listener: EventListener<Sender, Args>, once: boolean = false) {\n    this.eventListener = listener;\n    this.once = once;\n  }\n\n  /**\n   * Returns the wrapped event listener.\n   * @returns {EventListener<Sender, Args>}\n   */\n  get listener(): EventListener<Sender, Args> {\n    return this.eventListener;\n  }\n\n  /**\n   * Fires the wrapped event listener with the given arguments.\n   * @param sender\n   * @param args\n   */\n  fire(sender: Sender, args: Args) {\n    this.eventListener(sender, args);\n  }\n\n  /**\n   * Checks if this listener is scheduled to be called only once.\n   * @returns {boolean} once if true\n   */\n  isOnce(): boolean {\n    return this.once;\n  }\n}\n\n/**\n * Extends the basic {@link EventListenerWrapper} with rate-limiting functionality.\n */\nclass RateLimitedEventListenerWrapper<Sender, Args> extends EventListenerWrapper<Sender, Args> {\n\n  private rateMs: number;\n  private rateLimitingEventListener: EventListener<Sender, Args>;\n\n  private lastFireTime: number;\n\n  constructor(listener: EventListener<Sender, Args>, rateMs: number) {\n    super(listener); // sets the event listener sink\n\n    this.rateMs = rateMs;\n    this.lastFireTime = 0;\n\n    // Wrap the event listener with an event listener that does the rate-limiting\n    this.rateLimitingEventListener = (sender: Sender, args: Args) => {\n      if (Date.now() - this.lastFireTime > this.rateMs) {\n        // Only if enough time since the previous call has passed, call the\n        // actual event listener and record the current time\n        this.fireSuper(sender, args);\n        this.lastFireTime = Date.now();\n      }\n    };\n  }\n\n  private fireSuper(sender: Sender, args: Args) {\n    // Fire the actual external event listener\n    super.fire(sender, args);\n  }\n\n  fire(sender: Sender, args: Args) {\n    // Fire the internal rate-limiting listener instead of the external event listener\n    this.rateLimitingEventListener(sender, args);\n  }\n}","export namespace Guid {\n\n  let guid = 1;\n\n  export function next() {\n    return guid++;\n  }\n}\n","import {DOM} from './dom';\n\nexport interface ImageLoadedCallback {\n  (url: string, width: number, height: number): void;\n}\n\ninterface ImageLoaderState {\n  url: string;\n  image: DOM;\n  loadedCallback: ImageLoadedCallback;\n  loaded: boolean;\n  width: number;\n  height: number;\n}\n\n/**\n * Tracks the loading state of images.\n */\nexport class ImageLoader {\n\n  private state: { [url: string]: ImageLoaderState; } = {};\n\n  /**\n   * Loads an image and call the callback once the image is loaded. If the image is already loaded, the callback\n   * is called immediately, else it is called once loading has finished. Calling this method multiple times for the\n   * same image while it is loading calls only let callback passed into the last call.\n   * @param url The url to the image to load\n   * @param loadedCallback The callback that is called when the image is loaded\n   */\n  load(url: string, loadedCallback: ImageLoadedCallback): void {\n    if (!this.state[url]) {\n      // When the image was never attempted to be loaded before, we create a state and store it in the state map\n      // for later use when the same image is requested to be loaded again.\n      let state: ImageLoaderState = {\n        url: url,\n        image: new DOM('img', {}),\n        loadedCallback: loadedCallback,\n        loaded: false,\n        width: 0,\n        height: 0,\n      };\n      this.state[url] = state;\n\n      // Listen to the load event, update the state and call the callback once the image is loaded\n      state.image.on('load', (e) => {\n        state.loaded = true;\n        state.width = (<HTMLImageElement>state.image.get(0)).width;\n        state.height = (<HTMLImageElement>state.image.get(0)).height;\n\n        this.callLoadedCallback(state);\n      });\n\n      // Set the image URL to start the loading\n      state.image.attr('src', state.url);\n    } else {\n      // We have a state for the requested image, so it is either already loaded or currently loading\n      let state = this.state[url];\n\n      // We overwrite the callback to make sure that only the callback of the latest call gets executed.\n      // Earlier callbacks become invalid once a new load call arrives, and they are not called as long as the image\n      // is not loaded.\n      state.loadedCallback = loadedCallback;\n\n      // When the image is already loaded, we directly execute the callback instead of waiting for the load event\n      if (state.loaded) {\n        this.callLoadedCallback(state);\n      }\n    }\n  }\n\n  private callLoadedCallback(state: ImageLoaderState): void {\n    state.loadedCallback(state.url, state.width, state.height);\n  }\n}\n","/// <reference path='player.d.ts' />\nimport {UIManager, UIInstanceManager} from './uimanager';\nimport {Button} from './components/button';\nimport {ControlBar} from './components/controlbar';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {HugePlaybackToggleButton} from './components/hugeplaybacktogglebutton';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {SeekBar} from './components/seekbar';\nimport {SelectBox} from './components/selectbox';\nimport {ItemSelectionList} from './components/itemselectionlist';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {ToggleButton} from './components/togglebutton';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {Watermark} from './components/watermark';\nimport {UIContainer} from './components/uicontainer';\nimport {Container} from './components/container';\nimport {Label} from './components/label';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {Component} from './components/component';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {TitleBar} from './components/titlebar';\nimport {VolumeControlButton} from './components/volumecontrolbutton';\nimport {ClickOverlay} from './components/clickoverlay';\nimport {AdSkipButton} from './components/adskipbutton';\nimport {AdMessageLabel} from './components/admessagelabel';\nimport {AdClickOverlay} from './components/adclickoverlay';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {HugeReplayButton} from './components/hugereplaybutton';\nimport {BufferingOverlay} from './components/bufferingoverlay';\nimport {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {VolumeSlider} from './components/volumeslider';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {Spacer} from './components/spacer';\nimport {BackgroundColorSelectBox} from './components/subtitlesettings/backgroundcolorselectbox';\nimport {BackgroundOpacitySelectBox} from './components/subtitlesettings/backgroundopacityselectbox';\nimport {CharacterEdgeSelectBox} from './components/subtitlesettings/characteredgeselectbox';\nimport {FontColorSelectBox} from './components/subtitlesettings/fontcolorselectbox';\nimport {FontFamilySelectBox} from './components/subtitlesettings/fontfamilyselectbox';\nimport {FontOpacitySelectBox} from './components/subtitlesettings/fontopacityselectbox';\nimport {FontSizeSelectBox} from './components/subtitlesettings/fontsizeselectbox';\nimport {SubtitleSettingsButton} from './components/subtitlesettings/subtitlesettingsbutton';\nimport {SubtitleSettingsCloseButton} from './components/subtitlesettings/subtitlesettingsclosebutton';\nimport {SubtitleSettingSelectBox} from './components/subtitlesettings/subtitlesettingselectbox';\nimport {SubtitleSettingsLabel} from './components/subtitlesettings/subtitlesettingslabel';\nimport {SubtitleSettingsOpenButton} from './components/subtitlesettings/subtitlesettingsopenbutton';\nimport {SubtitleSettingsPanel} from './components/subtitlesettings/subtitlesettingspanel';\nimport {WindowColorSelectBox} from './components/subtitlesettings/windowcolorselectbox';\nimport {WindowOpacitySelectBox} from './components/subtitlesettings/windowopacityselectbox';\nimport {ArrayUtils} from './arrayutils';\nimport {StringUtils} from './stringutils';\nimport {PlayerUtils} from './playerutils';\nimport {UIUtils} from './uiutils';\nimport {BrowserUtils} from './browserutils';\nimport {StorageUtils} from './storageutils';\n// HACK: gulp-tslint fails on unused files so we need this dummy import\nimport {ArrayUtils as Dummy} from './utils'; // tslint:disable-line\nimport {SubtitleSettingsResetButton} from './components/subtitlesettings/subtitlesettingsresetbutton';\n\n// Object.assign polyfill for ES5/IE9\n// https://developer.mozilla.org/de/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\nif (typeof Object.assign !== 'function') {\n  Object.assign = function(target: any) {\n    'use strict';\n    if (target == null) {\n      throw new TypeError('Cannot convert undefined or null to object');\n    }\n\n    target = Object(target);\n    for (let index = 1; index < arguments.length; index++) {\n      let source = arguments[index];\n      if (source != null) {\n        for (let key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n    }\n    return target;\n  };\n}\n\nconst playerui = {\n  version: '{{VERSION}}',\n  // Management\n  UIManager,\n  UIInstanceManager,\n  // Utils\n  ArrayUtils,\n  StringUtils,\n  PlayerUtils,\n  UIUtils,\n  BrowserUtils,\n  StorageUtils,\n  // Components\n  AdClickOverlay,\n  AdMessageLabel,\n  AdSkipButton,\n  AirPlayToggleButton,\n  AudioQualitySelectBox,\n  AudioTrackSelectBox,\n  BufferingOverlay,\n  Button,\n  CastStatusOverlay,\n  CastToggleButton,\n  CastUIContainer,\n  ClickOverlay,\n  CloseButton,\n  Component,\n  Container,\n  ControlBar,\n  ErrorMessageOverlay,\n  FullscreenToggleButton,\n  HugePlaybackToggleButton,\n  HugeReplayButton,\n  Label,\n  MetadataLabel,\n  MetadataLabelContent,\n  PictureInPictureToggleButton,\n  PlaybackSpeedSelectBox,\n  PlaybackTimeLabel,\n  PlaybackTimeLabelMode,\n  PlaybackToggleButton,\n  PlaybackToggleOverlay,\n  RecommendationOverlay,\n  SeekBar,\n  SeekBarLabel,\n  SelectBox,\n  ItemSelectionList,\n  SettingsPanel,\n  SettingsPanelItem,\n  SettingsToggleButton,\n  Spacer,\n  SubtitleOverlay,\n  SubtitleSelectBox,\n  TitleBar,\n  ToggleButton,\n  UIContainer,\n  VideoQualitySelectBox,\n  VolumeControlButton,\n  VolumeSlider,\n  VolumeToggleButton,\n  VRToggleButton,\n  Watermark,\n  // Subtitle related components\n  subtitlesettings: {\n    BackgroundColorSelectBox,\n    BackgroundOpacitySelectBox,\n    CharacterEdgeSelectBox,\n    FontColorSelectBox,\n    FontFamilySelectBox,\n    FontOpacitySelectBox,\n    FontSizeSelectBox,\n    SubtitleSettingsButton,\n    SubtitleSettingsCloseButton,\n    SubtitleSettingSelectBox,\n    SubtitleSettingsLabel,\n    SubtitleSettingsOpenButton,\n    SubtitleSettingsPanel,\n    WindowColorSelectBox,\n    WindowOpacitySelectBox,\n    SubtitleSettingsResetButton,\n  },\n};\n\n// Export UI as UMD module\n// This goes together with the Browserify \"--standalone bitmovin.playerui\" config option (in the gulpfile)\ndeclare const module: any;\nmodule.exports = playerui;","import {Event, EventDispatcher, NoArgs} from './eventdispatcher';\nimport {BrowserUtils} from './browserutils';\n\nexport namespace PlayerUtils {\n\n  import PlayerAPI = bitmovin.PlayerAPI;\n\n  export enum PlayerState {\n    IDLE,\n    PREPARED,\n    PLAYING,\n    PAUSED,\n    FINISHED,\n  }\n\n  export function isTimeShiftAvailable(player: bitmovin.PlayerAPI): boolean {\n    return player.isLive() && player.getMaxTimeShift() !== 0;\n  }\n\n  export function getState(player: PlayerAPI): PlayerState {\n    if (player.hasEnded()) {\n      return PlayerState.FINISHED;\n    } else if (player.isPlaying()) {\n      return PlayerState.PLAYING;\n    } else if (player.isPaused()) {\n      return PlayerState.PAUSED;\n    } else if (player.isReady()) {\n      return PlayerState.PREPARED;\n    } else {\n      return PlayerState.IDLE;\n    }\n  }\n\n  export interface TimeShiftAvailabilityChangedArgs extends NoArgs {\n    timeShiftAvailable: boolean;\n  }\n\n  export class TimeShiftAvailabilityDetector {\n\n    private player: PlayerAPI;\n    private timeShiftAvailable: boolean;\n    private timeShiftAvailabilityChangedEvent = new EventDispatcher<PlayerAPI, TimeShiftAvailabilityChangedArgs>();\n\n    constructor(player: PlayerAPI) {\n      this.player = player;\n      this.timeShiftAvailable = undefined;\n\n      let timeShiftDetector = () => {\n        this.detect();\n      };\n      // Try to detect timeshift availability in ON_READY, which works for DASH streams\n      player.addEventHandler(player.EVENT.ON_READY, timeShiftDetector);\n      // With HLS/NativePlayer streams, getMaxTimeShift can be 0 before the buffer fills, so we need to additionally\n      // check timeshift availability in ON_TIME_CHANGED\n      player.addEventHandler(player.EVENT.ON_TIME_CHANGED, timeShiftDetector);\n    }\n\n    detect(): void {\n      if (this.player.isLive()) {\n        let timeShiftAvailableNow = PlayerUtils.isTimeShiftAvailable(this.player);\n\n        // When the availability changes, we fire the event\n        if (timeShiftAvailableNow !== this.timeShiftAvailable) {\n          this.timeShiftAvailabilityChangedEvent.dispatch(this.player, { timeShiftAvailable: timeShiftAvailableNow });\n          this.timeShiftAvailable = timeShiftAvailableNow;\n        }\n      }\n    }\n\n    get onTimeShiftAvailabilityChanged(): Event<PlayerAPI, TimeShiftAvailabilityChangedArgs> {\n      return this.timeShiftAvailabilityChangedEvent.getEvent();\n    }\n  }\n\n  export interface LiveStreamDetectorEventArgs extends NoArgs {\n    live: boolean;\n  }\n\n  /**\n   * Detects changes of the stream type, i.e. changes of the return value of the player#isLive method.\n   * Normally, a stream cannot change its type during playback, it's either VOD or live. Due to bugs on some\n   * platforms or browsers, it can still change. It is therefore unreliable to just check #isLive and this detector\n   * should be used as a workaround instead.\n   *\n   * Known cases:\n   *\n   * - HLS VOD on Android 4.3\n   * Video duration is initially 'Infinity' and only gets available after playback starts, so streams are wrongly\n   * reported as 'live' before playback (the live-check in the player checks for infinite duration).\n   */\n  export class LiveStreamDetector {\n\n    private player: PlayerAPI;\n    private live: boolean;\n    private liveChangedEvent = new EventDispatcher<PlayerAPI, LiveStreamDetectorEventArgs>();\n\n    constructor(player: PlayerAPI) {\n      this.player = player;\n      this.live = undefined;\n\n      let liveDetector = () => {\n        this.detect();\n      };\n      // Initialize when player is ready\n      player.addEventHandler(player.EVENT.ON_READY, liveDetector);\n      // Re-evaluate when playback starts\n      player.addEventHandler(player.EVENT.ON_PLAY, liveDetector);\n\n      // HLS live detection workaround for Android:\n      // Also re-evaluate during playback, because that is when the live flag might change.\n      // (Doing it only in Android Chrome saves unnecessary overhead on other plattforms)\n      if (BrowserUtils.isAndroid && BrowserUtils.isChrome) {\n        player.addEventHandler(player.EVENT.ON_TIME_CHANGED, liveDetector);\n      }\n    }\n\n    detect(): void {\n      let liveNow = this.player.isLive();\n\n      // Compare current to previous live state flag and fire event when it changes. Since we initialize the flag\n      // with undefined, there is always at least an initial event fired that tells listeners the live state.\n      if (liveNow !== this.live) {\n        this.liveChangedEvent.dispatch(this.player, { live: liveNow });\n        this.live = liveNow;\n      }\n    }\n\n    get onLiveChanged(): Event<PlayerAPI, LiveStreamDetectorEventArgs> {\n      return this.liveChangedEvent.getEvent();\n    }\n  }\n}","export namespace StorageUtils {\n  let hasLocalStorageCache: boolean;\n\n  export function hasLocalStorage(): boolean {\n    if (hasLocalStorageCache) {\n      return hasLocalStorageCache;\n    }\n\n    // hasLocalStorage is used to safely ensure we can use localStorage\n    // taken from https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API#Feature-detecting_localStorage\n    let storage = window['localStorage'];\n    try {\n      let x = '__storage_test__';\n      storage.setItem(x, x);\n      storage.removeItem(x);\n      hasLocalStorageCache = true;\n    }\n    catch (e) {\n      hasLocalStorageCache = e instanceof DOMException && (\n          // everything except Firefox\n        e.code === 22 ||\n        // Firefox\n        e.code === 1014 ||\n        // test name field too, because code might not be present\n        // everything except Firefox\n        e.name === 'QuotaExceededError' ||\n        // Firefox\n        e.name === 'NS_ERROR_DOM_QUOTA_REACHED') &&\n        // acknowledge QuotaExceededError only if there's something already stored\n        storage.length !== 0;\n    }\n    return hasLocalStorageCache;\n  }\n\n  /**\n   * Stores a string item into localStorage.\n   * @param key the item's key\n   * @param data the item's data\n   */\n  export function setItem(key: string, data: string): void {\n    if (StorageUtils.hasLocalStorage()) {\n      window.localStorage.setItem(key, data);\n    }\n  }\n\n  /**\n   * Gets an item's string value from the localStorage.\n   * @param key the key to look up its associated value\n   * @return {string | null} Returns the string if found, null if there is no data stored for the key\n   */\n  export function getItem(key: string): string | null {\n    if (StorageUtils.hasLocalStorage()) {\n      return window.localStorage.getItem(key);\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Stores an object into localStorage. The object will be serialized to JSON. The following types are supported\n   * in addition to the default types:\n   *  - ColorUtils.Color\n   *\n   * @param key the key to store the data to\n   * @param data the object to store\n   */\n  export function setObject<T>(key: string, data: T): void {\n    if (StorageUtils.hasLocalStorage()) {\n      let json = JSON.stringify(data);\n      setItem(key, json);\n    }\n  }\n\n  /**\n   * Gets an object for the given key from localStorage. The object will be deserialized from JSON. Beside the\n   * default types, the following types are supported:\n   *  - ColorUtils.Color\n   *\n   * @param key the key to look up its associated object\n   * @return {any} Returns the object if found, null otherwise\n   */\n  export function getObject<T>(key: string): T {\n    if (StorageUtils.hasLocalStorage()) {\n      let json = getItem(key);\n\n      if (key) {\n        let object = JSON.parse(json);\n        return <T>object;\n      }\n    }\n    return null;\n  }\n}\n","export namespace StringUtils {\n\n  export let FORMAT_HHMMSS: string = 'hh:mm:ss';\n  export let FORMAT_MMSS: string = 'mm:ss';\n\n  /**\n   * Formats a number of seconds into a time string with the pattern hh:mm:ss.\n   *\n   * @param totalSeconds the total number of seconds to format to string\n   * @param format the time format to output (default: hh:mm:ss)\n   * @returns {string} the formatted time string\n   */\n  export function secondsToTime(totalSeconds: number, format: string = FORMAT_HHMMSS): string {\n    let isNegative = totalSeconds < 0;\n\n    if (isNegative) {\n      // If the time is negative, we make it positive for the calculation below\n      // (else we'd get all negative numbers) and reattach the negative sign later.\n      totalSeconds = -totalSeconds;\n    }\n\n    // Split into separate time parts\n    let hours = Math.floor(totalSeconds / 3600);\n    let minutes = Math.floor(totalSeconds / 60) - hours * 60;\n    let seconds = Math.floor(totalSeconds) % 60;\n\n    return (isNegative ? '-' : '') + format\n        .replace('hh', leftPadWithZeros(hours, 2))\n        .replace('mm', leftPadWithZeros(minutes, 2))\n        .replace('ss', leftPadWithZeros(seconds, 2));\n  }\n\n  /**\n   * Converts a number to a string and left-pads it with zeros to the specified length.\n   * Example: leftPadWithZeros(123, 5) => '00123'\n   *\n   * @param num the number to convert to string and pad with zeros\n   * @param length the desired length of the padded string\n   * @returns {string} the padded number as string\n   */\n  function leftPadWithZeros(num: number | string, length: number): string {\n    let text = num + '';\n    let padding = '0000000000'.substr(0, length - text.length);\n    return padding + text;\n  }\n\n  /**\n   * Fills out placeholders in an ad message.\n   *\n   * Has the placeholders '{remainingTime[formatString]}', '{playedTime[formatString]}' and\n   * '{adDuration[formatString]}', which are replaced by the remaining time until the ad can be skipped, the current\n   * time or the ad duration. The format string is optional. If not specified, the placeholder is replaced by the time\n   * in seconds. If specified, it must be of the following format:\n   * - %d - Inserts the time as an integer.\n   * - %0Nd - Inserts the time as an integer with leading zeroes, if the length of the time string is smaller than N.\n   * - %f - Inserts the time as a float.\n   * - %0Nf - Inserts the time as a float with leading zeroes.\n   * - %.Mf - Inserts the time as a float with M decimal places. Can be combined with %0Nf, e.g. %04.2f (the time\n   * 10.123\n   * would be printed as 0010.12).\n   * - %hh:mm:ss\n   * - %mm:ss\n   *\n   * @param adMessage an ad message with optional placeholders to fill\n   * @param skipOffset if specified, {remainingTime} will be filled with the remaining time until the ad can be skipped\n   * @param player the player to get the time data from\n   * @returns {string} the ad message with filled placeholders\n   */\n  export function replaceAdMessagePlaceholders(adMessage: string, skipOffset: number, player: bitmovin.PlayerAPI) {\n    let adMessagePlaceholderRegex = new RegExp(\n      '\\\\{(remainingTime|playedTime|adDuration)(}|%((0[1-9]\\\\d*(\\\\.\\\\d+(d|f)|d|f)|\\\\.\\\\d+f|d|f)|hh:mm:ss|mm:ss)})',\n      'g'\n    );\n\n    return adMessage.replace(adMessagePlaceholderRegex, (formatString) => {\n      let time = 0;\n      if (formatString.indexOf('remainingTime') > -1) {\n        if (skipOffset) {\n          time = Math.ceil(skipOffset - player.getCurrentTime());\n        } else {\n          time = player.getDuration() - player.getCurrentTime();\n        }\n      } else if (formatString.indexOf('playedTime') > -1) {\n        time = player.getCurrentTime();\n      } else if (formatString.indexOf('adDuration') > -1) {\n        time = player.getDuration();\n      }\n      return formatNumber(time, formatString);\n    });\n  }\n\n  function formatNumber(time: number, format: string) {\n    let formatStringValidationRegex = /%((0[1-9]\\d*(\\.\\d+(d|f)|d|f)|\\.\\d+f|d|f)|hh:mm:ss|mm:ss)/;\n    let leadingZeroesRegex = /(%0[1-9]\\d*)(?=(\\.\\d+f|f|d))/;\n    let decimalPlacesRegex = /\\.\\d*(?=f)/;\n\n    if (!formatStringValidationRegex.test(format)) {\n      // If the format is invalid, we set a default fallback format\n      format = '%d';\n    }\n\n    // Determine the number of leading zeros\n    let leadingZeroes = 0;\n    let leadingZeroesMatches = format.match(leadingZeroesRegex);\n    if (leadingZeroesMatches) {\n      leadingZeroes = parseInt(leadingZeroesMatches[0].substring(2));\n    }\n\n    // Determine the number of decimal places\n    let numDecimalPlaces = null;\n    let decimalPlacesMatches = format.match(decimalPlacesRegex);\n    if (decimalPlacesMatches && !isNaN(parseInt(decimalPlacesMatches[0].substring(1)))) {\n      numDecimalPlaces = parseInt(decimalPlacesMatches[0].substring(1));\n      if (numDecimalPlaces > 20) {\n        numDecimalPlaces = 20;\n      }\n    }\n\n    // Float format\n    if (format.indexOf('f') > -1) {\n      let timeString = '';\n\n      if (numDecimalPlaces !== null) {\n        // Apply fixed number of decimal places\n        timeString = time.toFixed(numDecimalPlaces);\n      } else {\n        timeString = '' + time;\n      }\n\n      // Apply leading zeros\n      if (timeString.indexOf('.') > -1) {\n        return leftPadWithZeros(timeString, timeString.length + (leadingZeroes - timeString.indexOf('.')));\n      } else {\n        return leftPadWithZeros(timeString, leadingZeroes);\n      }\n\n    }\n    // Time format\n    else if (format.indexOf(':') > -1) {\n      let totalSeconds = Math.ceil(time);\n\n      // hh:mm:ss format\n      if (format.indexOf('hh') > -1) {\n        return secondsToTime(totalSeconds);\n      }\n      // mm:ss format\n      else {\n        let minutes = Math.floor(totalSeconds / 60);\n        let seconds = totalSeconds % 60;\n\n        return leftPadWithZeros(minutes, 2) + ':' + leftPadWithZeros(seconds, 2);\n      }\n    }\n    // Integer format\n    else {\n      return leftPadWithZeros(Math.ceil(time), leadingZeroes);\n    }\n  }\n}\n","// TODO change to internal (not exported) class, how to use in other files?\n/**\n * Executes a callback after a specified amount of time, optionally repeatedly until stopped.\n */\nexport class Timeout {\n\n  private delay: number;\n  private callback: () => void;\n  private repeat: boolean;\n  // There's two setTimeout declarations, one on Window which returns type \"number\" and one in NodeJS which returns\n  // type \"Timer\". For unknown reasons builds on Jenkins fail due to a type mismatch when we use type \"number\" here,\n  // although it works on other platforms (e.g. Windows, Codeship).\n  // To work around the issue we use type \"any\". The type does not matter anyway because we're not working with\n  // this value except providing it to clearTimeout.\n  private timeoutHandle: any;\n\n  /**\n   * Creates a new timeout callback handler.\n   * @param delay the delay in milliseconds after which the callback should be executed\n   * @param callback the callback to execute after the delay time\n   * @param repeat if true, call the callback repeatedly in delay intervals\n   */\n  constructor(delay: number, callback: () => void, repeat: boolean = false) {\n    this.delay = delay;\n    this.callback = callback;\n    this.repeat = repeat;\n    this.timeoutHandle = 0;\n  }\n\n  /**\n   * Starts the timeout and calls the callback when the timeout delay has passed.\n   * @returns {Timeout} the current timeout (so the start call can be chained to the constructor)\n   */\n  start(): this {\n    this.reset();\n    return this;\n  }\n\n  /**\n   * Clears the timeout. The callback will not be called if clear is called during the timeout.\n   */\n  clear(): void {\n    this.clearInternal();\n  }\n\n  /**\n   * Resets the passed timeout delay to zero. Can be used to defer the calling of the callback.\n   */\n  reset(): void {\n    let lastScheduleTime = 0;\n    let delayAdjust = 0;\n\n    this.clearInternal();\n\n    let internalCallback = () => {\n      this.callback();\n\n      if (this.repeat) {\n        let now = Date.now();\n\n        // The time of one iteration from scheduling to executing the callback (usually a bit longer than the delay\n        // time)\n        let delta = now - lastScheduleTime;\n\n        // Calculate the delay adjustment for the next schedule to keep a steady delay interval over time\n        delayAdjust = this.delay - delta + delayAdjust;\n\n        lastScheduleTime = now;\n\n        // Schedule next execution by the adjusted delay\n        this.timeoutHandle = setTimeout(internalCallback, this.delay + delayAdjust);\n      }\n    };\n\n    lastScheduleTime = Date.now();\n    this.timeoutHandle = setTimeout(internalCallback, this.delay);\n  }\n\n  private clearInternal(): void {\n    clearTimeout(this.timeoutHandle);\n  }\n}","import {UIContainer} from './components/uicontainer';\nimport {DOM} from './dom';\nimport {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\nimport {PlaybackToggleButton} from './components/playbacktogglebutton';\nimport {FullscreenToggleButton} from './components/fullscreentogglebutton';\nimport {VRToggleButton} from './components/vrtogglebutton';\nimport {VolumeToggleButton} from './components/volumetogglebutton';\nimport {SeekBar, SeekBarMarker} from './components/seekbar';\nimport {PlaybackTimeLabel, PlaybackTimeLabelMode} from './components/playbacktimelabel';\nimport {ControlBar} from './components/controlbar';\nimport {CancelEventArgs, EventDispatcher, NoArgs} from './eventdispatcher';\nimport {SettingsToggleButton} from './components/settingstogglebutton';\nimport {SettingsPanel, SettingsPanelItem} from './components/settingspanel';\nimport {SubtitleSettingsPanel} from './components/subtitlesettings/subtitlesettingspanel';\nimport {SubtitleSettingsLabel} from './components/subtitlesettings/subtitlesettingslabel';\nimport {SubtitleSettingsOpenButton} from './components/subtitlesettings/subtitlesettingsopenbutton';\nimport {VideoQualitySelectBox} from './components/videoqualityselectbox';\n// import {Watermark} from './components/watermark';\nimport {AudioQualitySelectBox} from './components/audioqualityselectbox';\nimport {AudioTrackSelectBox} from './components/audiotrackselectbox';\nimport {SeekBarLabel} from './components/seekbarlabel';\nimport {VolumeSlider} from './components/volumeslider';\nimport {SubtitleSelectBox} from './components/subtitleselectbox';\nimport {SubtitleOverlay} from './components/subtitleoverlay';\n// import {VolumeControlButton} from './components/volumecontrolbutton';\nimport {CastToggleButton} from './components/casttogglebutton';\nimport {CastStatusOverlay} from './components/caststatusoverlay';\nimport {ErrorMessageOverlay} from './components/errormessageoverlay';\nimport {TitleBar} from './components/titlebar';\nimport {RecommendationOverlay} from './components/recommendationoverlay';\nimport {PlaybackSpeedSelectBox} from './components/playbackspeedselectbox';\nimport {BufferingOverlay} from './components/bufferingoverlay';\n// import {CastUIContainer} from './components/castuicontainer';\nimport {PlaybackToggleOverlay} from './components/playbacktoggleoverlay';\nimport {CloseButton} from './components/closebutton';\nimport {MetadataLabel, MetadataLabelContent} from './components/metadatalabel';\nimport {AirPlayToggleButton} from './components/airplaytogglebutton';\nimport {PictureInPictureToggleButton} from './components/pictureinpicturetogglebutton';\nimport {AudioOnlyOverlay} from './components/audioonlyoverlay';\nimport {Spacer} from './components/spacer';\nimport {UIUtils} from './uiutils';\nimport {ArrayUtils} from './arrayutils';\nimport {BrowserUtils} from './browserutils';\nimport PlayerAPI = bitmovin.PlayerAPI;\n// import {AdMessageLabel} from './components/admessagelabel';\n// import {AdSkipButton} from './components/adskipbutton';\n// import {AdClickOverlay} from './components/adclickoverlay';\nimport EVENT = bitmovin.PlayerAPI.EVENT;\nimport PlayerEventCallback = bitmovin.PlayerAPI.PlayerEventCallback;\nimport AdStartedEvent = bitmovin.PlayerAPI.AdStartedEvent;\n// import {Label} from './components/label';\nimport PlayerEvent = bitmovin.PlayerAPI.PlayerEvent;\n\nexport interface UIRecommendationConfig {\n  title: string;\n  url: string;\n  thumbnail?: string;\n  duration?: number;\n}\n\n/**\n * Marks a position on the playback timeline, e.g. a chapter or an ad break.\n */\nexport interface TimelineMarker {\n  /**\n   * The time in the playback timeline (e.g. {@link SeekBar}) that should be marked.\n   */\n  time: number;\n  /**\n   * Optional duration that makes the marker mark an interval instead of a single moment in time.\n   */\n  duration?: number;\n  /**\n   * Optional title text of the marked position, e.g. a chapter name.\n   * Will be rendered in the {@link SeekBarLabel} attached to a {@link SeekBar}.\n   */\n  title?: string;\n  /**\n   * Optional CSS classes that are applied to the marker on a {@link SeekBar} and can be used to\n   * differentiate different types of markers by their style (e.g. different color of chapter markers\n   * and ad break markers).\n   * The CSS classes are also propagated to a connected {@link SeekBarLabel}.\n   *\n   * Multiple classes can be added to allow grouping of markers into types (e.g. chapter markers,\n   * ad break markers) by a shared class and still identify and style each marker with distinct\n   * classes (e.g. `['marker-type-chapter', 'chapter-number-1']`).\n   */\n  cssClasses?: string[];\n}\n\nexport interface UIConfig {\n  /**\n   * Specifies the container in the DOM into which the UI will be added. Can be a CSS selector string or a\n   * HTMLElement object. By default, the player figure will be used ({@link PlayerAPI#getFigure}).\n   */\n  container?: string | HTMLElement;\n  metadata?: {\n    title?: string;\n    description?: string;\n    markers?: TimelineMarker[];\n  };\n  // TODO move recommendations into metadata in next major release\n  recommendations?: UIRecommendationConfig[];\n  /**\n   * Specifies if the UI variants should be resolved and switched automatically upon certain player events. The default\n   * is `true`. Should be set to `false` if purely manual switching through {@link UIManager.resolveUiVariant} is\n   * desired. A hybrid approach can be used by setting this to `true` (or leaving the default) and overriding\n   * automatic switches through a {@link UIManager.onUiVariantResolve} event handler.\n   */\n  autoUiVariantResolve?: boolean;\n}\n\nexport interface InternalUIConfig extends UIConfig {\n  events: {\n    /**\n     * Fires when the configuration has been updated/changed.\n     */\n    onUpdated: EventDispatcher<UIManager, void>;\n  };\n}\n\n/**\n * The context that will be passed to a {@link UIConditionResolver} to determine if it's conditions fulfil the context.\n */\nexport interface UIConditionContext {\n  /**\n   * Tells if the player is loading or playing an ad.\n   */\n  isAd: boolean;\n  /**\n   * Tells if the ad allows a UI. This is currently only true for VAST ads and cannot be used to differentiate between\n   * different ad clients (i.e. to display different UIs for different ad clients).\n   * @deprecated Will be removed in an upcoming major release, use {@link #adClientType} instead.\n   */\n  isAdWithUI: boolean;\n  /**\n   * Tells the ad client (e.g. 'vast, 'ima') if {@link #isAd} is true.\n   */\n  adClientType: string;\n  /**\n   * Tells if the player is currently in fullscreen mode.\n   */\n  isFullscreen: boolean;\n  /**\n   * Tells if the UI is running in a mobile browser.\n   */\n  isMobile: boolean;\n  /**\n   * Tells if the player is in playing or paused state.\n   */\n  isPlaying: boolean;\n  /**\n   * The width of the player/UI element.\n   */\n  width: number;\n  /**\n   * The width of the document where the player/UI is embedded in.\n   */\n  documentWidth: number;\n}\n\n/**\n * Resolves the conditions of its associated UI in a {@link UIVariant} upon a {@link UIConditionContext} and decides\n * if the UI should be displayed. If it returns true, the UI is a candidate for display; if it returns false, it will\n * not be displayed in the given context.\n */\nexport interface UIConditionResolver {\n  (context: UIConditionContext): boolean;\n}\n\n/**\n * Associates a UI instance with an optional {@link UIConditionResolver} that determines if the UI should be displayed.\n */\nexport interface UIVariant {\n  ui: UIContainer;\n  condition?: UIConditionResolver;\n}\n\nexport class UIManager {\n\n  private player: PlayerAPI;\n  private uiContainerElement: DOM;\n  private uiVariants: UIVariant[];\n  private uiInstanceManagers: InternalUIInstanceManager[];\n  private currentUi: InternalUIInstanceManager;\n  private config: InternalUIConfig;\n  private managerPlayerWrapper: PlayerWrapper;\n\n  private events = {\n    onUiVariantResolve: new EventDispatcher<UIManager, UIConditionContext>(),\n  };\n\n  /**\n   * Creates a UI manager with a single UI variant that will be permanently shown.\n   * @param player the associated player of this UI\n   * @param ui the UI to add to the player\n   * @param config optional UI configuration\n   */\n  constructor(player: PlayerAPI, ui: UIContainer, config?: UIConfig);\n  /**\n   * Creates a UI manager with a list of UI variants that will be dynamically selected and switched according to\n   * the context of the UI.\n   *\n   * Every time the UI context changes, the conditions of the UI variants will be sequentially resolved and the first\n   * UI, whose condition evaluates to true, will be selected and displayed. The last variant in the list might omit the\n   * condition resolver and will be selected as default/fallback UI when all other conditions fail. If there is no\n   * fallback UI and all conditions fail, no UI will be displayed.\n   *\n   * @param player the associated player of this UI\n   * @param uiVariants a list of UI variants that will be dynamically switched\n   * @param config optional UI configuration\n   */\n  constructor(player: PlayerAPI, uiVariants: UIVariant[], config?: UIConfig);\n  constructor(player: PlayerAPI, playerUiOrUiVariants: UIContainer | UIVariant[], config: UIConfig = {}) {\n    if (playerUiOrUiVariants instanceof UIContainer) {\n      // Single-UI constructor has been called, transform arguments to UIVariant[] signature\n      let playerUi = <UIContainer>playerUiOrUiVariants;\n      let uiVariants = [];\n\n      // Add the default player UI\n      uiVariants.push({ ui: playerUi });\n\n      this.uiVariants = uiVariants;\n    }\n    else {\n      // Default constructor (UIVariant[]) has been called\n      this.uiVariants = <UIVariant[]>playerUiOrUiVariants;\n    }\n\n    this.player = player;\n    this.config = {\n      ...config,\n      events: {\n        onUpdated: new EventDispatcher<UIManager, void>(),\n      },\n    };\n    this.managerPlayerWrapper = new PlayerWrapper(player);\n\n    /**\n     * Gathers configuration data from the UI config and player source config and creates a merged UI config\n     * that is used throughout the UI instance.\n     */\n    const updateConfig = () => {\n      const playerSourceConfig = player.getConfig().source || {};\n\n      const uiConfig = { ...config };\n      uiConfig.metadata = uiConfig.metadata || {};\n\n      // Extract the UI-related config properties from the source config\n      const playerSourceUiConfig: UIConfig = {\n        metadata: {\n          // TODO move metadata into source.metadata namespace in player v8\n          title: playerSourceConfig.title,\n          description: playerSourceConfig.description,\n          markers: playerSourceConfig.markers,\n        },\n        recommendations: playerSourceConfig.recommendations,\n      };\n\n      // Player source config takes precedence over the UI config, because the config in the source is attached\n      // to a source which changes with every player.load, whereas the UI config stays the same for the whole\n      // lifetime of the player instance.\n      this.config.metadata = this.config.metadata || {};\n      this.config.metadata.title = playerSourceUiConfig.metadata.title || uiConfig.metadata.title;\n      this.config.metadata.description = playerSourceUiConfig.metadata.description || uiConfig.metadata.description;\n      this.config.metadata.markers = playerSourceUiConfig.metadata.markers || uiConfig.metadata.markers || [];\n      this.config.recommendations = playerSourceUiConfig.recommendations || uiConfig.recommendations || [];\n    };\n\n    updateConfig();\n\n    // Update the configuration when a new source is loaded\n    this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_SOURCE_LOADED, () => {\n      updateConfig();\n      this.config.events.onUpdated.dispatch(this);\n    });\n\n    if (config.container) {\n      // Unfortunately 'uiContainerElement = new DOM(config.container)' will not accept the container with\n      // string|HTMLElement type directly, although it accepts both types, so we need to spit these two cases up here.\n      // TODO check in upcoming TS versions if the container can be passed in directly, or fix the constructor\n      this.uiContainerElement = config.container instanceof HTMLElement ?\n        new DOM(config.container) : new DOM(config.container);\n    } else {\n      this.uiContainerElement = new DOM(player.getFigure());\n    }\n\n    // Create UI instance managers for the UI variants\n    // The instance managers map to the corresponding UI variants by their array index\n    this.uiInstanceManagers = [];\n    let uiVariantsWithoutCondition = [];\n    for (let uiVariant of this.uiVariants) {\n      if (uiVariant.condition == null) {\n        // Collect variants without conditions for error checking\n        uiVariantsWithoutCondition.push(uiVariant);\n      }\n      // Create the instance manager for a UI variant\n      this.uiInstanceManagers.push(new InternalUIInstanceManager(player, uiVariant.ui, this.config));\n    }\n    // Make sure that there is only one UI variant without a condition\n    // It does not make sense to have multiple variants without condition, because only the first one in the list\n    // (the one with the lowest index) will ever be selected.\n    if (uiVariantsWithoutCondition.length > 1) {\n      throw Error('Too many UIs without a condition: You cannot have more than one default UI');\n    }\n    // Make sure that the default UI variant, if defined, is at the end of the list (last index)\n    // If it comes earlier, the variants with conditions that come afterwards will never be selected because the\n    // default variant without a condition always evaluates to 'true'\n    if (uiVariantsWithoutCondition.length > 0\n      && uiVariantsWithoutCondition[0] !== this.uiVariants[this.uiVariants.length - 1]) {\n      throw Error('Invalid UI variant order: the default UI (without condition) must be at the end of the list');\n    }\n\n    // Switch on auto UI resolving by default\n    if (config.autoUiVariantResolve === undefined) {\n      config.autoUiVariantResolve = true;\n    }\n\n    let adStartedEvent: AdStartedEvent = null; // keep the event stored here during ad playback\n\n    // Dynamically select a UI variant that matches the current UI condition.\n    let resolveUiVariant = (event: PlayerEvent) => {\n      // Make sure that the ON_AD_STARTED event data is persisted through ad playback in case other events happen\n      // in the meantime, e.g. player resize. We need to store this data because there is no other way to find out\n      // ad details (e.g. the ad client) while an ad is playing.\n      // Existing event data signals that an ad is currently active. We cannot use player.isAd() because it returns\n      // true on ad start and also on ad end events, which is problematic.\n      if (event != null) {\n        switch (event.type) {\n          // When the ad starts, we store the event data\n          case player.EVENT.ON_AD_STARTED:\n            adStartedEvent = <AdStartedEvent>event;\n            break;\n          // When the ad ends, we delete the event data\n          case player.EVENT.ON_AD_FINISHED:\n          case player.EVENT.ON_AD_SKIPPED:\n          case player.EVENT.ON_AD_ERROR:\n            adStartedEvent = null;\n            break;\n          // When a new source is loaded during ad playback, there will be no ad end event so we detect the end\n          // of the ad playback by checking isAd() in ON_READY, because ON_READY always arrives when the source\n          // changes.\n          case player.EVENT.ON_READY:\n            if (adStartedEvent && !player.isAd()) {\n              adStartedEvent = null;\n            }\n        }\n      }\n\n      // Detect if an ad has started\n      let ad = adStartedEvent != null;\n      let adWithUI = ad && adStartedEvent.clientType === 'vast';\n\n      this.resolveUiVariant({\n        isAd: ad,\n        isAdWithUI: adWithUI,\n        adClientType: ad ? adStartedEvent.clientType : null,\n      }, (context) => {\n        // If this is an ad UI, we need to relay the saved ON_AD_STARTED event data so ad components can configure\n        // themselves for the current ad.\n        if (context.isAd) {\n          /* Relay the ON_AD_STARTED event to the ads UI\n           *\n           * Because the ads UI is initialized in the ON_AD_STARTED handler, i.e. when the ON_AD_STARTED event has\n           * already been fired, components in the ads UI that listen for the ON_AD_STARTED event never receive it.\n           * Since this can break functionality of components that rely on this event, we relay the event to the\n           * ads UI components with the following call.\n           */\n          this.currentUi.getWrappedPlayer().fireEventInUI(this.player.EVENT.ON_AD_STARTED, adStartedEvent);\n        }\n      });\n    };\n\n    // Listen to the following events to trigger UI variant resolution\n    if (config.autoUiVariantResolve) {\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_READY, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PLAY, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PAUSED, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_STARTED, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_FINISHED, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_SKIPPED, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_AD_ERROR, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_PLAYER_RESIZE, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_ENTER, resolveUiVariant);\n      this.managerPlayerWrapper.getPlayer().addEventHandler(this.player.EVENT.ON_FULLSCREEN_EXIT, resolveUiVariant);\n    }\n\n    // Initialize the UI\n    resolveUiVariant(null);\n  }\n\n  getConfig(): UIConfig {\n    return this.config;\n  }\n\n  /**\n   * Returns the list of UI variants as passed into the constructor of {@link UIManager}.\n   * @returns {UIVariant[]} the list of available UI variants\n   */\n  getUiVariants(): UIVariant[] {\n    return this.uiVariants;\n  }\n\n  /**\n   * Switches to a UI variant from the list returned by {@link getUiVariants}.\n   * @param {UIVariant} uiVariant the UI variant to switch to\n   * @param {() => void} onShow a callback that is executed just before the new UI variant is shown\n   */\n  switchToUiVariant(uiVariant: UIVariant, onShow?: () => void): void {\n    let uiVariantIndex = this.uiVariants.indexOf(uiVariant);\n\n    const nextUi: InternalUIInstanceManager = this.uiInstanceManagers[uiVariantIndex];\n    let uiVariantChanged = false;\n\n    // Determine if the UI variant is changing\n    if (nextUi !== this.currentUi) {\n      uiVariantChanged = true;\n      // console.log('switched from ', this.currentUi ? this.currentUi.getUI() : 'none',\n      //   ' to ', nextUi ? nextUi.getUI() : 'none');\n    }\n\n    // Only if the UI variant is changing, we need to do some stuff. Else we just leave everything as-is.\n    if (uiVariantChanged) {\n      // Hide the currently active UI variant\n      if (this.currentUi) {\n        this.currentUi.getUI().hide();\n      }\n\n      // Assign the new UI variant as current UI\n      this.currentUi = nextUi;\n\n      // When we switch to a different UI instance, there's some additional stuff to manage. If we do not switch\n      // to an instance, we're done here.\n      if (this.currentUi != null) {\n        // Add the UI to the DOM (and configure it) the first time it is selected\n        if (!this.currentUi.isConfigured()) {\n          this.addUi(this.currentUi);\n        }\n\n        if (onShow) {\n          onShow();\n        }\n\n        this.currentUi.getUI().show();\n      }\n    }\n  }\n\n  /**\n   * Triggers a UI variant switch as triggered by events when automatic switching is enabled. It allows to overwrite\n   * properties of the {@link UIConditionContext}.\n   * @param {Partial<UIConditionContext>} context an optional set of properties that overwrite properties of the\n   *   automatically determined context\n   * @param {(context: UIConditionContext) => void} onShow a callback that is executed just before the new UI variant\n   *   is shown (if a switch is happening)\n   */\n  resolveUiVariant(context: Partial<UIConditionContext> = {}, onShow?: (context: UIConditionContext) => void): void {\n    // Determine the current context for which the UI variant will be resolved\n    const defaultContext: UIConditionContext = {\n      isAd: false,\n      isAdWithUI: false,\n      adClientType: null,\n      isFullscreen: this.player.isFullscreen(),\n      isMobile: BrowserUtils.isMobile,\n      isPlaying: this.player.isPlaying(),\n      width: this.uiContainerElement.width(),\n      documentWidth: document.body.clientWidth,\n    };\n\n    // Overwrite properties of the default context with passed in context properties\n    const switchingContext = { ...defaultContext, ...context };\n\n    // Fire the event and allow modification of the context before it is used to resolve the UI variant\n    this.events.onUiVariantResolve.dispatch(this, switchingContext);\n\n    let nextUiVariant: UIVariant = null;\n\n    // Select new UI variant\n    // If no variant condition is fulfilled, we switch to *no* UI\n    for (let uiVariant of this.uiVariants) {\n      if (uiVariant.condition == null || uiVariant.condition(switchingContext) === true) {\n        nextUiVariant = uiVariant;\n        break;\n      }\n    }\n\n    this.switchToUiVariant(nextUiVariant, () => {\n      if (onShow) {\n        onShow(switchingContext);\n      }\n    });\n  }\n\n  private addUi(ui: InternalUIInstanceManager): void {\n    let dom = ui.getUI().getDomElement();\n    let player = ui.getWrappedPlayer();\n\n    ui.configureControls();\n    /* Append the UI DOM after configuration to avoid CSS transitions at initialization\n     * Example: Components are hidden during configuration and these hides may trigger CSS transitions that are\n     * undesirable at this time. */\n    this.uiContainerElement.append(dom);\n\n    // Some components initialize their state on ON_READY. When the UI is loaded after the player is already ready,\n    // they will never receive the event so we fire it from here in such cases.\n    if (player.isReady()) {\n      player.fireEventInUI(player.EVENT.ON_READY, {});\n    }\n\n    // Fire onConfigured after UI DOM elements are successfully added. When fired immediately, the DOM elements\n    // might not be fully configured and e.g. do not have a size.\n    // https://swizec.com/blog/how-to-properly-wait-for-dom-elements-to-show-up-in-modern-browsers/swizec/6663\n    if (window.requestAnimationFrame) {\n      requestAnimationFrame(() => { ui.onConfigured.dispatch(ui.getUI()); });\n    } else {\n      // IE9 fallback\n      setTimeout(() => { ui.onConfigured.dispatch(ui.getUI()); }, 0);\n    }\n  }\n\n  private releaseUi(ui: InternalUIInstanceManager): void {\n    ui.releaseControls();\n    ui.getUI().getDomElement().remove();\n    ui.clearEventHandlers();\n  }\n\n  release(): void {\n    for (let uiInstanceManager of this.uiInstanceManagers) {\n      this.releaseUi(uiInstanceManager);\n    }\n    this.managerPlayerWrapper.clearEventHandlers();\n  }\n\n  /**\n   * Fires just before UI variants are about to be resolved and the UI variant is possibly switched. It is fired when\n   * the switch is triggered from an automatic switch and when calling {@link resolveUiVariant}.\n   * Can be used to modify the {@link UIConditionContext} before resolving is done.\n   * @returns {EventDispatcher<UIManager, UIConditionContext>}\n   */\n  get onUiVariantResolve(): EventDispatcher<UIManager, UIConditionContext> {\n    return this.events.onUiVariantResolve;\n  }\n\n  /**\n   * Returns the list of all added markers in undefined order.\n   */\n  getTimelineMarkers(): TimelineMarker[] {\n    return this.config.metadata.markers;\n  }\n\n  /**\n   * Adds a marker to the timeline. Does not check for duplicates/overlaps at the `time`.\n   */\n  addTimelineMarker(timelineMarker: TimelineMarker): void {\n    this.config.metadata.markers.push(timelineMarker);\n    this.config.events.onUpdated.dispatch(this);\n  }\n\n  /**\n   * Removes a marker from the timeline (by reference) and returns `true` if the marker has\n   * been part of the timeline and successfully removed, or `false` if the marker could not\n   * be found and thus not removed.\n   */\n  removeTimelineMarker(timelineMarker: TimelineMarker): boolean {\n    if (ArrayUtils.remove(this.config.metadata.markers, timelineMarker) === timelineMarker) {\n      this.config.events.onUpdated.dispatch(this);\n      return true;\n    }\n\n    return false;\n  }\n}\n\nexport interface UIAudioOnlyOverlayConfig {\n    backgroundImageUrl?: string;\n    hiddeIndicator?: boolean;\n}\n\nexport interface MIUIConfig extends UIConfig {\n    audioOnlyOverlayConfig?: UIAudioOnlyOverlayConfig;\n}\n\nexport namespace UIManager.Factory {\n\n  export function buildAudioVideoUI(player: PlayerAPI, config: MIUIConfig = {}): UIManager {    // show smallScreen UI only on mobile/handheld devices\n    let smallScreenSwitchWidth = 600;\n\n    return new UIManager(player, [{\n      ui: modernSmallScreenUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n      },\n    }, {\n      ui: modernUI(),\n    }], config);\n  }\n\n  export function buildAudioOnlyUI(player: PlayerAPI, config: MIUIConfig = {}): UIManager {   // show smallScreen UI only on mobile/handheld devices\n    let smallScreenSwitchWidth = 600;\n\n    return new UIManager(player, [{\n      ui: modernAudioOnlySmallScreenUI(),\n      condition: (context: UIConditionContext) => {\n        return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n      },\n    }, {\n      ui: modernAudioOnlyUI(),\n    }], config);\n  }\n\n  // export function buildDefaultUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return UIManager.Factory.buildModernUI(player, config);\n  // }\n\n  // export function buildDefaultSmallScreenUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return UIManager.Factory.buildModernSmallScreenUI(player, config);\n  // }\n\n  // export function buildDefaultCastReceiverUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return UIManager.Factory.buildModernCastReceiverUI(player, config);\n  // }\n\n  function modernUI() {\n    let subtitleOverlay = new SubtitleOverlay();\n\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n      ],\n      hidden: true,\n    });\n\n    let subtitleSettingsPanel = new SubtitleSettingsPanel({\n      hidden: true,\n      overlay: subtitleOverlay,\n      settingsPanel: settingsPanel,\n    });\n\n    let subtitleSettingsOpenButton = new SubtitleSettingsOpenButton({\n      subtitleSettingsPanel: subtitleSettingsPanel,\n      settingsPanel: settingsPanel,\n    });\n\n    settingsPanel.addComponent(\n      new SettingsPanelItem(\n        new SubtitleSettingsLabel({text: 'Subtitles', opener: subtitleSettingsOpenButton}),\n        new SubtitleSelectBox()\n    ));\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        subtitleSettingsPanel,\n        new Container({\n          components: [\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true }),\n            new SeekBar({ label: new SeekBarLabel() }),\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right'] }),\n          ],\n          cssClasses: ['controlbar-top'],\n        }),\n        new Container({\n          components: [\n            new PlaybackToggleButton(),\n            new VolumeToggleButton(),\n            new VolumeSlider(),\n            new Spacer(),\n            new PictureInPictureToggleButton(),\n            new AirPlayToggleButton(),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new SettingsToggleButton({ settingsPanel: settingsPanel }),\n            new FullscreenToggleButton(),\n          ],\n          cssClasses: ['controlbar-bottom'],\n        }),\n      ],\n    });\n\n    return new UIContainer({\n      components: [\n        subtitleOverlay,\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new CastStatusOverlay(),\n        controlBar,\n        // new TitleBar(),\n        new RecommendationOverlay(),\n        // new Watermark(),\n        new ErrorMessageOverlay(),\n      ],\n      cssClasses: ['ui-skin-mi-wbc'],\n    });\n  }\n\n  function modernAudioOnlyUI() {\n    let subtitleOverlay = new SubtitleOverlay();\n\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n      ],\n      hidden: true,\n    });\n\n    let subtitleSettingsPanel = new SubtitleSettingsPanel({\n      hidden: true,\n      overlay: subtitleOverlay,\n      settingsPanel: settingsPanel,\n    });\n\n    let subtitleSettingsOpenButton = new SubtitleSettingsOpenButton({\n      subtitleSettingsPanel: subtitleSettingsPanel,\n      settingsPanel: settingsPanel,\n    });\n\n    settingsPanel.addComponent(\n      new SettingsPanelItem(\n        new SubtitleSettingsLabel({text: 'Subtitles', opener: subtitleSettingsOpenButton}),\n        new SubtitleSelectBox()\n    ));\n\n    let controlBar = new ControlBar({\n      components: [\n        settingsPanel,\n        subtitleSettingsPanel,\n        new Container({\n          components: [\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true }),\n            new SeekBar({ label: new SeekBarLabel() }),\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right'] }),\n          ],\n          cssClasses: ['controlbar-top'],\n        }),\n        new Container({\n          components: [\n            new PlaybackToggleButton(),\n            new VolumeToggleButton(),\n            new VolumeSlider(),\n            new Spacer(),\n            new AirPlayToggleButton(),\n            new CastToggleButton(),\n            new SettingsToggleButton({ settingsPanel: settingsPanel }),\n            new FullscreenToggleButton(),\n          ],\n          cssClasses: ['controlbar-bottom'],\n        }),\n      ],\n    });\n\n    return new UIContainer({\n      components: [\n        new AudioOnlyOverlay(),\n        subtitleOverlay,\n        new BufferingOverlay(),\n        new PlaybackToggleOverlay(),\n        new CastStatusOverlay(),\n        controlBar,\n        // new TitleBar(),\n        new RecommendationOverlay(),\n        // new Watermark(),\n        new ErrorMessageOverlay(),\n      ],\n      cssClasses: ['ui-skin-mi-wbc'],\n    });\n  }\n  // function modernAdsUI() {\n  //   return new UIContainer({\n  //     components: [\n  //       new BufferingOverlay(),\n  //       new AdClickOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new Container({\n  //         components: [\n  //           new AdMessageLabel({ text: 'Ad: {remainingTime} secs' }),\n  //           new AdSkipButton(),\n  //         ],\n  //         cssClass: 'ui-ads-status',\n  //       }),\n  //       new ControlBar({\n  //         components: [\n  //           new Container({\n  //             components: [\n  //               new PlaybackToggleButton(),\n  //               new VolumeToggleButton(),\n  //               new VolumeSlider(),\n  //               new Spacer(),\n  //               new FullscreenToggleButton(),\n  //             ],\n  //             cssClasses: ['controlbar-bottom'],\n  //           }),\n  //         ],\n  //       }),\n  //     ],\n  //     cssClasses: ['ui-skin-mi-wbc', 'ui-skin-ads'],\n  //   });\n  // }\n\n  function modernSmallScreenUI() {\n    let subtitleOverlay = new SubtitleOverlay();\n\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n      ],\n      hidden: true,\n      hideDelay: -1,\n    });\n\n    let subtitleSettingsPanel = new SubtitleSettingsPanel({\n      hidden: true,\n      hideDelay: -1,\n      overlay: subtitleOverlay,\n      settingsPanel: settingsPanel,\n    });\n\n    let subtitleSettingsOpenButton = new SubtitleSettingsOpenButton({\n      subtitleSettingsPanel: subtitleSettingsPanel,\n      settingsPanel: settingsPanel,\n    });\n\n    settingsPanel.addComponent(\n      new SettingsPanelItem(\n        new SubtitleSettingsLabel({text: 'Subtitles', opener: subtitleSettingsOpenButton}),\n        new SubtitleSelectBox()\n    ));\n\n    settingsPanel.addComponent(new CloseButton({ target: settingsPanel }));\n    subtitleSettingsPanel.addComponent(new CloseButton({ target: subtitleSettingsPanel }));\n\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true }),\n            new SeekBar({ label: new SeekBarLabel() }),\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right'] }),\n          ],\n          cssClasses: ['controlbar-top'],\n        }),\n      ],\n    });\n\n    return new UIContainer({\n      components: [\n        subtitleOverlay,\n        new BufferingOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar({\n          components: [\n            new MetadataLabel({ content: MetadataLabelContent.Title }),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new VolumeToggleButton(),\n            new SettingsToggleButton({ settingsPanel: settingsPanel }),\n            new FullscreenToggleButton(),\n          ],\n        }),\n        settingsPanel,\n        subtitleSettingsPanel,\n        new RecommendationOverlay(),\n        // new Watermark(),\n        new ErrorMessageOverlay(),\n      ],\n      cssClasses: ['ui-skin-mi-wbc', 'ui-skin-smallscreen'],\n    });\n  }\n\n  function modernAudioOnlySmallScreenUI() {\n    let subtitleOverlay = new SubtitleOverlay();\n\n    let settingsPanel = new SettingsPanel({\n      components: [\n        new SettingsPanelItem('Speed', new PlaybackSpeedSelectBox()),\n        new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n        new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n      ],\n      hidden: true,\n      hideDelay: -1,\n    });\n\n    let subtitleSettingsPanel = new SubtitleSettingsPanel({\n      hidden: true,\n      hideDelay: -1,\n      overlay: subtitleOverlay,\n      settingsPanel: settingsPanel,\n    });\n\n    let subtitleSettingsOpenButton = new SubtitleSettingsOpenButton({\n      subtitleSettingsPanel: subtitleSettingsPanel,\n      settingsPanel: settingsPanel,\n    });\n\n    settingsPanel.addComponent(\n      new SettingsPanelItem(\n        new SubtitleSettingsLabel({text: 'Subtitles', opener: subtitleSettingsOpenButton}),\n        new SubtitleSelectBox()\n    ));\n\n    settingsPanel.addComponent(new CloseButton({ target: settingsPanel }));\n    subtitleSettingsPanel.addComponent(new CloseButton({ target: subtitleSettingsPanel }));\n\n    let controlBar = new ControlBar({\n      components: [\n        new Container({\n          components: [\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true }),\n            new SeekBar({ label: new SeekBarLabel() }),\n            new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right'] }),\n          ],\n          cssClasses: ['controlbar-top'],\n        }),\n      ],\n    });\n\n    return new UIContainer({\n      components: [\n        new AudioOnlyOverlay(),\n        subtitleOverlay,\n        new BufferingOverlay(),\n        new CastStatusOverlay(),\n        new PlaybackToggleOverlay(),\n        controlBar,\n        new TitleBar({\n          components: [\n            new MetadataLabel({ content: MetadataLabelContent.Title }),\n            new CastToggleButton(),\n            new VRToggleButton(),\n            new VolumeToggleButton(),\n            new SettingsToggleButton({ settingsPanel: settingsPanel }),\n            new FullscreenToggleButton(),\n          ],\n        }),\n        settingsPanel,\n        subtitleSettingsPanel,\n        new RecommendationOverlay(),\n        // new Watermark(),\n        new ErrorMessageOverlay(),\n      ],\n      cssClasses: ['ui-skin-mi-wbc', 'ui-skin-smallscreen'],\n    });\n  }\n\n  // function modernSmallScreenAdsUI() {\n  //   return new UIContainer({\n  //     components: [\n  //       new BufferingOverlay(),\n  //       new AdClickOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new TitleBar({\n  //         components: [\n  //           // dummy label with no content to move buttons to the right\n  //           new Label({ cssClass: 'label-metadata-title' }),\n  //           new FullscreenToggleButton(),\n  //         ],\n  //       }),\n  //       new Container({\n  //         components: [\n  //           new AdMessageLabel({ text: 'Ad: {remainingTime} secs' }),\n  //           new AdSkipButton(),\n  //         ],\n  //         cssClass: 'ui-ads-status',\n  //       }),\n  //     ],\n  //     cssClasses: ['ui-skin-mi-wbc', 'ui-skin-ads', 'ui-skin-smallscreen'],\n  //   });\n  // }\n\n  // function modernCastReceiverUI() {\n  //   let controlBar = new ControlBar({\n  //     components: [\n  //       new Container({\n  //         components: [\n  //           new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.CurrentTime, hideInLivePlayback: true }),\n  //           new SeekBar({ smoothPlaybackPositionUpdateIntervalMs: -1 }),\n  //           new PlaybackTimeLabel({ timeLabelMode: PlaybackTimeLabelMode.TotalTime, cssClasses: ['text-right'] }),\n  //         ],\n  //         cssClasses: ['controlbar-top'],\n  //       }),\n  //     ],\n  //   });\n\n  //   return new CastUIContainer({\n  //     components: [\n  //       new SubtitleOverlay(),\n  //       new BufferingOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new Watermark(),\n  //       controlBar,\n  //       new TitleBar({ keepHiddenWithoutMetadata: true }),\n  //       new ErrorMessageOverlay(),\n  //     ],\n  //     cssClasses: ['ui-skin-mi-wbc', 'ui-skin-cast-receiver'],\n  //   });\n  // }\n\n  // export function buildModernUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   // show smallScreen UI only on mobile/handheld devices\n  //   let smallScreenSwitchWidth = 600;\n\n  //   return new UIManager(player, [{\n  //     ui: modernSmallScreenAdsUI(),\n  //     condition: (context: UIConditionContext) => {\n  //       return context.isMobile && context.documentWidth < smallScreenSwitchWidth && context.isAdWithUI;\n  //     },\n  //   }, {\n  //     ui: modernAdsUI(),\n  //     condition: (context: UIConditionContext) => {\n  //       return context.isAdWithUI;\n  //     },\n  //   }, {\n  //     ui: modernSmallScreenUI(),\n  //     condition: (context: UIConditionContext) => {\n  //       return context.isMobile && context.documentWidth < smallScreenSwitchWidth;\n  //     },\n  //   }, {\n  //     ui: modernUI(),\n  //   }], config);\n  // }\n\n  // export function buildModernSmallScreenUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return new UIManager(player, [{\n  //     ui: modernSmallScreenAdsUI(),\n  //     condition: (context: UIConditionContext) => {\n  //       return context.isAdWithUI;\n  //     },\n  //   }, {\n  //     ui: modernSmallScreenUI(),\n  //   }], config);\n  // }\n\n  // export function buildModernCastReceiverUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return new UIManager(player, modernCastReceiverUI(), config);\n  // }\n\n  // function legacyUI() {\n  //   let settingsPanel = new SettingsPanel({\n  //     components: [\n  //       new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n  //       new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n  //       new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n  //       new SettingsPanelItem('Subtitles', new SubtitleSelectBox()),\n  //     ],\n  //     hidden: true,\n  //   });\n\n  //   let controlBar = new ControlBar({\n  //     components: [\n  //       settingsPanel,\n  //       new PlaybackToggleButton(),\n  //       new SeekBar({ label: new SeekBarLabel() }),\n  //       new PlaybackTimeLabel(),\n  //       new VRToggleButton(),\n  //       new VolumeControlButton(),\n  //       new SettingsToggleButton({ settingsPanel: settingsPanel }),\n  //       new CastToggleButton(),\n  //       new FullscreenToggleButton(),\n  //     ],\n  //   });\n\n  //   return new UIContainer({\n  //     components: [\n  //       new SubtitleOverlay(),\n  //       new CastStatusOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new Watermark(),\n  //       new RecommendationOverlay(),\n  //       controlBar,\n  //       new TitleBar(),\n  //       new ErrorMessageOverlay(),\n  //     ],\n  //     cssClasses: ['ui-skin-legacy'],\n  //   });\n  // }\n\n  // function legacyAdsUI() {\n  //   return new UIContainer({\n  //     components: [\n  //       new AdClickOverlay(),\n  //       new ControlBar({\n  //         components: [\n  //           new PlaybackToggleButton(),\n  //           new AdMessageLabel(),\n  //           new VolumeControlButton(),\n  //           new FullscreenToggleButton(),\n  //         ],\n  //       }),\n  //       new AdSkipButton(),\n  //     ],\n  //     cssClasses: ['ui-skin-legacy', 'ui-skin-ads'],\n  //   });\n  // }\n\n  // function legacyCastReceiverUI() {\n  //   let controlBar = new ControlBar({\n  //     components: [\n  //       new SeekBar(),\n  //       new PlaybackTimeLabel(),\n  //     ],\n  //   });\n\n  //   return new UIContainer({\n  //     components: [\n  //       new SubtitleOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new Watermark(),\n  //       controlBar,\n  //       new TitleBar(),\n  //       new ErrorMessageOverlay(),\n  //     ],\n  //     cssClasses: ['ui-skin-legacy', 'ui-skin-cast-receiver'],\n  //   });\n  // }\n\n  // function legacyTestUI() {\n  //   let settingsPanel = new SettingsPanel({\n  //     components: [\n  //       new SettingsPanelItem('Video Quality', new VideoQualitySelectBox()),\n  //       new SettingsPanelItem('Audio Track', new AudioTrackSelectBox()),\n  //       new SettingsPanelItem('Audio Quality', new AudioQualitySelectBox()),\n  //       new SettingsPanelItem('Subtitles', new SubtitleSelectBox()),\n  //     ],\n  //     hidden: true,\n  //   });\n\n  //   let controlBar = new ControlBar({\n  //     components: [settingsPanel,\n  //       new PlaybackToggleButton(),\n  //       new SeekBar({ label: new SeekBarLabel() }),\n  //       new PlaybackTimeLabel(),\n  //       new VRToggleButton(),\n  //       new VolumeToggleButton(),\n  //       new VolumeSlider(),\n  //       new VolumeControlButton(),\n  //       new VolumeControlButton({ vertical: false }),\n  //       new SettingsToggleButton({ settingsPanel: settingsPanel }),\n  //       new CastToggleButton(),\n  //       new FullscreenToggleButton(),\n  //     ],\n  //   });\n\n  //   return new UIContainer({\n  //     components: [\n  //       new SubtitleOverlay(),\n  //       new CastStatusOverlay(),\n  //       new PlaybackToggleOverlay(),\n  //       new Watermark(),\n  //       new RecommendationOverlay(),\n  //       controlBar,\n  //       new TitleBar(),\n  //       new ErrorMessageOverlay(),\n  //     ],\n  //     cssClasses: ['ui-skin-legacy'],\n  //   });\n  // }\n\n  // export function buildLegacyUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return new UIManager(player, [{\n  //     ui: legacyAdsUI(),\n  //     condition: (context: UIConditionContext) => {\n  //       return context.isAdWithUI;\n  //     },\n  //   }, {\n  //     ui: legacyUI(),\n  //   }], config);\n  // }\n\n  // export function buildLegacyCastReceiverUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return new UIManager(player, legacyCastReceiverUI(), config);\n  // }\n\n  // export function buildLegacyTestUI(player: PlayerAPI, config: UIConfig = {}): UIManager {\n  //   return new UIManager(player, legacyTestUI(), config);\n  // }\n}\n\nexport interface SeekPreviewArgs extends NoArgs {\n  /**\n   * The timeline position in percent where the event originates from.\n   */\n  position: number;\n  /**\n   * The timeline marker associated with the current position, if existing.\n   */\n  marker?: SeekBarMarker;\n}\n\n/**\n * Encapsulates functionality to manage a UI instance. Used by the {@link UIManager} to manage multiple UI instances.\n */\nexport class UIInstanceManager {\n  private playerWrapper: PlayerWrapper;\n  private ui: UIContainer;\n  private config: InternalUIConfig;\n\n  private events = {\n    onConfigured: new EventDispatcher<UIContainer, NoArgs>(),\n    onSeek: new EventDispatcher<SeekBar, NoArgs>(),\n    onSeekPreview: new EventDispatcher<SeekBar, SeekPreviewArgs>(),\n    onSeeked: new EventDispatcher<SeekBar, NoArgs>(),\n    onComponentShow: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onComponentHide: new EventDispatcher<Component<ComponentConfig>, NoArgs>(),\n    onControlsShow: new EventDispatcher<UIContainer, NoArgs>(),\n    onPreviewControlsHide: new EventDispatcher<UIContainer, CancelEventArgs>(),\n    onControlsHide: new EventDispatcher<UIContainer, NoArgs>(),\n    onRelease: new EventDispatcher<UIContainer, NoArgs>(),\n  };\n\n  constructor(player: PlayerAPI, ui: UIContainer, config: InternalUIConfig) {\n    this.playerWrapper = new PlayerWrapper(player);\n    this.ui = ui;\n    this.config = config;\n  }\n\n  getConfig(): InternalUIConfig {\n    return this.config;\n  }\n\n  getUI(): UIContainer {\n    return this.ui;\n  }\n\n  getPlayer(): PlayerAPI {\n    return this.playerWrapper.getPlayer();\n  }\n\n  /**\n   * Fires when the UI is fully configured and added to the DOM.\n   * @returns {EventDispatcher}\n   */\n  get onConfigured(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onConfigured;\n  }\n\n  /**\n   * Fires when a seek starts.\n   * @returns {EventDispatcher}\n   */\n  get onSeek(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeek;\n  }\n\n  /**\n   * Fires when the seek timeline is scrubbed.\n   * @returns {EventDispatcher}\n   */\n  get onSeekPreview(): EventDispatcher<SeekBar, SeekPreviewArgs> {\n    return this.events.onSeekPreview;\n  }\n\n  /**\n   * Fires when a seek is finished.\n   * @returns {EventDispatcher}\n   */\n  get onSeeked(): EventDispatcher<SeekBar, NoArgs> {\n    return this.events.onSeeked;\n  }\n\n  /**\n   * Fires when a component is showing.\n   * @returns {EventDispatcher}\n   */\n  get onComponentShow(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentShow;\n  }\n\n  /**\n   * Fires when a component is hiding.\n   * @returns {EventDispatcher}\n   */\n  get onComponentHide(): EventDispatcher<Component<ComponentConfig>, NoArgs> {\n    return this.events.onComponentHide;\n  }\n\n  /**\n   * Fires when the UI controls are showing.\n   * @returns {EventDispatcher}\n   */\n  get onControlsShow(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsShow;\n  }\n\n  /**\n   * Fires before the UI controls are hiding to check if they are allowed to hide.\n   * @returns {EventDispatcher}\n   */\n  get onPreviewControlsHide(): EventDispatcher<UIContainer, CancelEventArgs> {\n    return this.events.onPreviewControlsHide;\n  }\n\n  /**\n   * Fires when the UI controls are hiding.\n   * @returns {EventDispatcher}\n   */\n  get onControlsHide(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onControlsHide;\n  }\n\n  /**\n   * Fires when the UI controls are released.\n   * @returns {EventDispatcher}\n   */\n  get onRelease(): EventDispatcher<UIContainer, NoArgs> {\n    return this.events.onRelease;\n  }\n\n  protected clearEventHandlers(): void {\n    this.playerWrapper.clearEventHandlers();\n\n    let events = <any>this.events; // avoid TS7017\n    for (let event in events) {\n      let dispatcher = <EventDispatcher<Object, Object>>events[event];\n      dispatcher.unsubscribeAll();\n    }\n  }\n}\n\n/**\n * Extends the {@link UIInstanceManager} for internal use in the {@link UIManager} and provides access to functionality\n * that components receiving a reference to the {@link UIInstanceManager} should not have access to.\n */\nclass InternalUIInstanceManager extends UIInstanceManager {\n\n  private configured: boolean;\n  private released: boolean;\n\n  getWrappedPlayer(): WrappedPlayer {\n    // TODO find a non-hacky way to provide the WrappedPlayer to the UIManager without exporting it\n    // getPlayer() actually returns the WrappedPlayer but its return type is set to Player so the WrappedPlayer does\n    // not need to be exported\n    return <WrappedPlayer>this.getPlayer();\n  }\n\n  configureControls(): void {\n    this.configureControlsTree(this.getUI());\n    this.configured = true;\n  }\n\n  isConfigured(): boolean {\n    return this.configured;\n  }\n\n  private configureControlsTree(component: Component<ComponentConfig>) {\n    let configuredComponents: Component<ComponentConfig>[] = [];\n\n    UIUtils.traverseTree(component, (component) => {\n      // First, check if we have already configured a component, and throw an error if we did. Multiple configuration\n      // of the same component leads to unexpected UI behavior. Also, a component that is in the UI tree multiple\n      // times hints at a wrong UI structure.\n      // We could just skip configuration in such a case and not throw an exception, but enforcing a clean UI tree\n      // seems like the better choice.\n      for (let configuredComponent of configuredComponents) {\n        if (configuredComponent === component) {\n          // Write the component to the console to simplify identification of the culprit\n          // (e.g. by inspecting the config)\n          if (console) {\n            console.error('Circular reference in UI tree', component);\n          }\n\n          // Additionally throw an error, because this case must not happen and leads to unexpected UI behavior.\n          throw Error('Circular reference in UI tree: ' + component.constructor.name);\n        }\n      }\n\n      component.initialize();\n      component.configure(this.getPlayer(), this);\n      configuredComponents.push(component);\n    });\n  }\n\n  releaseControls(): void {\n    // Do not call release methods if the components have never been configured; this can result in exceptions\n    if (this.configured) {\n      this.onRelease.dispatch(this.getUI());\n      this.releaseControlsTree(this.getUI());\n      this.configured = false;\n    }\n    this.released = true;\n  }\n\n  isReleased(): boolean {\n    return this.released;\n  }\n\n  private releaseControlsTree(component: Component<ComponentConfig>) {\n    component.release();\n\n    if (component instanceof Container) {\n      for (let childComponent of component.getComponents()) {\n        this.releaseControlsTree(childComponent);\n      }\n    }\n  }\n\n  clearEventHandlers(): void {\n    super.clearEventHandlers();\n  }\n}\n\n/**\n * Extended interface of the {@link Player} for use in the UI.\n */\ninterface WrappedPlayer extends PlayerAPI {\n  /**\n   * Fires an event on the player that targets all handlers in the UI but never enters the real player.\n   * @param event the event to fire\n   * @param data data to send with the event\n   */\n  fireEventInUI(event: EVENT, data: {}): void;\n}\n\n/**\n * Wraps the player to track event handlers and provide a simple method to remove all registered event\n * handlers from the player.\n */\nclass PlayerWrapper {\n\n  private player: PlayerAPI;\n  private wrapper: WrappedPlayer;\n\n  private eventHandlers: { [eventType: string]: PlayerEventCallback[]; } = {};\n\n  constructor(player: PlayerAPI) {\n    this.player = player;\n\n    // Collect all members of the player (public API methods and properties of the player)\n    // (Object.getOwnPropertyNames(player) does not work with the player TypeScript class starting in 7.2)\n    let members: string[] = [];\n    for (let member in player) {\n      members.push(member);\n    }\n\n    // Split the members into methods and properties\n    let methods = <any[]>[];\n    let properties = <any[]>[];\n\n    for (let member of members) {\n      if (typeof (<any>player)[member] === 'function') {\n        methods.push(member);\n      } else {\n        properties.push(member);\n      }\n    }\n\n    // Create wrapper object\n    let wrapper = <any>{};\n\n    // Add function wrappers for all API methods that do nothing but calling the base method on the player\n    for (let method of methods) {\n      wrapper[method] = function() {\n        // console.log('called ' + member); // track method calls on the player\n        return (<any>player)[method].apply(player, arguments);\n      };\n    }\n\n    // Add all public properties of the player to the wrapper\n    for (let property of properties) {\n      // Get an eventually existing property descriptor to differentiate between plain properties and properties with\n      // getters/setters.\n      let propertyDescriptor: PropertyDescriptor = Object.getOwnPropertyDescriptor(player, property) ||\n        Object.getOwnPropertyDescriptor(Object.getPrototypeOf(player), property);\n\n      // If the property has getters/setters, wrap them accordingly...\n      if (propertyDescriptor && (propertyDescriptor.get || propertyDescriptor.set)) {\n        Object.defineProperty(wrapper, property, {\n          get: () => propertyDescriptor.get.call(player),\n          set: (value: any) => propertyDescriptor.set.call(player, value),\n        });\n      }\n      // ... else just transfer the property to the wrapper\n      else {\n        wrapper[property] = (<any>player)[property];\n      }\n    }\n\n    // Explicitly add a wrapper method for 'addEventHandler' that adds added event handlers to the event list\n    wrapper.addEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      // in player V8 addEventHandler was replaced by on\n      if (player.on) {\n        player.on(eventType, callback);\n      } else {\n        // keep backward compatibility for versions <7.7\n        player.addEventHandler(eventType, callback);\n      }\n\n      if (!this.eventHandlers[eventType]) {\n        this.eventHandlers[eventType] = [];\n      }\n\n      this.eventHandlers[eventType].push(callback);\n\n      return wrapper;\n    };\n\n    // Explicitly add a wrapper method for 'removeEventHandler' that removes removed event handlers from the event list\n    wrapper.removeEventHandler = (eventType: EVENT, callback: PlayerEventCallback) => {\n      if (player.off) {\n        player.off(eventType, callback);\n      } else {\n        // keep backward compatibility for versions <7.7\n        player.removeEventHandler(eventType, callback);\n      }\n\n      if (this.eventHandlers[eventType]) {\n        ArrayUtils.remove(this.eventHandlers[eventType], callback);\n      }\n\n      return wrapper;\n    };\n\n    wrapper.fireEventInUI = (event: EVENT, data: {}) => {\n      if (this.eventHandlers[event]) { // check if there are handlers for this event registered\n        // Extend the data object with default values to convert it to a {@link PlayerEvent} object.\n        let playerEventData = <PlayerEvent>Object.assign({}, {\n          timestamp: Date.now(),\n          type: event,\n          // Add a marker property so the UI can detect UI-internal player events\n          uiSourced: true,\n        }, data);\n\n        // Execute the registered callbacks\n        for (let callback of this.eventHandlers[event]) {\n          callback(playerEventData);\n        }\n      }\n    };\n\n    this.wrapper = <WrappedPlayer>wrapper;\n  }\n\n  /**\n   * Returns a wrapped player object that can be used on place of the normal player object.\n   * @returns {WrappedPlayer} a wrapped player\n   */\n  getPlayer(): WrappedPlayer {\n    return this.wrapper;\n  }\n\n  /**\n   * Clears all registered event handlers from the player that were added through the wrapped player.\n   */\n  clearEventHandlers(): void {\n    for (let eventType in this.eventHandlers) {\n      for (let callback of this.eventHandlers[eventType]) {\n        this.player.removeEventHandler(eventType, callback);\n      }\n    }\n  }\n}\n\n","import {Component, ComponentConfig} from './components/component';\nimport {Container} from './components/container';\n\nexport namespace UIUtils {\n  export interface TreeTraversalCallback {\n    (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>): void;\n  }\n\n  export function traverseTree(component: Component<ComponentConfig>, visit: TreeTraversalCallback): void {\n    let recursiveTreeWalker = (component: Component<ComponentConfig>, parent?: Component<ComponentConfig>) => {\n      visit(component, parent);\n\n      // If the current component is a container, visit it's children\n      if (component instanceof Container) {\n        for (let childComponent of component.getComponents()) {\n          recursiveTreeWalker(childComponent, component);\n        }\n      }\n    };\n\n    // Walk and configure the component tree\n    recursiveTreeWalker(component);\n  }\n}\n"]}